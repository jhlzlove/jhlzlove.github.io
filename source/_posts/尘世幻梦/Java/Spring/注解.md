---
title: Java注解总结和一些说明
categories:
  - Java
  - 注解
music:
  server: netease
  type: song
  id: 440403990
  img: null
abbrlink: ae731a06
---

Java 及 Java 框架的注解的整理

<!-- more -->

# Java 及 Java 框架的注解的整理
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=true} -->

<!-- code_chunk_output -->

- [Java 及 Java 框架的注解的整理](#java-及-java-框架的注解的整理)
  - [注解](#注解)
    - [Spring 注解](#spring-注解)
    - [Mybatis 注解](#mybatis-注解)
    - [一些注解说明](#一些注解说明)
  - [1. @Async 的使用](#1-async-的使用)
  - [2. CompletableFuture](#2-completablefuture)
    - [Service 代码](#service-代码)
    - [测试代码](#测试代码)
  - [3. 线程池数量](#3-线程池数量)
  - [类](#类)

<!-- /code_chunk_output -->

## 注解

### Spring 注解

{% gallery %}
![Spring 注解总结](https://cdn.jsdelivr.net/gh/prettywinter/dist/images/doc/Spring注解总结.png "Spring 注解总结")
{% endgallery %}

### Mybatis 注解
{% gallery %}
![Mybatis 注解](https://cdn.jsdelivr.net/gh/prettywinter/dist/images/doc/mybatis注解总结.png "Mybatis 注解")
{% endgallery %}

### 一些注解说明
@ControllerAdvice 注解常与 @ExceptionHandler 注解联合用于自定义全局异常处理。
@ControllerAdvice 是Spring3.2提供的新注解，是一个 Controller 的增强器，可对 controller 中 @RequestMapping 注解的方法加一些逻辑处理。
@ExceptionHandler 用来指明异常类


@ResponseBody 底层集成了 jaskson，所以可以把对象等信息转换为 json 字符串。


## 1. @Async 的使用

Spring 提供了 异步执行的代码的功能,能让我们以多线程的方式执行,但是spring 中自带的@Async 注解执行异步时并没有使用线程池的概念, 导致如果同时执行多个任务可能出现把系统资源耗尽的情况.

对此,spingBoot 一做好了优化,默认使用线程池执行任务



在springboot 项目中需要异步执行的代码上加上注解 @Async,同时在启动类上加上@EnableAsync即可如下

```java
@SpringBootApplication
@EnableAsync
public class AnsyApplication {
    public static void main(String[] args) {
        SpringApplication.run(AnsyApplication.class, args);
    }
}
```



```java
 @Async
 public void test() throws InterruptedException {
     Thread.sleep(1000);
     System.out.println("子线程执行了");
 }
```

测试代码

```java
@RunWith(SpringRunner.class)
@SpringBootTest(classes = AnsyApplication.class)
public class TestDemo {
    @Autowired
    AnsyService service;
    @Test
    public void testDemo() throws Exception{
        service.test();
        System.out.println("主线程执行了");
         //阻塞当前的主线程，等待异步执行的结束
       Thread.sleep(2000);
    }
```

## 2. CompletableFuture

 此时主线程是不知道子线程什么时候执行结束的, 也不知道执行的结果是什么

如果想要更方便的获取结果, jdk 1.8 提供了 CompletableFuture

### Service 代码

```java
@Service
public class AnsyService {
    @Async
    public CompletableFuture<String> test2() throws InterruptedException {
        Thread.sleep(1000);
        System.out.println("子线程执行了2"+new Date()+Thread.currentThread().getName());
        return  CompletableFuture.completedFuture("ok");
    }
}
```

### 测试代码

```java
 @Test
    public void testDemo2() throws InterruptedException {

            CompletableFuture<String> future = service.test2();
            future.whenComplete((s, throwable) -> {
                System.out.println("执行完成：" + s);
            });
            System.out.println("主线程执行了");



            try {
                future.get(); //阻塞当前的主线程，等待异步执行的结束
                // 测试时使用, tomcat 中运行的diamante无需加这个,因为 tomcat一直在运行
            } catch (Exception e) {
                e.printStackTrace();
            }
    }
```

## 3. 线程池数量

Sprigboot 默认线程池数量是8个,   我们可以修改默认的配置将如下代码放入 启动类中即可

```java
@Bean
    public AsyncTaskExecutor asyncTaskExecutor() {
        ThreadPoolTaskExecutor asyncTaskExecutor = new ThreadPoolTaskExecutor();
        asyncTaskExecutor.setCorePoolSize(15);// 设置线程池初始大小
        asyncTaskExecutor.setMaxPoolSize(50);// 设置线程池最大大小
        asyncTaskExecutor.initialize();// 一定不要忘了这句代码,进行初始化
        return asyncTaskExecutor;
    }
```


## 类
ResponseBodyAdvice 类中有两个方法，supports() 和 beforeBodyWrite()，supports() 方法确定是否执行后面的方法，可以确定程序中的那些类或者那些方法需要对结果进行处理。beforeBodyWrite() 对 Controller 返回的结果做统一封装，例如字段脱敏或者加密等。


@Component 衍生注解，本质就是 @Component 注解
@Repository/@Mapper DAO类型
@Service  Service类型
@Controller Controller 类型
提供衍生注解更加准确的表达一个类型的作用。

@ResponseBody 将控制器方法返回值转为 json 格式的字符串并响应请求
@RequestBody 将请求中 json 格式字符串自动转为 Java 中对象(复杂对象)