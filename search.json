[{"title":"琐碎人生的真实写照：2024年一地鸡毛的生活点滴与反思","path":"/2024/03/24/2024/","content":"这篇文章行文没有章法 也没有目录 就像人生的剧目总是跌宕起伏 虽然自己的家境并不优渥，但还是自己被家人保护的太好，同时也由于我并不事事和家人商量，在 2024 年开始，自己做了很多很多错误的决定，这些决定甚至影响到了我的未来。 “原本我以为”这五个字可以说是对现在的我、什么都不懂的我的最好阐述了，枉我活了这 20 多年，其实自己什么都不知道，什么都不懂。不是所有事情都像自己认为的那样。 这些决定让我本就一地鸡毛的人生更加的糟糕了，枉我活了这 20 多年，感觉都活到狗身上了，甚至活的还不如狗。 本来自己在金陵工作，去年因为公司经济不景气然后被裁掉，但是房租自己又续到了今年 5 月份。到了金陵投了半个多月的简历没有任何消息。家里说有一个小事务所可以安排，于是就和房东商量，最后只能退到 4 月 18 号，然后就回家了。押金 + 2 个月的房租都白白的扔掉了！！！ 回家之后租房 500，是老房子，租了一个季度，离税务所也近一些，由此开启了早八生活。谁曾想，从一个坑出来，又掉进了另一个坑……税务所采取的积分制，就是说你做的任何一件事都有评分标准，这个无可厚非，影响不大。主要是积分影响你的基本工资！满分 100 分，60 分及格，若当月不够 60 分，一分倒扣 20。本来就没有多少的底薪又要被扣除。繁忙的干了半个月，发现自己只有将近 30 分，我觉得当时不如进厂，心情可想而知。 这些事情把我当时攒的钱花的差不多了，出来将近两三年，什么都没攒到，我的人生，输得一塌糊涂。 有时，我甚至在想，我是不是不应该活在这个世上，污染世界的同时，也让父母为我操碎了心，与其这样，不如自己死了一了百了。但是，我怕死，真的，很怕。我其实很想谈一场戀愛，不求有多轰轰烈烈，平平淡淡的就好，估计是不会有了。 我的人生，并没有选择要什么与不要什么的权利，后面的事情一切都是未知，我其实还是想在 IT 界再滚打滚打，但是现实不允许，自己的技术实力不是很强，学历又是大专水平，在社招面前毫无竞争力可言，虽然自己现在备战专升本考试，但是好像大家都不是很喜欢继续教育的学历水平。也许吧，人口越来越多，企业的选择也是越来越多的，人人都喜欢优秀的人。至于我，根本不配。 忽然想起来以前看的一篇文章中作者写的一段话，一定要有打算，不然你只会从这个坑跳进那个坑，到最后悔之晚矣且不可回头。我和作者云泥之别。 在你能做决定的时候，不要让自己后悔。 现在只能感慨自己少不经事，没有规划，不懂事，还是需要成长与历练。知道自己可以做什么与知道自己不能做什么同样重要。"},{"title":"社会学概论","path":"/2024/03/24/社会学概论/","content":"00034 社会学概论 本科目主要有三种情况的考试题型分布: ①单项选择题 30 题，每题 1 分，共 30 分；多项选择题 5 题，每题 2 分，共 10 分；简答题 5 题，每题 6 分，共 30 分；论述题 3 题，每题 10 分，共 30 分。 ②单项选择题 30 题，每题 1 分，共 30 分；多项选择题 5 题，每题 2 分，共 10 分；简答题 5 题，每题 5 分，共 25 分；论述题 2 题，每题 10 分，共 20 分；案例分析题 1 题，每题 15 分，共15分。 ③单项选择题 30 题，每题 1 分，共 30 分；多项选择题 5 题，每题 2 分，共 10 分；简答题 5 题，每题 5 分，共 25 分；论述题 2 题，每题 10 分，共 20 分；材料题 1 题，每题 15 分，共15分。 (本科目的考试题型根据历年真题预测，仅供复习参考。) 第一章 社会学的创立与发展 ★考点1：社会学创立的历史条件(简答) (1)社会变革的需要。 (2)自然科学发展的推动。 (3)社会经验研究的积累。 (4)社会研究先驱奠定的社会思想基础。 ★考点2：社会学创立时期的主要代表(多选) (1)奥古斯特·孔德;(2)卡尔·马克思;(3)赫伯特·斯宾塞。 ★★★考点3：奥古斯特·孔德(单选、多选) 孔德致力于实证哲学体系研究，1838 年在《实证哲学教程》六卷本的第四卷首次提出社会学这一概念，标志着社会学的诞生。同时他宣告，区别于旧哲学的一种新思维，即新视野的社会学理论诞生了。由此，孔德被人们称为“社会学之父”。孔德的社会学思想可从以下三方面进行把握。 (1)科学的分类:他在圣西门的科学分类的基础上，将科学依次划分为数学、天文学、物理学、化学、生物学，最后是社会学。社会学居于科学的最高层次，是科学之“皇后”，所有其他科学都为它的建立作了准备。 (2)社会学的研究对象：孔德把社会学区分为： ①社会静力学：主要是研究社会协调的问题，即研究人类社会基本秩序的。 ②社会动力学：综合研究人类理性和人类社会发展过程，即社会进步。“秩序”和“进步”是孔德实证主义社会学的两个核心概念，是社会学研究的两大主题。 (3)研究方法:孔德主张社会学科学化，社会学是“关于社会现象根本律则的实证研究”。孔德创造的实证方法是观察法、实验法、比较法和历史法。 ★考点4：卡尔·马克思(单选) (1)主要代表著作：《1844年经济学一哲学手稿》、《德意志意识形态》、《共产党宣言》、《政治经济学批判》、《资本论》等。 (2)对社会学的贡献：①马克思是社会学的主要奠基人。②马克思创立了社会学的基础理论。③马克思的社会学理论注重实际。 ★考点5：赫伯特·斯宾塞(单选、多选)斯宾塞被誉为“维多利亚时代英国的亚里士多德”。 (1)主要社会学代表著作：《社会静力学》、《社会学研究》、《社会学原理》。 (2)社会学理论： ①社会有机体论：斯宾塞认为，社会同生物一样也是一个有机体，存在结构分化和功能分化，不同部分之间相互影响；但社会不是简单的有机体而是“超有机体”。 ②社会进化论：斯宾塞从进化论的观点出发，以社会内部的管理类型为依据，将社会区分为军事社会和工业社会。 考点6：社会学形成时期的主要代表(多选) (1)埃米尔·涂尔干;(2)马克斯·韦伯. ★★★考点7：埃米尔·涂尔干(单选、多选) (1)代表作：“三论”(《社会分工论》、《社会学方法的准则》和《自杀论》) (2)社会学观点： ①社会学的研究对象:涂尔干提出社会学的特殊对象是社会事实。所谓社会事实，乃是存在于人们自身以外的行为方式、思想方式和感觉方式，并通过一种强制力施之于每个个人。社会事实具有先在性、外在性、客观性和强制性的特点。 ②社会团结理论：社会团结是指以吸引为特征的把个人与个人、个人与群体、群体与群体协调、合作、结合在一起的社会联系状态。社会团结的核心和基础是共同的价值观和共同的道德规范，即“集体意识&quot;。所谓集体意识是指同一社会成员平均所共有的信仰和感觉的总和，构成一个独立的体系。 涂尔干把社会团结分为“机械团结”和“有机团结”两个类型。 A.机械团结是指建立在个人之间相同性与相似性特质基础上的一种社会联系。 B.直机团结是建立在社会分工和个人异质性基础上的一种社会联系状态。 ③失范理论:失范是指社会对个人的欲望和行为的调节缺乏统一规范和足够制约力的社会状态。失范的存在和发展对社会的安定和发展是不利的，涂尔干的研究旨在寻求对个人实行外在控制的力量和途径。 ④社会学研究方法准则。 ⑤功能分析和历史分析方法：功能分析 将揭示特定社会现象给整个社会或局部运动带来什么结果，而 历史分析 则揭示出为什么是这个而不是其他现象能在当时发挥特定作用。 ★★考点8：马克斯·韦伯(单选) (1)主要著作：《新教伦理与资本主义精神》、《经济与社会》等。 (2)主要观点： ①理解社会学。韦伯认为，社会学的研究对象就是社会行动。 ②社会行动类型。合理性是韦伯社会学理论的核心概念，他由此出发，将社会行动分为四种类型：A.目的一手段合理性行动;B.价值合理性行动;C.情感性行动;D.传统性行动。 ③理想类型。理想类型是韦伯用以进行历史的和社会学的比较研究的根据，也是他比较社会学的方法论基础。 ④科层制理论。马克斯·韦伯为了避免德国人文学派和历史学派的个体化和特殊化的研究方法，提出了一个关键性的概念工具，即 理想类型。(单选) 考点9：芝加哥学派 (1)芝加哥学派开拓了现代城市社区的研究道路。 (2)芝加哥学派形成了人文区位学的城市理论。 (3)芝加哥学派推动了社会学调查研究方法的形成和完善。 (4)芝加哥学派创建了符号互动论。 ★考点10：结构功能论(单选) 结构功能论兴起于 20 世纪 30 年代，即美国乃至世界经济危机时期，第二次世界大战之后成为最重要的社会学理论流派。结构功能论的关注焦点于社会均衡是如何维持和不断修复的。结构功能论的主要代表人物是帕森斯和默顿。 ★★考点11：塔尔科特·帕森斯(单选) 帕森斯深受斯宾塞、涂尔干和韦伯等早期社会学家的影响，他通过对涂尔干的功能理论和韦伯的行动理论的综合，建立了现代结构功能理论。 (1)代表著作：《社会行动的结构》和《社会系统》。 (2)其结构功能理论的重要内容：AGIL功能分析图式。 帕森斯认为任何社会若要生存就必须具备维持系统所必须的一般条件，这些必要功能条件包括了四个方面：适应、达鹄、整合和维模。 考点12：罗伯特·默顿 (1)代表著作：《社会理论与社会结构》。 (2)主要内容： 一种社会安排不会仅仅只具有一种功能，通常总是同时发挥着各种功能。其中有些功能是社会所期望和认识到的，默顿称之为显功能；有些功能则是社会所不期望或尚未认识到的，默顿称之为潜功能。结构功能分析不仅要阐明社会现象的显功能，更要揭示出社会现象的潜功能。 ★考点13：冲突理论(单选) 与结构功能论相反，冲突论认为社会冲突根源于社会结构之中；冲突总是经常性的发生，是社会的常态。冲突理论渊源于马克思的社会思想，马克思的阶级斗争理论被认为是最早、也是最深刻和最系统的冲突论。其中比较有代表性的是 科塞的功能冲突论 和 达伦多夫的辩证冲突论。 ★考点14：交换理论(单选) 交换理论 是美国社会学家霍曼斯所建立的。霍曼斯认为，人类的相互交往和社会联合都是一种交换行为，经济学的交换原则可以推广到一切社会行为，人们的互动可以被理解为酬赏的交换，一个人如何行动取决于其行动所能得到的酬赏或可能招致的惩罚。霍曼斯的理论有一个明显的缺陷，即只看到个人交换行为的心理方面，只讲交换行为建造社会结构，而没有看到社会结构对交换行为的影响。 因此另一位重要的交换理论的代表人物布劳认为，交换理论只能用来解释微观的个人之间的交换；但交换不仅发生在个人之间，也发生在个人与集团之间、集团与集团之间，而这种交换过程远比个人交换复杂。他在其著作《社会生活中的交换与权力》中指出，交换常常是在资源和权力分配的不平等基础上展开的。 ★考点15：符号互动论(多选) 符号互动论源于美国社会学家 乔治·赫伯特·米德，主要代表人物有 赫伯特·布鲁默 和 欧文·戈夫曼。 符号互动论的 基本观点 是：人类的互动是以符号为中介的，对共享的符号的理解是社会互动的基础。 考点16：社会批判理论 社会批判理论，是法兰克福学派所主张的理论道路。 (1)主要代表人物：本雅明、霍克海默、阿多诺、马尔库塞、哈贝马斯等。 (2)法兰克福学派的观点 ①法兰克福学派相信资本主义制度正在使得人们逐渐失去了批判社会的能力。 ②法兰克福学派认为在社会研究领域存在同样的问题，特别是反映在实证主义社会学的研究取向上。 ③法兰克福学派的局限性。需要指出的是，虽然法兰克福学派的社会批判理论深刻揭示了资本主义社会所存在的种种问题，却没有能够找到真正解决资本主义根本矛盾的出路，从而常常在激进否定的同时陷入历史发展的悲观主义情绪中。 ★★★考点17：当代社会学理论的代表人物(单选) (1)艾尔弗雷德·舒茨 出生于奥地利，后移民美国。创立了现象学社会学，其代表著作有《社会世界的现象学》、《生活世界的结构》。 (2)米歇尔·福柯 法国社会思想家，主要著作有《疯癫与文明》(1961)、《词与物》(1966)、《规训与惩罚》(1975)、《性史》(1976~1984)等。 (3)安东尼·吉登斯 英国社会学家，主要著作有《社会的构成》(1984)、《民族一国家与暴力》(1985)、《现代性的后果》 (1990)、《第三条道路》(1998)等。 (3)尤尔根·哈贝马斯 德国社会学家，法兰克福学派后期代表人物。主要著作有《公共领域的结构转型》(1962)、《作为意识形态的科学技术》(1968)、《合法性危机》(1975)、《交往行动理论》(1981)等。 (4)皮埃尔·布迪厄 法国社会学家，主要著作有《实践理论大纲》、《区隔》、《国家精英》、《实践与反思》等。 ★★★考点18：社会学传入中国时的重要事件(单选) 康有为 在广州长兴里万木草堂开设“群学”，将其列入“经世之学”，与“政治原理学”等并列。 谭嗣同在其所著《仁学》第一篇“仁学界说”里首次提出了“社会学”之名，认为“凡为仁学者”，应学佛学和西学，如通《新约》及算学、格致一样通社会学之书。 最早 译介西方社会学论著的是 严复。1897年，严复用古雅的文字将斯宾塞的《社会学研究》的前两章翻译为“砭愚篇”和“倡学篇”，并在上海《国闻报》上发表。全书于1903年以《群学肆言》为书名出版面世。 此前一年，章太炎翻译出版了日本女子大学社会学教授岸本能武太的《社会学》，该书综合介绍了斯宾塞的社会进化论和吉登斯(又译作吉丁斯)的早年社会心理学。 ★★考点19：中国早期社会学学科地位的确立(单选、简答) (1)队伍和制度化建设: ①社会学队伍的形成；②学校教育制度化；③学术团体的建立；④期刊和论著的发表。 (2)社会调查的兴起。 (3)马克思主义社会学的传入与实践。 李达的代表性著作之一是《社会学大纲》。(单选) ★★★考点20：社会调查的兴起(单选、多选) (1)早期自主的社会调查。近代中国科学意义上的社会调查，是以教会学校的外籍教师为主导，由中国青年教师、学生参加完成的。 (2)中国社会学者新视野的实地调查。 实地研究主要代表著作有费孝通的《江村经济》(1939)和林耀华的《金翼》(1944)等。抗日战争期，费孝通主持的云南大学社会学系研究室在艰苦的环境中坚持实地调查，取得了突出的成果。其成果包括费孝通的《禄村农田》，费孝通和张之毅的《云南三村》，史国衡的《昆厂劳工》和《个旧矿工》，田汝康的《芒市边民的摆》和《内地女工》，谷苞的《化城镇的基层行政》，胡庆钧的《呈贡基层权力结构》等。 1928年至1934年，陈翰笙率领王寅生、薛暮桥、钱俊瑞、张锡昌、姜君辰、孙冶方、林止延等人进行了三次大规模的农村调查，调查结果出版了《亩的差异》(1929)、《黑龙江流域的农民与地主》(1929)、《广东农村生产关系与生产力》(1934)和《帝国主义工业资本与中国农民》(英文版，1939)等。 ★★★考点21：“五脏六腑”说(单选、多选) “五脏六腑”是费孝通借用中医学的术语，比喻社会学的建设。 所谓五脏，是指学会组织、专业研究机构、各大学的社会学系、图书资料中心和出版物。 所谓六腑，是说一个社会学专业至少要有六门基础课程。它们是：社会学概论、社会调查研究方法、社会心理学、城乡社会学(社区概论)、文化人类学、国外社会学说。 考点22：社会学本土化(单选) 社会学本土化是一种使外来社会学与本土的优秀传统文化和现实社会的实际相结合，形成具有本土特色的社会学理论与研究方法的学术过程。 ★★考点23：中国社会学本土化目标的实现(论述) 社会学中国化与中国社会学的本土化在本质上是一致的。在中国，社会学本土化是一项长期的系统工 程。为实现这个目标： (1)应当以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想和科学发展观作为自己的行动指南，认真地开展社会现象研究; (2)把研究经济社会协调发展和人的社会化作为社会学的基本任务; (3)立足中国社会的现实，坚持理论联系实际，宏观和微观相结合，理论研究和经验研究相结合，使社会学的教学与研究能切实为我国的社会主义建设事业服务; (4)采取积极的态度，在借鉴国外社会学和中国过去社会学的优秀成果的基础上，进行创新，逐步建立中国社会学的理论知识体系，形成中国社会学学派; (5)造就一支愿意并有能力为之奋斗的社会学专业队伍。 第二章 社会学研究方法 考点1：社会学的研究对象(单选) 社会学直面社会生活，追求社会和谐，探寻人与人、人与社会的协调发展，也就自然地把个人与社会的关系看作是本学科的研究对象。 社会学这门社会科学主要研究 个人与社会的关系。(单选) ★考点2：社会学的特征(多选) (1)整体性;(2)综合性;(3)经验性;(4)应用性。 ★★★考点3：社会学的功能(单选、论述) (1)研究功能 ①描述性功能：指那些为了解和掌握发生了什么事、什么情况而进行的探索性研究。 ②解释性功能：指对影响社会事实发生、变化的主客观因素，从其因果联系上加以说明的过程。解释性功能也就是运用社会学的概念或范畴，将描述性的感性认识进行理论抽象，回答“为什么”。 ③预测性功能。和描述、解释功能相联系的高一层次的目标是预测功能。预测是要提示将来的社会事件和状态是怎样的。预测包含预见与对社会未来的测量双重涵义。 ④规范性功能。社会学者的规范性研究，是确定预定社会目标及其达到预定目标而采取的行动与手段，以及对社会目标、行动与手段的合理性可行性进行评价的过程。 (2)教育功能 ①帮助人们自觉地完成社会化。②帮助人们合理选择。 (3)社会管理功能 ①建立规范。②提供模式。③反馈信息。 (4)社会批评功能 社会学参与社会的另一个方面，就是对旧的思想、旧的观念和阻碍社会进步的事物及行为进行揭露，实事求是地进行理论分析，提出克服和解决问题的意见与建议。这种研究我们称之为 社会批评。 ★考点4：社会学方法论探讨的主要问题(多选) (1)社会现象的性质；(2)社会学的研究方法和基本假设；(3)价值在社会研究中的作用。 ★考点5：实证主义方法论(单选) 实证主义方法论，指遵循自然科学法则，用普遍的因果律研究社会现象的方法理论。实证主义方法论以孔德 《实证哲学教程》 一书的论述为代表，并经涂尔干的 《社会学方法的准则》 等著作系统阐述后日趋成熟。 实证主义方法论的基本观点是： (1)社会现象和自然现象都是客观存在，自然科学法则同样适用研究社会现象。 (2)科学的目的在于对现象的因果性作出说明，以及在此基础上对现象的未来发展趋势作出预测。 (3)提倡经验研究和社会调查。 (4)以数学和统计学为取向，特别注重量化的研究方法，并在研究方法上尽量使研究的程序与结果合乎自然科学研究的准则，包括测量的精确性、价值立场的中立性、研究程序的可重复性和研究结果的“可验证性”。 ★★考点6：人文主义方法论(单选、简答) 人文主义方法论，又称反实证主义方法论，是对社会行动过程及结果予以主观意义理论的方法。其主要代表是德国哲学家 威廉·狄尔泰 和社会学家 马克斯·韦伯，他们认为人是有自由意志的，绝不能效仿自然科学方法来研究社会科学，只能用人文主义的研究方法。 人文主义方法论的基本观点是: (1)强调自然科学与社会科学的区别。认为自然科学是探寻自然界的一般规律，而社会科学则是说明社会中的个别具体事物的联系，它具有不可重复性，也没有一般规律。 (2)社会学理论研究的目的在于“理解”而非“说明”。 (3)认为社会学研究应该立足于微观层面，从日常的、平凡的事物出发，研究人类对社会现象作出的解释以及赋予它们的意义，而不是简单地还原到自然规律的水平。 ★考点7：马克思主义社会学方法论(简答) (1)承认客观的社会规律。 (2)社会是不断发展、变化的，社会进程是人与人之间相互作用的结果。 (3)唯物史观，强调人类的历史实践活动，注重制约人的行动的社会物质环境(经济基础、生产力、社会结构)。 ★考点8：当代社会学方法论的主要流派(多选) (1)后实证主义;(2)新人文主义;(3)批判诠释理论;(4)后现代主义。 考点9：社会学的研究方式与方法 (1)统计调查;(2)问卷调查;(3)实地研究;(4)实验法;(5)文献法。 ★★★考点10：统计调查(单选、多选) (1)概念: 统计调查是根据调查的目的与要求，运用科学的调查方法，有计划、有组织地搜集数据信息资料的统计工作过程。 (2)常用方式 统计调查的常用方式是 普遍调查、抽样调查和统计报表，一般采用问卷调查收集资料。 ①普遍调查：又称全面调查，简称普查，指为特定目的而专门组织的一次性或周期性的总体调查，是统计调查的组织形式之一。 ②抽样调查：是非全面调查的一种，它是从总体中按一定的方法抽选一部分单位进行调查，并据以对总体调查研究对象作出估计和推断的一种调查方法。其本质特征是以部分代表总体。 ③统计报表：是按统一规定的表格形式，统一的报送程序和报表时间，自下而上提供基础统计资料，是一种具有法律性质的报表制度。 考点11：问卷调查 问卷调查是以一组问题获得相关、有效信息的一种方法。 ★★★考点12：实地研究(单选、多选) (1)涵义 实地研究又称田野调查，是一种深入研究对象内部，以参与观察和非结构访问的方式收集资料，并通过这些资料进行定性分析，解释社会现象的一种研究方法。 (2)指导范式 ①个案研究：是一种以某个社会单位或案例为一个整体，进行详细考察的方法。 ②典型研究：是在研究对象中，有意识地选取个别或少数具有代表性的典型社会单位进行深入和周密的实地调查研究，以推断调查总体的一种研究方法。 ③访谈：指研究者通过有计划、有目的地与被研究者交谈，进行调查和收集资料的方法。有结构访谈和非结构访谈之分。 ④观察：是指研究者有计划、有目的地用感官来考察事物或现象的知觉过程。观察法分参与观察和非参与观察。 试图通过深入地“解剖麻雀”达到对某一社会现象的全面认识，从个性发现共性，特殊认识一般，这种研究方法是 典型调查。 (单选) 考点13：做好实地研究的方法 (1)要有准备，搜索相关的文献；了解研究对象的背景; (2)制定实地研究方案; (3)作好个体或小组的定性访谈; (4)尊重对方，忠实于所研究的问题，认真作好观察记录; (5)分析综合，撰写研究报告，概括总结出新的理论和范畴。 ★★考点14：实验法(单选、多选) (1)概念：实验法是根据一定的研究假设，在有控制的条件下，通过观察、记录和分析，以发现或证实变量间或社会现象间因果关系的方法。 (2)类型 实验法的类型可从实验环境和方法上划分，前者有实地实验和实验室实验；后者可分为分标准实验、准实验、控制实验和双盲实验。 (3)作用 ①通过实验判断社会现象间或变量间的因果关系，为某一理论提出新的假设; ②通过实验发现以往未知或尚未解释的新事实，建立新的理论。 (4)社会实验的优缺点 社会实验是控制检验因果过程的重要工具。 优点： ①把实验变量与它带来的影响分离开来。 ②由于实验有明确的范围限制，省时、省力、省钱，并可重复实验，增强了效度和信度。 不足： ①实验环境的人为性；②实验过程的反应性；③实验对象的有限性；④实验结果的适应性。 ★★考点15：文献法(单选) (1)涵义 文献法，又称文件法、文案法和非介入性研究法。它不是直接从研究对象那里收集所需资料，而是通过搜集现存的以文字、数字、符号、语音、画面等信息形式出现的文献资料，在不影响研究对象的情况下，分析和探讨个人与社会关系现象的方法。 (2)文献的来源：①官方文献；②个人文献；③大众传播媒介。 (3)文献法的优缺点 ①优点： A.文献法的资料信息恒存不变; B.文献法的费用较低; C.文献法可以研究其他方法不可及的历史现象; D.文献法适于作纵贯分析。 ②缺点： A.许多文献资料的客观真实性难以考证; B.受隐私和保密等限制，相关资料不易获取; C.部分文献缺乏标准化的资料，难于编录和比较分析。 考点16：社会学研究的一般程序(单选) (1)筹划阶段;(2)实施阶段;(3)总结阶段。 ★考点17：筹划阶段的工作(简答) (1)选择研究题目，有新意，要适中，可操作。 (2)初步探索，收集相关文献资料，接触研究对象，做到“心中有底&quot;。 (3)建立研究假设，作出理论解释，明确概念。 (4)制订研究方案。研究方案一般包括明确研究内容、目的和意义，选择调查地点，确定调查对象和研究单位(个人、群体、组织和社区等)，确定研究方式方法，制定调查问卷、量表和访谈提纲，准备调查工具，统筹与预算研究经费。 (5)组织工作，包括研究人员的组成和培训，以及与协作单位的沟通等。 ★★考点18：社会学研究的分析类型(单选) (1)定性分析 ①涵义：定性分析是对收集到的资料进行归纳、分类、比较，进而对某个或某类现象的性质和特征作出概括的一种分析方法。定性分析 偏重人文主义，通过深度比较分析，揭示社会现象的本质特征。 ②定性资料的主要来源：“实地源&quot;；“文献源”。 ③意义与不足： 一般来说，实地研究和非介入性研究属于定性方法。定性研究者使用个案和情境语言，使用手头现成的东西，将社会过程和个案置于它们所处的社会情境中来考察，并探寻特定环境背景下的解释或独具的意义。 定性分析有助于发掘事物的深层原因，能够展现社会生活中复杂的细致过程和后果，但定性分析的有限个案难以反映事物总体的情况，其结论不一定具有普遍性。 (2)定量分析 ①涵义：定量分析是对社会现象的数量特征、数量关系与数量变化进行分析的一种方法。定量分析 遍重经验实证主义 的原则，强调量化的科学性、准确性。 ②定量分析的软件系统：现在广泛采用的统计性软件包是“社会科学统计程序包”(简称 SPSS)和 统计分析系统(简称 SAS)。 ★考点19：定性分析与定量分析的关系(论述) 定性分析与定量分析实质性的区别体现为数据化或非数据化。具体地说，两者的不同点有： (1)着重点不同。(2)依据不同。(3)手段不同。(4)学科基础不同。(5)结论表述形式不同。 第三章 社会与文华 ★★考点1：社会(单选、简答) (1)涵义：社会 是人们交互作用中产生的各种社会关系的总和。 (2)特征 ①社会以 人 为主体。 ②社会以 人们的物质生产活动 为基础。 ③社会以 人与人的交往 为纽带。 ④社会来源于自然又不同于自然。 ★★考点2：社会结构(单选、多选) (1)概念：社会结构是指社会诸要素之间在相互作用过程中形成的相对稳定的关系。 (2)类型 ①关系性社会结构：指社会结构按照一定的秩序和一定的相互关系组合，这种相互关系是社会结构的本质。 ②实体性社会结构：指社会结构由一些作为社会实体的基本单元和要素构成。 ③规范性社会结构：指社会结构中的各种社会实体同时作为社会规范而存在着。 ★考点3：社会建设(单选) 社会建设就是在社会领域不断建立和完善各种能够合理配置资源和机会的社会体制和运行机制。 我国明确地采用社会建设概念，是在中国共产党的 十六届四中全会。(单选) 考点4：社会管理(单选) 社会管理是政府和社会组织为促进社会系统协调运行，对社会系统的组成部分、社会生活的不同领域以及社会发展的各个环节进行组织、协调、监督和控制的过程。 考点5：社会的基本要素 (1)人口; (2)自然资源; (3)环境; (4)文化。 ★★考点6：人口(单选、简答) (1)人口的概念：人口是指在特定地域内，由一定社会关系联系起来的、一定数量和质量的有生命的个人所组成的总体。 (2)人口的属性：自然属性和社会属性。 (3)人口数量的概念：是对人口的量的规定性，指一定时间和一定地区有生命的个体总和，通常人口数量指的是人口规模。 (4)人口质量的概念：也称人口素质，是对人口的质的规定性，包括人口的身体素质、科学文化素质和思想素质等。 (5)人口问题： ①人口素质问题; ②人口流动迅猛; ③人口分布失衡; ④人口老龄化加速; ③人口性别失衡。 考点7：自然资源(多选) (1)概念：自然资源是指与人类活动相关联的全部自然条件的总和，是社会赖以生存和发展的外部条件。 (2)特点: ①自然资源的有限性; ②自然资源的无限性; ③自然资源的系统性; ④自然资源的不均匀性。 考点8：自然资源在社会发展中的地位 (1)自然资源提供了社会生产和生活资料的来源。 (2)自然资源影响社会生产部门的布局和生产发展的方向。 (3)自然资源影响社会发展的速度。 考点9：环境(单选、多选) (1)概念：环境是指围绕在人类周围的其他生物和非生命物质等因素所构成的人类的生存环境，它是影响人类生存和发展的所有外界条件的总和。 (2)功能 ①环境对人类具有支持作用。②环境对人类具有供给作用。 ③环境对人类具有调节作用。④环境对人类具有文化启迪作用。 ★★考点10：文化(单选、多选) (1)涵义：文化是指人类创造出来的一切物质产品和非物质产品的总和。 (2)特征：①创造性；②习得性；③共享性；④累积性；⑤特殊性和共性。 西方学者中首先给文化定义的是 英国 人类学家 爱德华·泰勒。(单选) 英国人类学家 马林诺夫斯基 推进泰勒对文化的定义是在 1936 年。(单选) ★★★考点11：文化结构(单选) (1)文化特质。文化特质是组成文化的最小单位，也称 文化元素。 (2)文化集丛。功能上互相整合的一组文化特质，它们结合起来共同发挥一项功能，以满足人的某种需要，这些文化特质就组成一个文化集丛。 (3)文化模式。文化模式是指由许多文化集丛结合而成的一个文化整体，而与其他文化模式互相区别。 考点12：文化规范体系 (1)习俗;(2)道德;(3)法律;(4)宗教。 ★★★考点13：文化交流 文化交流是指从文化传播开始的两种文化之间互相 沟通、采借、冲突与融合 的过程。 (1)文化传播：是指某种文化元素随同社会交往而扩散，为其他社会所采借或吸收的过程。 (2)文化冲突：是指异质文化在传播、接触中出现的互相排斥的倾向和状态。 (3)文化采借：又译为 文化杂交，是指一种文化接受或吸收另一种文化的某些文化元素或文化集丛，融入本文化的过程。 考点14：文化震惊(单选) 文化震惊是指生活在某一文化中的人，当他初次接触到另一文化模式时所产生的思想上的迷惑、混乱与心理上的震撼。文化震惊是一种客观现象，是人们直接感受文化多样性时的心理现象。 ★考点15：主文化和亚文化(单选) (1)主文化：又称主流文化，是在社会上占主导地位的，为统治集团倡导，并被多数社会成员所接受的文化。 (2)亚文化：仅为社会上一部分成员所接受的或为某一地区、某一群体特有的文化。 考点16：文化中心主义和文化相对主义(单选) (1)文化中心主义：指各个国家、各个民族常有一种倾向，常将自己的生活方式、信仰、价值观、行为规范看成是最好的，是优于其他民族的。 (2)文化相对主义：认为各种不同的文化模式是不能评价和比较的。因为，如果从各种不同的文化模式所赖以生存的环境看，每一种文化模式都有其存在的合理性，每一种文化都有其相对的价值，它们之间没有高低优劣好坏之分。 ★★考点17：文化自觉(单选、论述) (1)含义：“文化自觉”指生活在一定文化中的人对自己的文化有“自知之明”，对他人的文化有“识人之明”。“文化自觉”是 费孝通 提出的。 (2)内容 ①“文化自觉”关注了中国现代化的反思。 ②“文化自觉”关注了文化断裂下的主体再造。 ③“文化自觉”提出了美美与共的价值诉求。 第四章 社会化与社会角色 ★考点1：社会化概述 (单选) (1)概念 社会化 是社会对个人的文化教化和个人对社会主动选择与能动调适的统一过程。 (2)内涵 ①从时间方面理解，即个人社会化涉及人生发展的全过程; ②从内容方面理解，个人社会化关注个人作为社会一员所应具有的全部文化遗产; ③从关系方面理解，个人社会化注重个人与社会的交互作用以及个人社会化的结果。 ★★★考点2：社会化的类型(单选) (1)基本社会化 所谓 基本社会化，就是“生物人”通过社会文化教化，获得人的社会性，获得社会生活资格的过程。基本社会化是人的生命早期的社会化过程，也称为一级社会化。 基本社会化还有一种特殊表现形式，即一个人为适应特定角色需要而进行的知识准备过程。有的研究者称此为 预期社会化。一般来说，职业学校教育就属于这一社会化过程。此外，还有岗前培训和岗位培训等。 (2)继续社会化 继续社会化是人在成年以后的社会化，或称二级社会化。 继续社会化还有一种特殊表现，即发展社会化。这是一种为适应生活的变化、承担起新的角色而主动学习与调适的过程，它突出表现为拓宽知识基础、变更职业技能、改变角色能力等。成人教育是一种常见的发展社会化过程。 (3)再社会化 再社会化也称 重新社会化，它是使个人改变以前的知识结构、价值标准和行为模式，建立起新的、符合社会要求和新的形势需要的知识结构、价值标准和行为模式的过程。 ①主动再社会化，即个人主动地、自觉地适应新的社会生活，通常称为自觉改造; ②强制性再社会化，一般是通过特别机构和特别途径强迫进行。 (4)正向社会化和反向社会化 所谓正向社会化，是指上代人对下代人的文化传递和教化过程。 所谓反向社会化，是年轻一代用新知识、新观念影响前辈的过程，这种社会化又称为 文化反哺。 ★★★考点3：社会化的有关理论(单选) (1)弗洛伊德的精神分析学说 弗洛伊德的社会化理论基于对人格结构的分析。弗洛伊德认为，人格由本我、自我和超我三个部分组成。 (2)库利和米德的自我理论 库利的理论集中于他的“镜中之我”概念，即一个人的自我形象是别人看他是什么样子的反映，或者说是这个人认为别人看他是什么样子的反映。乔治·赫伯特·米德将自我分为两个部分：“主我”和“客我”。 (3)科尔伯格的道德意识发展阶段论 科尔伯格认为道德发展分为三种水平六个阶段： ①前常规水平。其中第一阶段为服从与惩罚阶段，儿童判断是非的标准是其行为选择是否会导致惩罚。第二阶段为相对功利主义阶段，儿童的判断标准是其行为能否获取更多的收益。 ②常规水平。其中第三阶段为好孩子阶段，个人把合乎重要他人(比如父母)的期待视为是非标准。第四阶段为法律秩序阶段，个人把普遍化的社会期待即既定的法律和道德规范视为是非标准。 ③后常规水平。其中第五阶段为社会契约合法性阶段，个人相信某些具体的法律规范并非总是合理地反映了伦理要求，因此可以通过合法方式加以修改，但在修改之前仍然应当遵守和维护法律。第六阶段为普遍伦理原则阶段，个人选择以更高的普遍伦理原则而非具体的法律条文来决定自己的行为。 ★★考点4：社会化的条件(单选、多选) (1)生物因素：社会化的生物因素，是指个人所带有的一种由上代为下代提供的、有利于人类从事社会活动的特殊遗传素质。 (2)环境因素 所谓社会化的环境因素，是指影响个人社会化过程的全部社会环境。它是社会化的必要条件。 影响个人社会化的环境因素，主要有家庭、学校、伙伴群体、工作单位、社区和大众传媒等。 (3)互联网：互联网，是指一个由各种不同类型和规模的、独立运行和管理的计算机网络组成的全球性信息系统，英文名字叫 Internet。 (4)社会实践：社会实践是实现知识内化与积累，达到社会化目标的根本途径。 ★考点5：网络对青少年社会化产生的正面影响(简答) (1)为青少年的教育提供了选择权。 (2)开阔了青少年的视野。 (3)有助于青少年更好地了解社会规范。 (4)“虚拟环境”为青少年提供了很好的与人沟通的互动环境。 考点6：个人在社会实践中实现社会化的方法 (1)观察学习；(2)角色扮演;(3)知识积累。 ★考点7：社会角色(单选、多选) (1)概念：社会角色 是由一定的社会地位所决定的、符合一定社会期望的行为模式。 (2)涵义 ①社会角色是社会地位的外在表现。 ②社会角色是一整套行为规范和行为期待。 ③社会角色是人的多种社会属性和社会关系的反映。 ④社会角色是构成社会群体和社会组织的基础。 ★★考点8：社会角色的类型(单选) (1)根据人们 获得角色方式 的不同，可以将角色划分为 先赋角色与自致角色。 (2)根据 角色规范化的程度，可以将角色划分为 规定性角色与开放性角色。 (3)根据 角色追求的目标，可以将社会角色划分为 功利性角色和表现性角色。 建立在血缘、遗传等先天的生理因素基础上的社会角色，被称为 先赋角色。(单选) ★考点9：社会角色的扮演 (简答) (1)角色期待;(2)角色领悟;(3)角色实践。 ★★考点10：社会角色的失调(简答、论述) (1)角色紧张。(2)角色冲突。(3)角色不清。 (4)角色中断。(5)角色失败。 第五章 社会互动 ★★考点1：社会互动(单选、简答) (1)概念 社会互动 是人与人之间通过一定的符号和交往形式而产生相互影响的过程。 (2)构成因素 ①必须要有两个或两个以上的互动主体。 ②互动主体之间必须发生某种形式的接触。 ③参与互动的各方有意识地考虑到行动“符号”所代表的“意义”。 ★考点2：社会互动的基本形式(多选) (1)暗示;(2)模仿;(3)交换;(4)竞争;(5)合作;(6)冲突;(7)调适。 ★考点3：暗示(单选) (1)概念：暗示是人们为了某种目的，在非对抗的条件下，通过语言、表情、肢体语言以及某些符号，用含蓄的，间接的方式对他人的心理与行为进行影响，使其接受暗示者所示意的意见、观点或按所示意的方式进行活动。 (2)表现类型：①直接暗示。②间接暗示。③自我暗示。④反暗示。 考点4：模仿 模仿是在没有外在压力条件下，个体受他人影响，而仿照他人，使自己与之在某些方面相同或相似的现象。模仿是人们相互影响的一种重要方式。 考点5：交换 (1)概念：交换指的是在一定的规则下，行为者为了获得回报而行动并获得回报的社会互动形式。 (2)构成要素：①目标。②付出。③回报。④效益。 (3)类型：①物质的交换。②非物质的交换。 考点6：竞争 (1)概念 竞争是指行动者之间为了共同的目标而展开的较量、争夺，它是社会互动的一种普遍可见的形式。 (2)类型 ①从社会互动的主体分，可分为个人和个人之间竞争、个人和群体之间竞争、群体和群体之间竞争。 ②从社会互动的内容和目标来看，宏观层面分为经济竞争(如争夺市场份额)、政治竞争(如总统竞选)、科技竞争等；微观层面可分为地位竞争(如争夺某个职位)、声望竞争(如争夺某项荣誉)、恋人竞争等。 ★★★考点7：合作(单选) (1)概念 合作是指在社会互动中，行为者之间为达到某些共同的利益或目标彼此密切配合的一种联合行动。 (2)类型 ①自发性合作。指某种情境下人们自觉自愿地聚集帮助他人解决实际困难和需要的行为。这是一种最古老和最具普遍意义的合作形式。这种自发的合作直接体现为援助行为。比如，农村中的左邻右舍帮助乡里将病危老人送往山外医院救治，就是合作性的救助行为。 ②制度化的传统合作。当自发性合作逐步发展为稳定的社会习惯，而成为一种制度化的合作以后，我们把它称为制度化的传统合作。比如在一些农业地区逐步形成大家一起收获庄稼的合作习惯。 ③指导性合作。是现代社会比较多见的合作形式。指的是双方在具有权威地位的第三方的指导下起完成某项工作。比如在公司里工作的员工，有些工作任务可能是在部门经理或总经理的管理和协调下共同完成的。又如，大学生的社会实践是在他们的老师指导下，有序有效地进行的。 ④契约式合作。指个人或群体之间达成协议、以契约或类似契约的方式进行合作。这是现代社会的一种合作方式。比如在金钱借贷方面的合作，某公司几个合伙人之间的合作，都是契约式合作的例子。 ★考点8：冲突(单选) (1)概念 冲突是指不同行动者之间相互反对或阻止对方意图的自觉行动。 (2)类型 ①从冲突的规模上分为群体之间的冲突和个人之间的冲突; ②从冲突的性质上划分，有经济冲突、政治冲突、文化冲突、种族冲突以及阶级冲突等; ③从冲突的方式或程度上划分，有显性冲突(直接的、明显可见的)和隐性冲突(间接的、隐藏的)等，其中显性的冲突方式又有争论、拳斗和械斗、仇斗、诉讼和战争等等之分。 ★★考点9：调适(单选、简答) (1)概念 调适即调整自己的行为以适应环境的要求，是对冲突情境加以适应的状态或过程。 (2)调适产生的原因。 ①由冲突引起的调适。②由社会发展或变迁引起的调适。③由文化交流或迁移引起的调适。 考点10：符号(单选) 符号，指由一群人所共同认可的、有意义地代表其自身以外的别的事物的象征。 ★考点11：语言(单选) 语言指人类所特有的用来表达意思、交流思想的工具，是由语音、词汇和语法构成的系统。 考点12：个人空间 个人空间是指环绕一个人周围的直接的物理区域，人们可以利用它在社会互动中表达某种意义。 ★★★考点13：社会存在四种不同的个人空间(单选) (1)亲密距离，指相距18英寸(约 45厘米)以内的距离。这个空间是为 关系亲密 的个人之间接触保留的。 (2)个人距离，指相距18英寸(约 45厘米)到4英尺(约122厘米)。这个空间是为熟人或朋友保留的。 (3)社会距离，指相距4英尺(约122 厘米)到12英尺(约365厘米)以内。是比较正式的场合保持的距离。比如会等一些交际场合。 (4)公众距离，是指相距12英尺(约365厘米)以上的距离。这是为一些类似演说家等公众人物保留的距离。 个人空间理论的提出者是 霍尔。(单选) ★考点14：社会互动的理论(单选) (1)符号互动论 符号互动论，又称符号互动主义或象征相互作用论，指从互动个体的日常自然环境去研究人类群体生活的理论派别。美国社会学家库利、托马斯和米德等人是符号互动论的早期代表。 (2)拟剧论 拟剧论，指用表演和比喻来说明日常生活中人与人之间相互作用的一种互动的理论。拟剧论是戈夫曼从符号互动论中发展出来的，其代表作是1959 年发表的《日常生活中的自我表演》。 (3)常人方法学 “常人方法学”就是指对人们在日常生活互动中所使用方法的研究。 社会互动最重要的特征就是“印象管理”或“自我呈现”，这种观点来自于 拟剧论。(单选) 考点15：社会网络的特征(简答) (1)普遍性。(2)多重性。(3)滚珠性。(4)多向性。(5)隐蔽性。 ★★考点16：社会网络的形态(单选) (1)封闭形态和开放形态。以 个人进出该社会网络的难易程度 的不同来区分。 (2)稳固形态和松散形态。以 个人和社会网络的连接的紧密程度不同来区分。 (3)互利形态和互补形态。以 个人在社会网络中获得的利益 来区分。 ★考点17：强关系与弱关系(论述) 美国社会学家 格兰诺维特 提出人际关系网络可以分为强关系网络和弱关系网络两种。强关系指的是个人的社会网络同质性较强，人与人的关系紧密，有很强的情感因素维系着人际关系。反之，弱关系的特点是个人的社会网络异质性较强，人与人关系并不紧密，也没有太多的感情维系。 ★★考点18：社会资本(单选) (1)概念 社会资本，指通过社会联系与社会关系所获取的资源。 (2)分类 ①以布朗等为代表，将社会资本分为微观层次的社会资本、中观层次的社会资本和宏观层次的社会资本三大类。 ②依据社会资本的性质，社会资本分为同质性社会资本和异质性社会资本。 ③罗伯特·科利尔把社会资本分为政府社会资本和民间社会资本。 第六章 家庭与婚姻 ★考点1：家庭(单选、多选) 家庭 是由具有婚姻、血缘或收养关系的人们组成的长期共同生活的群体，是人类生活中最基本、最重要的一种群体形式。一般说来，**婚姻关系、血缘关系和收养关系** 是形成家庭的基本关系。 考点2：婚姻(单选) 婚姻 通常是男女之间依照社会风俗或法律的规定而结为夫妻关系的一种社会制度。 考点3：家庭的功能(多选) (1)规范性行为功能。(2)经济生活功能。(3)人口再生产功能。 (4)精神生活功能。(5)教育功能。(6)抚养、赡养功能。 ★★★考点4：家庭的结构类型(单选) (1)核心家庭：一般指由一对夫妇及其未婚子女生活在一起而组成的家庭。在核心家庭这一类型中，还有一种特殊情况，即一对夫妇没有子女并且自愿终生不育的家庭。 (2)主干家庭：是由一对夫妇与父母和未婚子女聚居生活的家庭。主干家庭还有一些特殊的形式，如只有两对或两对以上都是异代的夫妇而没有未婚子女组成的家庭。还有夫妇或父母缺损一方的单亲主干家庭。 (3)联合家庭：是指由父母和多对已婚子女以及孙(外孙)子女组成的家庭。 (4)其他家庭 ①残缺家庭，即夫妻双方有一方因离婚、丧偶而同未婚子女生活在一起的家庭; ②断代家庭，即只有一代未婚青少年与祖(外祖)父母组成的家庭; ③单身家庭，即孤老户以及那些终身不娶或不嫁而又独身居住生活的男人或女人。 一般认为，所有家庭形式中最稳定的是 核心家庭。(单选) ★考点5：家庭的特殊类型(单选) (1)重组家庭;(2)“失独”家庭;(3)同性恋家庭;(4)丁克家庭;(5)留守家庭。 失去家中独生子女的家庭被称为 失独家庭。(单选) ★考点6：家庭形态的变化(简答) (1)家庭规模小型化;(2)家庭离婚率上升;(3)家庭类型多样化。 ★考点7：家庭功能的变化(论述) (1)经济功能弱化。(2)抚育和社会化的功能外移。 (3)家庭的生育偏好开始改变。(4)养老功能的挑战。 考点8：家庭与婚姻观念的变化 (1)性观念多元化;(2)地位平等化;(3)行为理性化。 第七章 群体与组织 ★考点1：群体的概念和特征(多选、简答) (1)概念：群体是人们通过某种社会关系联结起来进行共同活动和感情交流的集体。 (2)特征: ①有一定数量的社会成员。 ②有一定的为群体成员所接受的目标。 ③有明确的成员关系，并形成归属感。 ④有一定的行为准则。 ③时间上具有一定的持续性。 ★★★考点2：群体的类型(单选) (1)初级群体和次级群体 初级群体和次级群体是以成员的 互动关系特征 为标准而进行的一种群体分类。 ①初级群体又称作 首属群体，是社会群体中最古老、最基本的形式，是个人参加社会生活的基础群体。 ②次级群体又称作 次属群体，是用来表示与初级群体相对应的各种群体，如学校、职业群体、社团等。 (2)正式群体和非正式群体 正式群体和非正式群体是以 群体的关系结构和组织功能 为标准而进行的一种群体分类。 非正式群体是一种自发形成的、无正式组织结构、无正式章程的群体，如朋友群、游伴群等。它与正式群体不同，不是由上级社会结构组织起来的，而是在 成员个人倡议的基础上 建立的。 (3)内群体和外群体 内群体和外群体是以 成员对群体的心理归属 为标准而进行的一种群体分类。 内群体和外群体，又称作“我群”和“他群” ①凡是成员感到自己与群体关系密切，对群体有强烈归属感的，就是内群体。 ②那些由他人结合而成、与自己没有什么关系的群体，就属于外群体。 (4)成员群体和参照群体 参照群体和成员群体是以 群体成员的归属 为标准而进行的一种群体分类。 ①成员群体也就是内群体，个人属于该群体的成员，并以本群体的规范作为自已活动的准则，各成员之间在行为上彼此互相影响。 ②参照群体是指被某一群体成员用来作为某种参照对象并试图效法的群体。也叫“标准群体”或“榜样群体”。 (5)大群体和小群体 大群体和小群体是以 群体的规模 为标准而进行的一种群体分类。 ①大群体一般指规模较大、人数较多、人员之间较少直接互动的群体。 ②小群体则是指那些规模较小、成员之间能够直接互动的群体。 初级群体概念是20世纪初由美国社会学家 库利 提出来的。(单选) 关于群体的类型，美国社会学家 海曼 提出的概念是 参照群体。(单选) ★考点3：初级群体(简答) (1)涵义：初级群体作为由面对面的互动所形成的、具有亲密的人际关系的社会群体，在社会生活中具有重要的地位和作用。 (2)类型 ①家庭。②邻里。③伙伴群体。 考点4：组织的概念 (单选) 所谓组织，即人们为了达到特定目标而有计划地建立起来的具有比较严密的结构的制度化的群体。 ★★考点5：组织过程(单选) (1)组织决策：指组织成员从两个以上的行动方案中进行选择决断，以期最优化地达到组织目标的过程。 (2)组织沟通：指组织内部的信息交流，即组织成员之间通过各种形式的交往以传达思想、观点、态 度、感情或情报的过程。 (3)组织控制：指组织用各种规章制度和奖惩手段约束组织成员的行为，以保证组织的决策和指令能 够有效地贯彻执行，维护组织的各项秩序。 ★★考点6：合法性统治类型(单选) 韦伯把历史上出现过的合法统治归纳为： (1)超凡魅力型，也称克里斯玛型。(2)传统型。(3)法理型。 科层制的提出者是 马克斯·韦伯。 (单选) 其典型形式为科层制的是 法理型权威。(单选) ★★考点7：科层制(简答、论述) (1)含义：所谓科层制，是指建立在法理型权威基础上的，以正式规则为管理主体的，具有职权分工和职位等级体系的组织形式和管理方式。 (2)特征 ①明确规定的固定权限。②明确规定的职位等级。 ③执行职务建立在公文基础上。④职务的专业化和量才录用。 ③照章办事。 (3)科层制组织的优点和弊端 ①优点：相比较其他组织体系和管理方式，行政管理效率高。 ②弊端：形式主义；繁文缛节；用人困境；人情味欠缺；对外界变化反应不灵敏。 考点8：组织管理理论 (1)科学管理理论;(2)人际关系理论;(3)组织行为理论;(4)权变理论。 ★考点9：科学管理理论(单选) 科学管理理论的观点认为，为了使组织更有效地实现它的目标，必须使组织的结构和过程科学化和合理化。其主要的代表人物有美国工程师泰罗和法国管理学家法约尔。 泰罗最先提出了组织的一系列科学管理原则，建立了刺激性的计件工作制。 与泰罗理论的重点在于车间和作业管理方面不同，法约尔的研究重点放在组织的行政管理方面。法约尔为此提出了有助于改进组织行政管理的 14 项原则。 ★考点10：人际关系理论(单选) 人际关系理论反对泰罗等科学管理理论家把人看作“会说话的机器”，或人的活动仅仅受金钱的驱使，而认为人是“社会人”。这个理论是在哈佛大学教授梅约和罗伊斯里伯格等人指导的著名的霍桑实验中逐步形成的。 ★考点11：组织行为理论(单选) 组织行为理论是从人际关系理论发展而来的组织管理理论。其代表人物有 巴纳德和麦克雷戈。巴纳德提出了 “组织平衡论”观点，认为组织的存在和成功取决于在组织成员的贡献与满足之间所维护的平衡。 麦克雷戈则提出了著名的 “X”理论和“Y”理论，对不同管理模式背后的理论假设进行了区别和分析。组织行为理论 呼吁组织采取民主而非集权专制 的领导方式，认为民主型领导比专制型领导的组织效果更好。 ★考点12：权变理论(单选) 权变理论又称 情势理论，认为组织管理不只是和组织本身有关，而且涉及组织和环境之间的关系，组织的管理者应根据不同的环境和具体情况，灵活地决定组织的决策方式、领导方式和行动方式。 权变理论中较著名的是美国心理学家 约翰·摩尔斯和杰伊·洛斯奇 提出的 超“Y”理论，这种理论是对X理论和Y理论的发展。超Y理论强调组织的管理者应该根据实际情况，灵活地采用不同的管理方法，具体情况具体分析，因人、因事、因其不同的情境而采取不同的管理方法。 ★★考点13：集体行为(单选、多选、简答) (1)含义：集体行为是指在缺乏确定的组织程序和制度规范的条件下，很大程度上自发形成的，由许多个体参加的非制度化的行为。 (2)特征：①群众性；②自发性；③非组织化；④非制度化。 ★★★考点14：集体行为的传统解释(单选) (1)勒庞的乌合之众理论 1896年，古斯塔夫·勒庞 出版了《乌合之众》一书，从 社会心理学视角 来解释集体行为。 (2)斯梅尔瑟的价值累加理论 斯梅尔瑟提出，只有当六个因素不断累加影响下，才会导致集体行为的发生。 ①结构性助因。②结构性紧张。③一般化信念。④促发性因素。③行动动员。③社会控制。 斯梅尔瑟对集体行为进行解释的理论是 价值累加理论。(单选) 根据斯梅尔塞的价值累加理论，罢工这一行为的发生，常常是由于经济不景气要裁员或降薪，从而导致企业员工的愤怒，这属于 结构性紧张。(单选) ★★考点15：集体行动的理性选择理论(单选) (1)奥尔森的搭便车理论 美国学者 奥尔森 在其《集体行动的逻辑》一书中详尽地探讨了他提出的搭便车理论。奥尔森的搭便车理论的假设是：如果个体越理性，群体规模越大，那么这个群体发生集体行为的可能性就越小。 (2)社会运动的资源动员理论 资源动员理论特别关注对社会运动的解释。社会运动主要指有比较明确的变革社会的目标、组织化程度也相对较高的那类集体行为。资源动员理论的代表人物有 麦卡锡和扎尔德 等。 社会运动所需要的资源至少包括以下五种。 ①时间资源。②参与者规模。③金钱与物质资源。④外界支持。③理念资源。 第八章 教育劳动与消费 ★★考点1：教育(单选) (1)教育的内涵 ①广义教育 泛指一切传播和学习人类文明成果一一各种知识、技能和社会生活经验，以促进个体社会化和社会个性化的社会实践活动，产生于人类社会初始阶段。 ②狭义的教育 专指学校教育，即制度化教育。 (2)教育的类型 ①从教育发生的场所来说，可以分为 家庭教育、学校教育和社会教育。 ②从个体对教育的需求而言，可以把教育分为 生存教育和地位教育。 最早的教育形态是 社会教育。(单选) ★考点2：约翰·杜威关于教育的功能的观点(多选) 美国哲学家和教育家约翰·杜威认为，教育的 首要功能是社会化。他提出的“教育即生活教育即改造”、“学校即社会”和“儿童中心论”等观点中，体现了通过创设社会情境，在教育中尊重受教育者的主体性，使受教育者适应社会生活，从而实现社会化的思想。 ★考点3：现代学校教育的显功能(多选) (1)社会化的功能。(2)社会选拔的功能。 (3)提高人口素质的功能。(4)知识技术创新的功能。 ★考点4：现代学校教育的潜功能(单选) (1)建立未来人际关系。(2)减小就业压力。(3)社会控制的功能。 ★★★考点5：教育的社会学分析视角(单选) (1)功能论视角下的教育 这一传统的直接来源是社会学家涂尔干，他强调要寻找一个社会事实的功能，应该看它与某种社会目标的关系。因此，对教育的社会学考察首先应当关注其功能，即为专门化的社会角色提供训练有素的能力，具体表现为：社会化即让个体成为社会的；遂选即为分工后形成的不同社会角色提供适当人选。 (2)冲突论视角下的教育 冲突论认为，社会秩序不是建立在对共同价值的一致认可上，而是建立在统治阶级的控制权力上。具体至教育研究领域，学校 不再被视为社会实现其自我良性再生产的领域，而成为统治阶级用以生产与其特殊地位与利益相吻合地位的工具。 (3)互动论视角下的教育 在教育的社会学研究中，互动论传统被称为“人本主义”和微观取向。与之前的宏观社会制度思维不同，它将视角引入到具体的教育场景之中，引入到 人与人的互动关系 之中。 ★★★考点6：教育不平等的社会学分析(单选) (1)对制度化教育的批判 教育通常被认为是能够促进社会平等的手段。但是美籍奥地利学者 伊凡·伊利奇 则质疑了这种常识性观点。在题为《去学校化的社会》一书中，伊里奇对学校教育进行了激烈的批判，认为学校作为一种制度化教育，其实无法改变社会的不平等；恰恰相反，它的基本逻辑还正在强化和再生产着这种不平等。 (2)教育与文化资本 法国社会学家 布迪厄 从 文化资本的再生产角度 加以批驳，并着重分析了这一事实，即为什么来自社会下层的思维方式更容易在正式的学校环境中遭遇排斥。 (3)劳工阶层子弟的“亚文化” 社会学家 保罗·威利斯 根据在英国伯明翰的实地调查，提出了有关亚文化再生产机制的讨论，即劳工阶层的子女是如何再次成为劳工的。 ★考点7：劳动(单选) (1)概念：劳动是有目的、有意识地变换、调整和控制自然界的活动，包括脑力活动和体力活动。 (2)分类： ①根据 是否劳动报酬，分为有薪劳动和无薪劳动。 ②根据 消耗体力还是脑力，分为体力劳动和脑力劳动。 ③根据 劳动的二重性，分为具体劳动和抽象劳动。 ★考点8：福特主义(单选) (1)涵义 “福特主义”一词起源于 安东尼奥·葛兰西，指以泰勒制原则(一种使作业标准化、规范化的工业管理方法)和市场为导向，以分工和专业化为基础的生产劳动方式。 (2)特征 ①以生产机械化、自动化和标准化形成的流水线作业及其相应的工作组织，通过大规模生产极大地提高了标准化产品的劳动生产率。 ②劳资双方从劳资双方关于工作过程控制权的斗争转变为保障就业权和工资决定的斗争，最终形成了以劳资集体谈判制度为核心的劳资关系新形式。 ③专用性机器投资和低技能工人相结合的生产过程提高了资本有机构成，通过加速资本周转来降低高资本有机构成对利润率的影响，促进了企业之间纵向一体化过程，从而在主要行业形成了垄断竞争的市场格局。 ★★★考点9：后福特主义(单选、简答) (1)涵义 后福特主义是指以精益生产、柔性专业化等非大规模生产方式为核心的新的资本主义积累方式及其社会经济结构的生产劳动方式。 (2)特征 ①灵活的专项化生产取代了大规模标准化消费商品的生产; ②减少所有不能增加产品最终价值的间接劳动形式，包括监督活动、质量控制、维护工作和清理工作等; ③随着信息处理资源越来越掌握在企业一线工作区域，工作团队的自主权增加，企业内部协调信息发生了从中央集中处理到分散处理的转换; ④劳资关系从福特主义下的对抗性的竞争关系，变成某种程度上的相互合作与信任关系。 ★★★考点10：失业(单选) (1)概念 失业是指达到就业年龄具备工作能力谋求工作但未得到就业机会的状态。 (2)类型 ①摩擦性失业，指人们在转换工作过程中的失业。 ②结构性失业，由于产业结构或者生产技术的改变，使得原有的工作机会消失而造成的失业。 ③周期性失业，由于经济周期波动所造成的失业。 ④季节性失业，受季节性因素影响的失业。农业、营建业与旅游业季节性强，容易产生失业。 ③残余性失业，因无就业能力的失业。 ★★考点11：消费(单选、简答) (1)念 消费是为满足生产和生活需要而消耗物质和文化财富的活动，消费不仅仅是人们生活中的生活消费，还包括属于生产本身的生产消费。 (2)特征 ①消费的经济属性。②消费的心理属性。 ③消费的社会属性。④消费的文化属性。 ★考点12：消费社会(多选) (1)涵义 所谓消费社会，是一个以生活必需品之外的消费为主的社会。 (2)特征 ①消费成为社会的核心。 ②消费水平和消费规模的不断扩张。 ③消费主义盛行。 考点13：消费的社会学理论 (1)韦伯的生活风格理论; (2)凡勃伦的炫耀性消费理论; (3)鲍德里亚的消费社会论。 第九章 社会与社区发展 ★考点1：社区(单选、简答) (1)定义 所谓社区，一般地说，是指以一定地域为基础的社会生活共同体。社区概念最早是由德国社会学家 滕尼斯 在1887年所著《社区与社会》一书得到经典的阐述。 (2)内涵 ①社区是一定的地理区域空间，人们在这个空间共同生活; ②社区是一个社会关系网络，它的形成基于人们共同生活中的社会互动; ③社区是集体认同的一个标志，人们由于共同生活而产生了对社区所在区域或群体在一定程度上的心理认同，视自己为社区的一分子。 ★★考点2：社区的功能(单选) (1)经济生活功能。社区具有一套生产、分配、交换和消费的体系，通过生产或进口，为其成员提供衣、食、住、行等基本的生活必需品和服务，以满足社区成员的需求，这是社区的首要功能。 (2)社会化功能。社区具有一系列的组织和设施，将社区共有的价值观念、行为规范、基本常识等传递给下一代社区成员，或者教育新移入的居民，使他们能够融入到社区生活中来，例如家庭、邻里、学校、教堂。 (3)社会控制功能。任何社区都会对其社区成员偏离社会规范的行为施以某种形式的制裁，以督促人们遵守社会规范，维护社区的社会秩序。 (4)社会参与功能。社区可以向社区成员提供生活和交往的场所、设施和途径，帮助社区成员参与社区事务以及更大范围的社会事务，这就是社区的社会参与功能。 (5)社会保障的功能。社区的社会保障既包括具体落实社会救济、社会保险、社会服务、公共福利等与整个社会相联系的社会保障制度，更重要的是，社区还能形成以社会互助为核心的社会支持系统。 考点3：社区的类型学理论(单选) 一般认为，社会学者对于社区的研究始于德国社会学家滕尼斯的类型学研究，他在《社区与社会》一书中分析了“社区”和“社会”两种对立的社会联系类型。 滕尼斯为，个人主义泛滥其间的“社会”终将取代温情脉脉的“社区”，使得“社区”中相互关心并具有共同道德信念的基础瓦解。 ★★★考点4：人文区位学理论(单选) (1)同心圆理论 同心圆理论是美国学者伯吉斯在20世纪20年代运用人文区位学原理对城市空间结构提出的一个假说。伯吉斯把城市划分为五个同心圆区域：第一环是中心商业区，位于城市中心；第二环是过渡区；第三环是工人居住区；第四环是较高级住宅区；第五环是高级住宅区(往返区)。 (2)扇形理论 扇形理论是霍伊特在对伯吉斯同心圆理论的批评的基础上于 1939 年提出的。 (3)多核心理论 多核心理论是哈里斯和厄尔曼所提出的，他们认为城市并不总是只有一个中心区，而可能有两个甚至两个以上的中心区；越是规模大的城市，核心区域就越多，并且这些核心区域往往还各有其专门性的功能，大城市的空间结构因此表现为多核心的形态。 考点5：社区全貌研究(单选) 美国学者林德夫妇在社区研究中开创了以小市镇为对象的全貌研究。所谓全貌研究，就是描述社区的各个不同部分并解释这些不同部分的相互关系。美国学者林德夫妇在社区研究中开创了以小市镇为对象的全貌研究。《中镇》开创了社区综合研究的先河，推动了后来的学者进行一系列类似的研究。 林德夫妇的名著“中镇”属于 社区全貌理论。(单选) ★考点6：农村社区的特点(多选) (1)农村社区的人口密度低。(2)农村社区的经济活动相对简单。 (3)农村社区的社会结构相对简单。(4)传统农村社区的社会变迁比较缓慢。 ★考点7：现代城市社区生活方式的特点(多选) (1)城市社区的社会分工复杂，居民从事更专门化的工作，彼此工作背景相差很大。 (2)城市社区中家庭和初级群体作用减弱，取而代之的是各类正式组织。 (3)城市社区中，人际互动趋向功利化、理性化和肤浅化。 (4)城市社区存在和包容了更多的文化差异。 考点8：社区发展的概念(单选) 社区发展 指在城乡基层社区中社区居民依靠社区自身力量，在政府和其他组织机构的支持下，推动社区有计划地社会变迁，改善社区的经济、社会和文化状况，提高社区居民的生活质量。 ★★★考点9：社区发展的原则(单选、简答) (1)民主的原则，即社区发展过程中应充分发扬民主。 (2)民众需要的原则，即应满足社区居民的共同需求为重点，特别应从解决社区面临的迫切问题入手。社区发展是一个持续不断的过程，以改善社区居民的生活，因此必须鼓励社区居民自已来判断和认定其自身需要，而不是简单地由政府或其他专家来界定。 (3)自力原则，即要求社区居民挖掘自身潜力、自力更生，而不是一味地依靠外部的和国家的投入。 (4)自下而上与自上而下相结合的原则。社区发展过程中的具体要求，应是来自社区基层群众，然后由政府有关部门加以引导和支持。 (5)物质文明、精神文明和政治文明建设并重的原则。社区发展包括物质经济上的发展和精神文化上的发展。 考点10：当前社区发展的基本任务 第一项任务，促进城市治理体系的进一步完善。 第二项任务，促进民主政治建设。 第三项任务，减轻市场经济发展对社会生活带来的负面影响。 第十章 城镇化 考点1：城镇化 城镇化 亦称城市化、都市化，指人口和社会职能向城市或城市聚集，生产方式、文化模式和社会角色发生变更，使城乡接近、融合的过程。 考点2：世界城镇化演进模式(单选) (1)欧美模式 属于市场主导型城镇化; (2)墨印模式 属于政治主导型城镇化。 ★考点3：城镇化的类型(单选) (1)依城镇化发展水平，可分为初步城镇化、中等城镇化、成熟期城镇化和高度城镇化。 (2)若根据经济体制，可分为计划型城镇化和市场型城镇化。 (3)从城镇化与工业化发展水平关系来考察，城镇化可分 同步城镇化、过度城镇化、滞后城镇化、低度城镇化和逆城镇化 五种类型。 ★考点4：城市群概念 城市群，又称“都市圈”、“都市带”、“都市丛”、“大都市连绵区”等，是指人口规模在2500万以上和人口密度超过每平方公里 250人的城市集聚区。这是牛津大学地理学学院主任、国际著名城市地理学家 琼·戈特曼 最早提出的概念。 ★考点5：城市群分类 (1)从规模和层次角度，城市群可以划分为超级城市群(顶级城市群、特级城市群、超大城市群)、一级城市群(大型城市群)、二级城市群(中型城市群)和三级城市群(小型城市群)等。 (2)从形态和结构角度，城市群可以分为星系城市群、带状城市群、扇形城市群、葡萄串城市群等。 (3)从中心城市的角度，城市群可分为单核城市群、双核城市群和多核城市群。 ★★★考点6：城市群研究(单选) (1)田园城市。1898年，英国城市学家 E.霍华德 出版《明天：通往真正改革的平和之路》一书，提出了田园城市的理论。他主张田园城市应该兼有城市和乡村各自优点，城乡交融和群体组合型城市。 (2)组合城市。1915年，英国生物学家、社会学家、教育家和现代城市研究与区域规划理论先驱 帕特里克·格迪斯 创造了“城市学”的概念。 (3)区域整体发展理论。美国学者 刘易斯·芒福德 继承了 格迪斯 区域规划思想，创造性地提出区域整体发展理论。 (4)城市集中发展理论。法国建筑学家和城市理论家 勒·柯布西耶 从城市规划视觉角度提出了城市集中发展理论。 (5)城市群理论。1961 年和 1987 年，戈特曼 先后出版了《城市群：美国城镇化的东北部海岸》和《城市群：25年之后》两本专著，更奠定了他的“城市群”理论创始人的地位。 (6)城乡融合区。20 世纪 80年代，麦吉 等人对印尼、泰国、印度、中国大陆和中国台湾等亚洲国家和地区的大都市周边地区进行了研究，发现中心城市主体及周边地区一起形成了“扩展大都市区”。1985 年麦在美国阿克隆大学关于亚洲城市化的国际研讨会上把这种新型空间形态称之为“城乡融合区&quot;。 ★★考点7：中国城镇化的三个阶段(单选) 第一阶段(1949~1957)，为平稳起步阶段。 第二阶段(1958~1977)，为大起大落阶段。 第三阶段(1978 年至今)，为加速发展阶段。 ★考点8：中国城市群演进中面临的主要问题(论述) (1)城市群形成过程的人为因素过大，行政干预过高，缺乏市场机制的自然发育期; (2)城市群的形成和发展依然受限于现存行政体制的束缚，彼此求大求全，缺乏产业分工，利益的矛盾和冲突易发，降低了整体和各自的效率和效益； (3)城市群的人口和经济总量在全国的比重还不高，对全国城乡协调发展和经济社会协调发展的拉动还有限; (4)城市群内部结构还不完善，大中小城市还比较少，缺乏连接中心城市与众多小城镇和广大农村之间的中间环节; (5)城市群空间分布不均衡，特别是人口和经济分布不协调，产业结构重叠严重；等等。 ★考点9：中国城镇化道路选择的不同观点 (多选) (1)大中城市论;(2)均衡发展论;(3)多元模式论;(4)小城镇重点论。 ★★★考点10：中国城镇化的方针(单选) 改革开放初期，国家针对大城市社会问题严重、小城镇长期发展缓慢的状况，于 1978 年提出“控制大城市，多搞小城镇”的城镇化方针。 1980年10月，全国城镇化工作会议提出了 “控制大城市规模，合理发展中等城市，积极发展小城镇” 的城镇建设方针。 1989年12月《中华人民共和国城市规划法》规定：“国家实行严格控制大城市规模，合理发展中等城市和小城市的方针，促进生产力和人口的合理布局。” 为了迎接 21世纪全球可持续发展战略的挑战，中国政府作出了履行 1992 年联合国环境与发展大会通过的《21世纪议程》的承诺，1994 年 3 月 25日，国务院第十六次常务会议审议通过了 《中国21世纪议程》。 ★考点11：促进我国小城镇的健康发展的方法(论述) (1)小城镇建设要有科学规划。 (2)小城镇建设规模要适度。 (3)小城镇建设要重视生态环境保护。 (4)建立健全健康发展的体制机制。 ①建立与城镇化健康发展相适应的财税、征地、行政管理和公共服务等制度。 ②加快小城镇住房、就业、医疗、教育和社会保障制度的市场化改革。 ③加大对小城镇建设的投入，在政府引导下主要通过发挥市场机制的作用，引导社会资金投入小城镇 开发。 ④在保护耕地和保障农民合法权益的前提下，妥善解决小城镇建设用地。 ③改革小城镇管理体制，尽快形成符合小城镇经济社会特点的行政管理体制。 ③特别要加强小城镇居民的市民素质教育，使之尽可以地适应城镇文化，承担起城镇建设者的责任。 第十一章 社会分层与社会流动 ★考点1：社会不平等的相关概念(单选) (1)性别：是指男女两性在生理和心理上的差别。 (2)年龄：年龄是一种自然产生的生命过程，是一种先赋地位。依据一个人的年龄而确定的地位，称为“年龄地位”。对占据某年龄地位的人的行为期望，称为“年龄角色”。 (3)种姓：种姓或种姓制度是以血统、血缘和职业为标准，将社会成员划分为不同群体或社会集团的社会等级制度。 (4)种族：种族亦称人种，指在体质形态上具有共同生活遗传特征(肤色、发色、面容、体格、血型、头型等)的人群。 (5)等级：指按经济地位和政治法律地位不同而互相区别的群体或社会集团。 (6)阶级：所谓阶级，指的是这样一些集团，它们因为在历史上一定社会生产体系中所处的地位不同、对生产资料的关系(这种关系大部分是在法律上明文规定了的)不同、在社会劳动组织中所起的作用不同，从而领得自己所支配的那份社会财富的方式和多寡也不同。 (7)阶层：所谓阶层，一是指阶级内部的层次划分；二是泛指具有不同社会地位的群体。 ★★★考点2：马克思和恩格斯的社会分工理论(单选、论述) (1)分工有“自然分工”和“真实分工”之别。 (2)从“自然分工”到“真实分工”是一个质的飞跃。 (3)在“真实分工”出现的同时，产生了产品的不平等分配和私有制。 (4)分工的发展导致了物质劳动和精神劳动相分离。 (5)“物质劳动和精神劳动的最大一次分工，就是城市和乡村的分离。”这种分离贯穿着全部文明的历史并一直延续到今天。 (6)在阶级对立的社会中，分工的发展具有矛盾的性质。 ★考点3：社会不平等的两个研究传统(单选) (1)阶级分析：阶级分析传统把阶级斗争作为理解人类历史发展(包括社会不平等的演变)的关键所在，其关于社会不平等的冲突论假设，鲜明地体现在《共产党宣言》的第一句话里：“至今一切社会的历史都是阶级斗争的历史。” (2)分层研究：指的是以“生活机会”的分配和获得为核心内容的社会不平等研究传统。 考点4：社会分层(单选) 社会分层的实质，是社会资源(财富、收入、声望、教育机会等)在社会中的不均等分配。社会分层包含 社会分层结构和社会流动 两方面的基本内容。 ★考点5：古典社会学家的社会分层理论(多选) (1)马克思主义的社会分层理论。(2)韦伯的社会分层理论。(3)帕累托的精英理论。 ★★考点6：当代社会分层理论(单选) (1)功能主义的社会分层理论。 功能主义认为，社会分层是社会不平等的体现；社会分层之所以在各个时代、各个社会中普遍存在，是因为社会运行过程的需要。1945 年，美国社会学家 K.戴维斯 和 W.摩尔 发表《分层的若干原理》一文，阐述了功能主义的社会分层观。 (2)冲突论的社会分层理论。 与功能主义的社会分层理论相反，冲突论的社会分层理论强调冲突在不平等形成过程中的作用。其代表达伦多夫便认为：社会分层的起源在于这样的事实，即在任何一个社会中，个人或群体都要强制奖惩，这种实施能力意味着权力关系的存在。 功能主义和冲突论的社会分层理论，在20世纪60年代进行过激烈争论。此后，产生了一种折中的社会分层理论，其代表人物是 格尔哈特·伦斯基。(单选) “布劳一邓肯地位获得模型”划分社会阶层的标准是 职业。(单选) ★考点7：功能主义分层理论的缺陷(简答) (1)先赋性或继承性的优势，可能会影响到不同资源配置的逻辑。如一个无能之辈，可能运用其占据地位的资源获得较好的社会职位，而一个能力强得多的平民子女却得不到这样的好处。 (2)能力较强的人未必都能得到高报酬等实质性的刺激。如中小学教师、日托护理员、警察以及社会工作者等职业应当由能力较强的人来担当，可实际上他们的工资却很低。而有些人职位的价值很有限，他们的收入却很高。 (3)教育不均等导致地位获得未必是均等的。如生活极度贫困的人，他们得不到良好的教育和培训，其才能得不到发展，虽然他们中有的人可通过自身的努力上到高层，但这样的机遇相对于富有的上层人士来说，要小得多。 总的说来，社会分层不能保证最有才干的人去扮演最重要的角色或培养他们去扮演这些角色。 ★考点8：新中国成立前的阶级阶层结构(单选) (1)地主阶级和买办阶级。(2)民族资产阶级。(3)小资产阶级。(4)半无产阶级。 (5)无产阶级。(6)游民无产者阶层。(7)农民阶级。 ★考点9：改革开放前的阶级阶层结构(多选) 1949~1952年，史称国民经济恢复时期：形成了工人阶级、农民阶级、小资产阶级、资产阶级四个基本阶级的格局。 1953~1956年是社会主义改造时期：原来的四个基本阶级构成的阶级、阶层结构，演化为工人阶级、农民阶级和知识分子阶层组成的所谓“两个阶级，一个阶层”的阶级、阶层结构。 1977年，中国社会的阶级、阶层状况：工人阶级；农民阶级；知识分子阶层。 考点10：改革开放以来中国社会阶级阶层结构(单选) 根据《当代中国社会阶层结构研究报告》(2002)一书以职业分类为基础，以组织资源、经济资源、文化资源的占有状况为标准，可将全国成年社会成员划分成十个阶层：国家与社会管理者阶层，经理人员阶层，私营企业主阶层，专业技术人员阶层，办事人员阶层，个体工商户阶层，商业服务业员工阶层，产业工人阶层，农业劳动者阶层和城乡无业、失业、半失业者阶层。 ★★★考点11：社会流动(单选) (1)概念：社会流动，指社会成员从一种社会地位或职业向另一种社会地位或职业的变动。 (2)类型 ①垂直流动与水平流动。 A.垂直流动指在社会分层体系当中的不同层次之间的上下流动，又称纵向流动。 B.水平流动是指在同一个社会分层的层次当中，在同一个层内部的流动，又称横向流动。 ②代内流动与代际流动。 A.代内流动指个人一生中特别是其工作生涯中的社会地位变化。 B.代际流动指的是子女相对于父母的地位的变动。 ③结构式流动与自由流动。 A.结构式流动，是由于生产技术或社会体制变革而引起的规模较大的社会流动。 B.自由流动，指那种不是由于体制的变化而是由于个人特殊的原因(如个人努力，偶然的机遇等)而 导致的社会流动，是在整个社会阶层结构不发生变化的情况下，某些社会成员阶层地位的变化。 ④竞争式流动与赞助式流动。 A.在竞争式流动中，作为公开竞争目标的较高的社会地位，需通过追求者自身努力去获得。 B.赞助式流动，指较高的社会地位不是个人通过竞争可以直接获得，而由已经获得了较高地位的人根据某种既定的标准来授予。 1927年发表的《社会流动》一书的作者是 索罗金。(单选) ★考点12：新中国成立以来五次大规模的社会流动(单选、简答) 第一次大规模社会流动过程发生于 1949~1956 年。 第二次大规模社会流动发生于 1957~1965 年。 第三次大规模社会流动发生于 1966~1977 年。 第四次大规模社会流动发生于 1978~1991 年。 第五次大规模社会流动发生于 1992 年，一直延续到今天。 ★考点13：影响中国社会流动因素与机制(论述、案例分析) (1)社会流动的影响因素包括先赋因素与自致因素。就中国的现实情况而言，人们发生何种的社会流动，大致受三个层面因素的影响： ①在宏观层面，受制于社会结构和国家的制度安排(如户籍制度); ②在中观层面，则依赖于工作单位和家庭; ③在微观层面，则取决于个人后天努力(如党员身份)。 (2)导致社会流动的机制划分为四种主要类型： ①制度安排本身导致的社会流动; ②制度安排与先赋因素、自致因素混合导致的社会流动; ③制度安排抑制先赋因素或自致因素而导致的社会流动; ④制度安排中的某些漏洞或偏向，被一部分社会成员利用而导致的社会流动。 ★考点14：当前中国社会流动的特点(简答) (1)社会流动模式发生重大改变。 (2)社会结构从封闭迈向开放。 (3)社会流动呈向上流动的趋势。 (4)当前，中国社会流动仍然受制于社会转型和体制转轨，带有明显的转型特点。 (5)值得注意的是，当前中国的社会流动正在表露出一些不利于社会开放、公正的消极趋向。 第十二章 偏差行为与社会控制 ★考点1：偏差行为(单选) (1)概念 偏差行为是指在特定社会中社会成员不同程度地偏离或违反了既有的社会规范的行为，也被称为越轨行为、离轨行为或差异行为等。 (2)类型 ①按照偏差行为的表现方式可分为三大类型：偏差习惯、偏差心理和偏差文化。 ②按行为所偏离的社会行为准则的标准可以分为三种类型：违法行为、违章行为、违规行为。 在我国公共场所抽烟，属于一种 违章行为。(单选) ★★考点2：偏差行为的功能(多选、简答) (1)偏差行为的负功能 ①干扰正常的社会生活秩序。②损害个人和社会的利益。 ③减弱他人遵从规范的意愿。④破坏社会成员间的相互信任。 (2)偏差行为的正功能 ①有助于人们进一步认识社会规范。②有助于加强社会团结。 ③有助于社会预警。④有助于促进社会进步。 ★★★考点3：偏差行为的社会学解释(单选、多选) (1)失范理论 结构功能主义的重要代表人物美国学者默顿应用涂尔干的失范概念，建立了著名的失范理论来解释偏差行为的产生。社会失范会使人们处于失范性紧张状态，为缓解这种紧张，默顿认为人们可能有五种适应方式： 所谓 革新者，即为了追求社会鼓励的目标，采用了不被社会认可的手段，甚至是违法的手段。对于新者来说，他可能感到自己无法采取社会认可的手段，或者使用这一手段过于困难和耗时，所以选择了未被社会认可的捷径。 所谓 形式主义，是拒绝社会提供的目标，但仍然遵守社会规范的手段行事。 所谓 退缩主义，是既放弃了社会鼓励的目标，也抛弃了社会认可的手段。 所谓 反叛，是指不仅拒绝社会认可的目标和手段，而且试图从个人观念出发，以新的目标和手段来替代。当这种偏差行为涉及政治领域时，通常也被称为革命。 (2)文化传递理论 文化传递理论，也称为 亚文化理论。文化传递理论由此把社会文化分为两种类型：主流文化和亚文化。亚文化中人们的正常行为在主流文化中就可能被视为偏差行为。 (3)标签理论 标签理论认为，一种行为之所以被视为偏差行为，是因为社会的权力集团给这种行为贴上了 偏差的标签，偏差行为只是一种被社会定义为偏差的行为。 ★★考点4：社会控制(单选、简答) (1)概念: ①广义的社会控制，是指社会组织通过社会规范以及相应的方式和手段，对社会成员的社会行为进行指导和限制，对各类社会关系加以调节和制约、对社会成员的价值观进行引导和约束的过程。 ②狭义的社会控制则主要指对偏差行为给予惩处和重新教育的过程。 (2)特点 ①普遍性。②规范性。③多重性。 ★考点5：社会控制的必要性(简答) (1)表现在社会生活中个人与个人之间、个人与社会之间的目标不一致上。 (2)表现在稳定各种社会关系上。 (3)体现在制止社会生活中各种失控现象的方面。 ★考点6：社会控制的类型(单选) (1)宏观控制和微观控制;(2)制度化控制和非制度化控制; (3)外在控制和内在控制;(4)积极性控制和消极性控制。 社会控制的形式并不以明文规定的条文来实现，而是通过社会成员日常互动所形成的共识来实现，这种社会控制的类型是 非制度化控制。(单选) 考点7：社会控制的方式 (多选) (1)法律控制;(2)道德控制; (3)习俗控制;(4)宗教控制。 ★考点8：社会过控与社会失控(论述) (1)社会过控：指过分强调了社会控制的一面，忽视了社会成员的个性表达及自由要求的一面。 (2)社会失控：指社会控制相对削弱，社会成员的自由散漫性提高。 第十三章 社会问题 ★考点1：社会问题的涵义(单选、多选) 社会问题 是指因个人与社会关系在社会进程中发生了障碍或社会结构与社会环境失调，造成了影响社会全体或部分成员正常生活的问题。 1941年，美国社会学家富勒和麦尔兹在《社会问题的发展》一文中指出，所有社会问题都要经过的阶段包括 警觉、政策制定和改革。(多选) 考点2：社会问题的构成要素 (1)某些社会现象产生了失调情况;(2)这种失调影响了许多人正常的社会生活; (3)这种失调引起了相当多社会成员的关注;(4)这种失调需要动员社会力量进行综合治理。 ★考点3：社会问题与个人困扰的区别(单选、简答) 美国社会学家赖特·米尔斯在《社会学的想象力》一书中，把社会问题视作公众问题，认为公众问题与个人困扰不同。 (1)个人困扰必须和个人的自我联系在一起，只关系到个人直接体验的有限的社会生活领域，而“社会问题所牵涉的事情超出个人的局部环境，超出个人一已的生活领域”。 (2)困扰只涉及个人，即个人感到自己所珍重的价值受到威胁，而社会问题涉及的是公众，即公众所共同珍重的某个价值受到威胁。 (3)“个人困扰具有个人的特点，它只发生在个人与他人直接构成的关系区域里”。而社会问题具有公众的特点，它常常包含着制度上、结构上的危机，也常常包含着马克思所说的“矛盾”和“斗争”。 ★考点4：社会问题的一般特征(多选) (1)社会性;(2)普遍性;(3)特殊性; (4)集群性;(5)复杂性。 ★★考点5：社会问题研究的几个理论(单选、多选) (1)社会病理学；(2)社会解组理论;(3)价值冲突理论; (4)行为偏差理论;(5)社会建构理论。 解决社会问题的途径在于加强社会对个人的道德教育，这一观点来自于 社会病理学。(单选) 社会问题仅仅是人们对某种社会情况的界定过程的主观产物，这种观点来自于社会问题研究理论中的 社会建构理论。(单选) ★考点6：社会解组理论 (单选) 社会解组理论侧重从社会结构角度解释社会问题，其代表有 库利、奥格本、托马斯和兹纳尼茨基 等。所谓社会解组，是指社会中的各种规则对约束个人的行为失去了效力，社会既不能提供给人们以预期的奖赏和回报，也不能对违规的行为加以惩罚。 社会解组有三种形式：一是 无序状态，即社会生活中没有一套统一的合适的社会规范来指导人们的行动；二是 文化冲突，即社会生活中至少存在两种相互对立的价值规范和规则，使人们无所适从；三是 价值崩溃，即社会的价值体系和规范体系完全混乱。这一理论认为，社会问题最有效的解决方法是尽快建立社会规范和秩序，重建社会的均衡体系。 ★考点7：结构性问题(单选) 结构性问题指社会制度或社会政策失调诱发的社会问题。如人口问题、失业问题、贫困问题、老龄化问题、城乡差距问题、社会福利问题、劳资纠纷问题、腐败问题、环境污染问题、教育不平等问题、种族问题、民族问题、恐怖主义问题等。 考点8：腐败 腐败是权力的滥用，即国家工作人员利用政府和公众所赋予的权力和权威，侵吞、窃取、骗取或以其他手段为个人或个人所效忠的某个集团非法占有公共财物的行为。 ★考点9：中国农村的贫困问题的原因(简答、材料) (1)历史因素；(2)自然因素;(3)地区发展不平衡制约; (4)制度政策影响;(5)家庭及个人原因;(6)社会生产力水平低(根本原因)。 ★★考点10：中国城市的贫困问题(简答、材料) (1)城市贫困人口构成 ①下岗失业人员; ②低收入群体; ③老弱病残和“三无”人员； ④在校生和其他未成年人; ⑤进城务工的贫困农民工； ⑥在城市化进程中失地的贫困农民。 (2)原因 ①从历史因素来看，人口众多、决策失误、生产效率长期低下及“多子多孙多福气”思想观念影响等; ②从社会经济原因看，主要是国有企业的制度缺陷、社会保障制度改革滞后、传统的就业用工制度等; ③从收入分配原因看，主要是行业分配不公与分配要素发生变化导致贫富分化; ④从失业原因看，中国正处于一个失业高峰期; ⑤从个人及家庭原因看，单亲家庭、有残疾人、重病患者、无养老金的老年人家庭，家庭负担重、贫困人口构成复杂。 ★考点11：偏差性社会问题(单选) 般指个体偏离或违反一定社会行为规范造成的社会问题。如斗殴问题、酗酒问题、吸毒问题、艾滋病问题、赌博问题、自杀问题、贪污问题、投机作问题、抢劫问题、走私问题等。其中有的是违纪违法问题，有的是违法犯罪问题。 考点12：自然性社会问题 自然性社会问题也就是自然灾害问题，指一种人类无法控制的力量造成的社会问题。 自然灾害是自然界的部分物质以特殊的方式进行的自然运动，通常称为“自然变异”或“自然事件”。 ★考点13：社会问题防治(单选、简答) 社会问题防治，指对显露或潜在的社会问题进行科学分析，采取相应的对策和手段，避免、减少社会问题的发生或使社会问题得以缓解和解决的综合治理过程。 ★考点14：社会问题防治的战略思想(单选) (1)全球性思想;(2)全局性思想；(3)长期性思想。 ★★考点15：社会问题防治的战略措施(论述) (1)解放和发展生产力。 (2)改革上层建筑和意识形态。 (3)发展科学技术。 (4)完善社会保障制度，缓解后顾之忧。 (5)建立社会预警系统。 (6)发挥舆论监督的作用。 第十四章 社会变迁 ★★考点1：社会变迁(单选、多选、简答) (1)概念 社会变迁，是个人与社会的关系基本形态的变异。 (2)内容 ①社会关系的基本制度; ②社会的基本结构; ③社会关系的基本面貌; ④人与自然。 (3)特点 ①必然性。②前进性。③非直线式。④全面性。 ★★★考点2：社会变迁的基本类型(单选) (1)社会进步与社会倒退 ①社会进步 是指人类社会由低级向高级合乎规律的前进运动，社会形态的更替是社会进步的过程。 ②社会倒退 是社会局部或整体，从已经达到的较高发展阶段向较低发展阶段变化的过程。 (2)社会改革与社会革命 ①社会改革 是人们有意识地规划并在较短时间内实现的社会局部调整或全面改良的过程。 ②社会革命 是一种急剧的、对整个社会进行根本改造的社会变迁形式。 (3)整体变迁和局部变迁 ①整体变迁 是整个社会体系的变化，是各个社会要素变化合力的结果。 ②局部变迁 是社会要素及它们之间相互关系的变化，如经济体制、政治体制和文化体制等方面发生的变化。 (4)自发变迁与有计划变迁 ①自发的社会变迁 指被动地参与或盲目地顺从社会变迁。 ②有计划的社会变迁 指人类有意识、有目的地参与或控制社会变迁。 考点3：社会变迁的原因 (1)社会生产力的增长以及生产力与生产关系的矛盾运动。 (2)社会物质需要和利益之间的冲突。 (3)科学技术的发明创造。 (4)文化的发展与传播。 (5)观念的改变。 (6)人口状况的改变。 (7)外来入侵、环境破坏、自然灾害等。 考点4：社会发展计划(单选) 社会发展计划 是对社会发展总的方向、大目标、主要步骤与重大措施的设想。社会有计划地发展与变化是现代社会的基本特征之一。 考点5：社会现代化 社会现代化，是指由传统农业社会向现代工业社会的变迁过程，是在社会分化的基础上，以科学技术进步为先导，以工业化、城市化、民主化和知识化等为主要内容，经济与社会协调发展的社会变迁过程。 ★★考点6：社会现代化的特征(简答) (1)社会现代化是一项社会领域的革命进程，它有六个基本内涵： ①从农业社会向工业社会、从工业社会向知识社会的两次社会转型; ②社会生产力和生活质量的持续提高; ③生活方式和观念的深刻变化; ④国民文化和健康素质的大幅提高; ③国内社会福利与社会公平的根本改善; ③国际社会地位的变化。 (2)社会现代化是一个长期的、有阶段的历史过程。 (3)社会现代化是一场持续的国际竞赛，包括不同国家追赶、达到和保持世界先进水平的国际竞赛，以及国内社会生活、社会结构、社会制度和社会观念的变化。 ★★★考点7：社会现代化理论(单选) (1)经典现代化理论 经典现代化理论是二战以后以西方发达国家现代化过程为研究对象形成的理论成果的统称。其主要代表人物有 帕森斯、列维、勒纳、摩尔、英格尔斯、麦克勒兰德、布莱克、艾森斯塔德 等。 (2)依附理论 依附理论的代表人物主要有 霍布森、普雷维仕、弗兰克、阿明、费尔南多·卡多索和恩佐·法莱图 等学者。 (3)世界体系理论 世界体系理论 20 世纪 70 年代兴起的一种有广泛影响的理论，以 美国社会学家 沃勒斯坦 为代表。 (4)“信息社会论” 1980 年法国 让-雅克·塞尔旺-施赖贝尔 根据巴黎小组研究成果写出的《世界面临挑战》、美国学者 **托夫勒 的《第三次浪潮》**和美国学者 奈斯比特 的《大趋势》 是系统论述信息化社会的代表著作。 (5)“后工业社会论” “后工业社会论”由美国社会学家 丹尼尔·贝尔 在其代表作《后工业社会的来临》中首先提出。 ★★考点8：中国的社会现代化(单选) (1)现代化起步阶段(1840~1911); (2)局部现代化阶段(1912~1949); (3)全面现代化探索期(1949~1977); (4)全面现代化发展期(1978年至今)。 考点9：全球化 (1)含义 全球化是指在全球范围内展现的涉及政治、经济、文化、社会等各个领域的客观历史进程和趋势，同时也是世界共同体的各个国家和地区彼此之间的交往和交换关系进一步加强、彼此之间的依存性、关联性程度不断加深的过程。 (2)特征 ①全球化是一个客观的历史进程。 ②全球化是一个多维度的过程。 ③全球化是世界各国的共同性与差异性相统一的客观要求。 ④全球化过程是一个不断出现矛盾和冲突的过程。"},{"title":"使用 Netlify 免费部署云函数","path":"/2024/02/15/使用Netlify免费部署云函数/","content":"简介 Netlify 类似于 Vercel。更多信息请自定阅读官网介绍。 Netlify 每个月有 100G 带宽，300 分钟免费构建时间。 前置准备 NodeJs 18.x+ Git 编写无服务函数说明 使用 js 编写。Netlify 提供了两种函数，分别为 Functions 和 Edge Function，这里我们只介绍 Function。 默认函数目录为 YOUR_BASE_DIRECTORY/netlify/functions。Netlify 将在每次构建期间访问 functions 目录，并每个支持的代码文件并将其部署为函数。您可以将函数文件直接存储在 functions 目录下或专用于函数的子目录中。如果选择子目录，则函数入口文件必须命名为 index 或与子目录同名。例如，以下任何文件都将创建一个名为 “hello” 的函数： netlify/functions/hello.mjs netlify/functions/hello/hello.mjs netlify/functions/hello/index.mjs 函数运行环境说明 Netlify 函数在 Node.js 中运行，Node.js 18.0.0 是所需的最低版本，因为函数使用标准的 Fetch API，该 API 仅在版本 18.0.0 以及最新版本添加到 Node.js 中，当然，您可以使用 环境变量 来设置 Node.js 版本。 Node.js 支持两种不同的模块格式，它们具有不同的功能和 API： ECMAScript 模块（或 ES 模块）是 JavaScript 包的官方标准格式，而 CommonJS 则是 Node.js 特有的传统格式。 每个函数的模块格式将由其入口文件的文件扩展名决定： 扩展名为 .mjs 的函数总是作为 ES 模块执行。 扩展名为 .cjs 的函数始终作为 CommonJS 执行。 如果最近的 package.json 文件中设置了 type: &quot;module&quot;，则带有 .js 扩展名的函数将作为 ES 模块执行；否则将作为 CommonJS 执行。 选择模块格式会影响函数的编写方式，尤其是在导入 npm 包时： CommonJS 函数不能使用静态导入来加载以 ES 模块形式编写的 npm 包，而必须使用 动态导入。 在引用以 CommonJS 编写的 npm 包时，ES 模块函数不能使用命名导入(例如，import &#123; kebabCase &#125; from &quot;lodash&quot;)，而应使用默认导入(import _ from &quot;lodash&quot;) 在 ES 模块中，Node.js 内置原语(如 __dirname 和 __filename) 不可用，应使用 import.meta.url 代替。 来自官方的提示： 除非您有充分的理由选择 CommonJS，否则我们建议您选择 ES 模块，因为它是一种现代、标准、前瞻性的格式。由于边缘函数也使用这种格式，因此使用这种格式将使您的代码在两种函数类型之间具有互操作性。 获取环境变量 在 Netlify 中获取 Function 的环境变量使用 process.env.VARIABLE_NAME，Edge Function 使用 Netlify.env.get(&quot;VARIABLE_NAME&quot;) 附 本地测试可以使用 Netlify Cli，浪子没有试过，直接 commit Github 测试的。 Netlify 云函数的返回的资源默认不支持跨域，可以进行如下设置： 123456789return &#123; statusCode: 200, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, // 支持所有跨域请求 或者 选择性支持 &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27; || &#x27;Access-Control-Allow-Origin&#x27;: &#x27;你的域名&#x27; &#125;, body: JSON.stringify(data),&#125;;","tags":["netlify"],"categories":["瞎折腾"]},{"title":"Word 选用字体格式参考","path":"/2024/01/12/Word选用字体格式参考/","content":"本文仅供参考。 论文格式 1 ~ 3级标题 名称 字体 字体大小 对齐 缩进 间距 行距 示例 一级标题 黑体 小三号 （可选加粗） 段前 0.5 行，段后 0.5 行 通常 1.5 倍行距 1. 第一章 二级标题 黑体 四号 （可选加粗） 通常 1.5 倍行距 1.1. 第一节 三级标题 黑体 小四号（可选加粗） 通常 1.5 倍行距 1.1.1. 第一条 正文 中：宋体英：Times New Roman 小四号 2 个字符 1.5 倍行距 目录标题 黑体 三号 居中 通常 1.5 倍行距 目录 目录内容（一般放置两级标题） 宋体 小四号 18 磅行距 1.1. 第一节 开始·······3 图片标题（位于图片下方） 黑体 五号 居中 段后 0.5 行 图 1.1 xxx 表格标题（位于表格上方） 黑体 五号 居中 段前 0.5 行 表 1.1 xxx 表格内文字 中：宋体英：Times New Roman 五号 参考文献标题 黑体 小三号 居中 参考文献 参考文献内容 宋体 小四号 18 磅行距 [1] author, filename, press, date 所有有关“量”的符号使用 斜体 表示，例如 速度 (v)、密度 (ρ) 等； 单位符号使用 正体 表示，例如 m/s、km/h。 如果每章的标题需要新起一页，在 word 中使用快捷键在标题前使用 Ctrl + Enter 一般标准 word 格式参考 各公司标准不同，以下内容来源于互联网。 目前公文大都是采用： 标题：二号 至 三号，黑体； 小标题：三号，粗体； 正文：四号或者小四号，仿宋体 摘要：小四号，楷体。","tags":["word"],"categories":["瞎折腾"]},{"title":"行政组织理论","path":"/2024/01/06/行政组织理论/","content":"行政组织理论学 2019 版 ——高等教育出版社(倪星)，含多选。 行政组织理论（总分100分，考试时间150分钟） 一、单选题(共25题，每题1分，共25分) 二、多选题(共6题，每题2分，共12分) 三、简答题(共5题，每题5分，共25分) 四、论述题(共2题，每题12分，共24分) 五、案例分析题(共1题，共14分) 一、绪论 行政与组织理论概述 组织 是人类生存的基本方式，是连接人与社会的中介， 是社会的细胞、社会的基本单元，是人们实现共同目标的工具。(单选、辨析) 广义的行政组织是指各种为达到共同目的而负有执行性管理职能的组织系统。它既包括各类企事业单位、群众团体、政党中的负有管理职能的组织系统，也包括国家机关中的立法、司法系统中负有执行性职能的各类单位和国家的整个行政机关。 狭义的行政组织是指国家的行政机关，即根据宪法和法律组建的、体现统治阶级的意志、行使行政权力、执行行政职能、推行政务、管理国家公共事务的机关体系，是国家权力的执行机关。(辨析) ★ 构成组织和行政组织的要素有 (1)三种物质要素：人员、经费、物资设备 (2)三种精神要素：目标、权责结构、人际关系 行政组织的 第一个物质要素 是人员，这是行政组织的主体、核心； 经费 是维持行政组织运行与发展不可缺少的要素； 物资设备 是行政组织赖以生存和发展的物质基础。 ★ 行政组织的一般性质包括 静态的组织结构、动态的组织过程、生态的组织环境 和 心态的组织意识 四个方面。 ★ 职位 是行政组织的基本元素和细胞，职位之间的权责关系构成了整个行政组织的结构。职能目标是组织结构建立的依据，是组织的层次和部门划分、职位配置的出发点和归宿。 ★ 行政组织的特殊性质体现为 政治性、社会性、权威性、 法治性、系统性、服务性。 行政组织功能是指作为国家行政管理主体的各种行政组织，在依法管理社会公共事务的过程中所具有的独特作用。它反映着国家行政管理活动的基本内容与行为方向，是国家本质的具体表现。 行政组织功能的行使以立法机关制定的法律为出发点，以司法机关的强制力为后盾。 行政组织功能 的内容有 政治功能、经济功能、文化功能、社会功能。当代各国行政组织的社会功能主要有提供社会保障、促进公正的收入分配、控制人口增长和环境保护。 行政组织功能的特点 (1)广泛性与有限性 一方面，行政组织功能具有无所不包的广泛性。另一方面，行政组织功能又是有限的，它表现在：第一，行政组织功能发挥的领域和程度要以社会需要为限;第二,凡是私人生活领域,只要不触犯刑律，行政组织就不应干预；第三，行政组织功能发挥要以法律为依据；第四，行政组织自身的能力也是有限的。 (2)稳定性与变异性 一方面，行政组织活动的普遍性,要求其功能具有一定的稳定性。另一方面，行政组织的功能又具有变异性，行政组织功能不是一成不变的。 行政组织理论的研究内容包括: (1)综合性总体研究，主要研究行政组织的性质、要素、作用、区别及历 史发展与理论发展; (2)静态研究，主要研究行政组织的目标、结构和体制; (3)动态研究，主要研究行政组织的建立、管理与变革。 行政组织理论的学科性质 行政组织具有双重的性质，它既是统治阶级实现对社会统治的工具，又是国家政权对社会公共事务进行管理的主体，由此决定了行政组织理论既有特殊的 政治性，又有各个不同国家所共有的 社会性。 ★ 行政组织理论的研究方法和意义 行政组织理论的研究方法主要有 阶级分析的方法、系统分析的方法、理论联系实际的方法、静态与动态相结合的方法、纵向与横向相结合的方法 等五种方法。 ★ 行政组织理论的研究意义 (1)研究行政组织理论是为了建立具有中国特色的行政组织理论体系。 (2)研究行政组织理论是实现行政组织科学化、法治化和现代化的需要，是社会健康发展的需要。 (3)研究行政组织理论是我国当前行政组织改革的实践需要，它可以为行政组织改革的实践提供理论上的指导。 (4)研究行政组织理论是优化行政工作人员的素质、提高其管理水平和工作能力的需要 ★ 理论联系实际的方法 理论联系实际是马克思主义的一个基本原则，也是研究行政组织理论应有的学风和方法。它要求任何理论的研究必须从实际出发，实事求是，从大量的客观存在中寻找其自身的规律。行政组织理论是一门应用科学，具有直接的实践性，理论联系实际的方法显得更为重要。 二、行政组织的演变 外国行政组织的演变 奴隶制时期的外国行政组织 原始社会末期，随着阶级和国家的出现，产生了最早的行政组织。 外国奴隶制时期最典型的行政组织是 古埃及、古希腊、古罗马。 古埃及实行奴隶主君主专制，其行政组织是高度混同的，祭司在国家机构中地位显著。雅典是古代奴隶主民主共和政体的典型,当时国家最高权力机关是 公民大会，最重要的权力机关是 元老院。保民官 是古罗马平民的代言人，其职责是维护平民的利益，这是罗马民主制的一大特色。 雅典的行政组织具有原始的民主行政特征，强调依法行政，行政官员非专业化、非职业化、无报酬,行政职能简单。古罗马的行政组织分古罗马共和国时期和古罗马帝国时期两个阶段。共和国的日常行政机关掌握在执政官、检察官、保民官、营造官等高级长官手中。公元4世纪，古罗马帝国被统一划成高卢、意大利、伊里利亚和东方四大行政区。 ★ 奴隶制时期外国行政组织的特点 (1)行政组织职能简单且未明确分化。 (2)古希腊、古罗马的行政组织与国家机关其他组织开始有了初步的原始的分工，行政管理也带有民主与法治色彩，不同于古埃及的君主专制。 (3)中央和地方的关系相对简单。 (4)在共和制时期，行政组织的官员都无报酬，任期短，行政工作未职业化。 ★ 封建制的行政组织，东方以中国为代表，西方以英国为代表。西方国家的议会和内阁都 发源于英国。御前会议的出现意味着国王和国家行政组织开始从贵族会议中分离出来。“地方自治之乡”在 英国。监察官的设置是 法国 完成中央集权化的行政框架的重要标志。 ★ 英国在盎格鲁-撒克逊时代有国王和贤人会议两个权力中心，在威廉时期形成召集贵族会议和御前会议的惯例。英国地方行政组织由 郡、百户区、村社 三级组成。中世纪法国君主制度经历了地方分封的封建君主制、等级君主制、中央集权的专制君主制三个阶段，行政组织也经历了相应演变。 ★ 封建制时期英法行政组织的特点 (1)立法权与行政权相对分离，行政权受到立法权的制约。 (2)中世纪末期，随着专制王权的确立，宫廷的内务组织演变成全国的中央行政组织。 (3)地方行政组织较奴隶制时期有很大的发展。 (4)王权与教权的关系十分密切，它们之间既有斗争又有合作。 资本主义时期的国家行政组织才是现代意义上的行政组织。就政府组织形式而言，最典型的有英国的内阁制、美国的总统制、法国的半总统制三种 (1)英国的中央行政组织主要有枢密院、内阁和政府各部。内阁是英国 实际上的最高行政机关，是英国政府的核心机构，其主要职能有:行政职能、决策职能、立法职能、监督职能。英国地方行政组织一般分为二级(郡、区)或 三级(郡、区、教区或社区)。其主要职能有:管理交通道路、维护公共秩序和 治安、搞好环境卫生、制定和实施城乡规划、发展公共事业、提供福利服务。 (2)美国是联邦制国家，又是实行三权分立制最典型的国家，也是总统制 特征最突出的国家。美国行政组织包括联邦政府机构、州政府机构以及地方 政府机构。联邦政府机构由总统直属机构、内阁和行政部、独立行政机构组 成，其中部是最重要的行政机关。 独立行政机构有“第四部门”之称，县有专业性强、具有独产性、行使 混合权力、办事效率高的特点 联政府第一个具有重要地位的独立行政机构是1887年成立的州际商业委 员会联邦政府与州政府实行分权制，不存在直接的领导和从属关系。美国市政府的组织形式有市长一市议会制(最古老、最通行)、市经理制、委员会制、大都会区制四类 (3)法国的半总统制半议会制体制是行政组织运行的基础其中央行政组织由总统总理和中央各部等组成，地方行政组织有大区、省和市镇三个层次。省是法国最主要的国家行政区域，市镇是法国最古老的地方行政组织。法国行政体制的主要特征是高度中央集权，中央政府对地方团体自治行政机关行使监督权。 美国内阁与英国内阁的不同特点 (1)美国的内阁不决定任何政策，也没有集体的政治责任。 (2)美国内阁只向总统负责，不向国会负责。 (3)美国内阁没有固定的组织形式，没有固定的人员，没有固定的会期。 法国地方行政组织的特点 (1)每一个层级，既是地方的国家行政机构，是中央政府在地方的代表。 (2)其机构为各级政府及其行政长官，同时又是地方团体自治行政机关，其机构是议会及议长。前者负责国家在地方的事务，后者负责纯地方事务。 资本主义时期外国行政组织的特点 (1)行政组织日趋独立且职能不断扩大，行政组织总量不断增加。 (2)行政组织职能已从原来的以政治职能为主转变到现在的以经济和社会职能为主。 (3)行政权力越来越大。行政权力在国家权力体系中的地位逐步上升。 (4)中央适度集权与地方适度分权是市场经济条件下各国的共同要求。 中国行政组织的演变 夏朝创立了王位世袭制度,周朝中央政府主要机构是“三司”&quot;六太”。秦汉确立专制主义中央集权制,中央朝廷内实行三公九卿制，其中丞相地位最高。自魏晋至隋、唐形成了三省六部二十四司制(中书、门下、尚书三省，吏、户、礼、兵、刑、工六部)，其中尚书省是全国最高行政机关。 宋、元时中书省逐渐成为最高行政机关，枢密院、中书省、御史台是当时中央最重要的三大机关。明、清罢丞相设内阁。地方行政组织演变，秦设郡、县两级，汉末有州、郡、县三级，隋、唐有州、县两级，宋朝有路、州、县三级，元朝有省、路(府、州)、县三级，明代有省、府、县三级，清朝有省、道、府、县四级。元朝创立的行省制度是我国古代地方行政组织的一次重大改革。 中国古代行政组织的特点 (1)强化中央集权，集国家最高权力于一人之手，是中国古代行政组织发展的主流。 (2)中国古代行政组织的演变具有前后因袭、循序渐进的特点。 (3)中国古代行政组织结构严谨，分工精细，层级节制，集中统一。 (4)中国古代的行政组织具有强烈的宗法色彩 南京临时政府时期(1912-1913)：先依据《临时政府组织大纲》，采取总统制，后公布《中华民国临时约法》，改总统制为参议院下的内阁制。 北洋政府时期(1913-1928)：公布《新约法》，改内阁制为“总统制”后改帝制。 国民政府时期(1927-1949)：根据孙中山的五院制构想，国民政府由行政院、立法院、司法院、考试院和监察院组成，行政院是国民政府的最高行政机关，五院院长由国民党中央执委会选任。 中华民第一阶段(1949-1954)的行政组织:典型的议行合一体制政务院是国家政务的最高执行机关。第二阶段(1955一1966)的行政组织：全国人民代表大会是国家最高权力机关，国务院是最高国家权力机关的执行机关，国务院组织结构由职能机构、直属机构、办公机构三大块组成。国的行政组织特点 (1)中华民国的行政组织在其初创期，接受了西方三权分立与民主共和国的思想。 (2)孙中山提出的政权和治权相区别，在国民大会下实行立法、行政、司法、考试、监察五权分立的思想，具有历史的进步意义。 (3)从法律上确立了国民党一党专政的政治体制。 (4)在中央与地方的关系上，国民政府没有也不可能实现孙中山的均权制主张，而是中央集权制与地方军阀割据并存。 中华人民共和国的行政组织 第一阶段(1949-1954)的行政组织：典型的议行合一体制，政务院是国家政务的最高执行机关。 第二阶段(1955一1966)的行政组织：全国人民代表大会是国家最高权力机关，国务院是最高国家权力机关的执行机关，国务院组织结构由职能机构、直属机构、办公机构三大块组成。 第三阶段(1967一1974)的行政组织：上海“一月风暴”后,革命委员会成为政府机构,1970年开始的机构大精简使国务院机构总数达到中华人民共和国成立以来的最低点(32个)。 第四阶段(1975-1981)的行政组织：到1981年12月,国务院机构总数达到中华人民共和国成立以来的最高点(100个)。 我国多数地方行政组织为省、市(地级)、县、乡四级。全国有 23 个省、5 个自治区、4 个直辖市、香港和澳门 2 个特别行政区，6 个行政特区。地方各级人民政府之间基本没有职能的不同，只有管理地域面积的大小或个别机构不同。 地方各级政府机构大致分为经济管理部门、政法管理部门、综合管理部门、教科文卫事业管理部门、经济和社会的监督部门和其他管理部门六类。国家规定省级政府设 40 个左右机构，地级市政府设 30 个左右机构，县级政府设 20 个左右机构。在中央与地方的关系上，实行层级节制的中央集权型行政体制，这一体制是在计划经济时期形成的。 ★ 中华人民共和国行政组织的特点 (1)中华人民共和国行政组织具有充分的人民性，人民代表大会制度是中华人民共和国的根本政治制度。 (2)中华人民共和国行政组织的设置与运行，本着精简、统一、效能的原则，不断进行调整与改革，并取得了一定的成就。 (3)在处理中央与地方的关系上，我国行政组织基本上贯彻了民主集中制原则。 (4)中华人民共和国行政组织在其发展的历史过程中，也暴露出一些弊端，如机构臃肿、部门林立等。 ★ 两个“怪圈”与计划经济体制的关系 (1)我国行政组织进行过多次调整与改革，虽然取得了一定的成效，但始终摆脱 不了两个“怪圈”:一是机构设置上的“精简——膨胀——再精简——再膨胀”的怪圈；二是权限划分上的“一统就死，一死就放，一放就乱，一乱就收”的怪圈。 (2)就我国的实际情况分析，高度集权的管理体制以及政府对社会经济事务的直接管理方式是导致这两个怪圈的根本原因，而高度的集权管理体制和政府对社会经济事务的直接管理又根源于无所不包的计划经济体制。 三、科层制组织理论 科层制组织理论的产生 科层制概念的源起 科层制是一种建立在合法统治理论基础之上的，以分工、分层、规则、集权等为特性的金字塔式的组织结构形态和管理方式，其理论产生与发展应归功于 韦伯。 科层制组织兴起的条件 社会分工的出现 货币经济的存在 大众化教育的普及 理性精神的普遍认可 科层制组织的理论和实践基础 威尔逊 于 1887 年发表了《行政学研究》一文，他在文中指出行政学研究的目标在于了解。为了政府能够成功有效地完成工作，威尔逊又进一步提出了 政治与行政二分法 原则，这种理论的建构为韦伯的科层制理论体系提供了学理上的支持。 19世纪70-80年代英美两国先后建立了文官制度，即国家公务员制度。文官制度的建立实行了新的人事管理原则，主要包括 法制化、职业化、专业化、价值中立、政务官与事务官分离 等原则，这些原则为韦伯科层制理论的实践奠定了基础。可以说，韦伯科层制理论正是通过公务员制度的建立与发展，才得以从理论走向了实践。 科层制组织的特征与要素 ★ 科层制组织的基本特征包括: 专业化、层级化、规则化、非人格化、技术化 专业化原则既适用于组织中的个人,也适用于组织单位或分工关系。在层级制组织中工作是根据工作类型和目的进行划分的，有很清楚的职责范围,对权力义务体系的规定细而明晰，使得每个人都能够按照章办事而不超越义务的范围。 层级化又称等级化，机构和行政人员按照层级原则进行管理。科层制组织是一个等级实体,具有等级与权力一致的特征,在这样的一个等级实体中,将各种公职或职位按权力等级组织起来，形成一个指挥统一的指挥链条，沿着自上而下的等级制,由最高层级的组织指挥控制下一层级的组织直至最基层的组织,于是便形成科层制组织中层级节制的权力体系科层制组织拥有大批行政人员,其高度专业化需要一个复杂的协作系统 规则化又称法制化、制度化。在现代科层制组织中，通常要制定一套规则和程序来规范组织及其成员的行为,以保证整个组织管理工作的一致性和明确性，组织还行包括成员间的活动与关系都受规则或制度限制。 非人格化：在一般组织中,人们的个人情感和偏好等非理性因素常常会影响其理性、合法性和客观性，并进而会助长亲情、裙带和偏爱等关系。“非人格化”被视为科层制组织的“特殊美德”。 技术花：专业化、层级化的科层制要求管理者必须训练有素。在科层制组织中组织成员都具备相应的专业技术资格，组织成员凭自己的专业所长、技术能力获得工作机会,享受工资报酬;组织按成员的技术资格授予其职位,并根据成员的工作成绩与资历条件决定其晋升和加薪与否，从而促进个人为工作尽心尽职,保证组织效率的提高。 科层制组织的要素体质 尽管现代社会科层制组织机构的形式干差万别、各有侧重，但就最般、最抽象的特征而言，却与韦伯科层制所设立的机构规范内容一致。 权限预先确定; 职位的层级化； 职务的履行; 职位； 调节; 专业训练; 工作例行化; 限制 角色要素的原则，被加 布里埃尔·亚伯拉罕·阿尔蒙德 处理为 “选择和诱导” 两个标准化的分析概念。 科层制组织价值规范的 核心要素 有: (1)效率 (2)功利 (3)工具一目标取向的合理 (4)服从 合理性是韦伯科层制理论重要的学理预设，是他设计理想型科层制模式的一个最基本原则。 韦伯认为合理性有两种形式，即形式合理性(或工具合理性)和实质合理性(或价值合理性)。 ★ 为了构建合法性的现代统治类型，韦伯将合法性权威分为三种类型: 传统权威、魅力权威、法理权威 传统型组织是以传统权威为核心、以先例或惯例为基础的组织，而这些先例或惯例是由其统治者以传统遗传下来的规则加以确定的。 魅力型组织，又称神秘化组织或卡里斯马型组织，这种组织形态基于领导者的“超凡魅力”(包括领袖的超人能力、英雄主义精神及模范品格等)而产生。 魅力型组织主要表现为以下特点： 维系组织的基础是非理性的 组织内部管理的非专业化 组织的不稳定性 不同权威下的组织类型 理性——合法型组织,又称科层制组织。这类组织以组织内部的各种规则为基础，人们对权威的服从以依法建立的等级体系为依据。 科层制组织的实践困境与理论发展 科层制组织的实践困境 形式主义导致的效率悖论 压抑个性导致的创新缺失 本位主义导致的合作意识缺乏 文牍主义导致的积极性不足 权力垄断导致的反民主性 科层制组织理论的延续和发展 [单选] 米塞斯将科层制度界定为“一种行政技术和组织原则””。他指出,人们经常认为科层管理和民主政府、民主制度是不相容的,这是一种谬见。 [单选]默顿对科层制所引|起的组织功能失调问题进行了深人研究，最早提出“反功能”这一概念，其主要是针对韦伯几乎只强调科层制的正面功能而提出的。 默顿指出，科层制在提高了效率的同时，也具有明显的反功能，其主要表现为：刻板僵化，墨守成规，效率只针对例行事务，一旦特殊事件发生，既定条件改变，便反应迟钝，动作缓慢。 当西方公共行政学界对科层制的批判和否定正值高峰之时,查尔斯·古德塞尔提出了不同于主流论调的独特观点。他认为,来自大众媒体的指责有失偏颇，其可信度将受质疑，而学术界的批评更为激烈和深刻。 古德塞尔主要从五个方面对科层制进行了辩护 对有关科层制的调查数据进行分析 对科层制进行比较研究 指出科层制已背负“不能承受之重” 对科层组织中的成员进行部析 又对科层制的规模进行新考察 [单选]塞尔兹尼克对科层组织内部的授权问题进行了研究，他认为授权是科层制实行控制的需要。当组织规模达到一定程度后，由于个人能力的限制,组织必须进行分权和授权。 ★ 科层制组织理论的延续和发展 米塞斯对科层制的辩证理解 默顿、布劳等对科层组织反功能的分析 古德塞尔对科层制的辩护 塞尔兹尼克对于科层组织内部授权的研究 四、人本主义组织理论 人本主义组织理论的产生 ★ 人本主义概念的源起[单选、辨析] 人本主义的本质是把人变为主体，号召人以主体的姿态面对整个世界；强调的核心是人的主体性，即人类主体性和个体主体性。所以，人本主义就其本质而言就是以人为中心的主体主义。 人本主义组织理论的产生背景 [单选、辨析] 20世纪20年代以后，人们的教育水平普遍提高，各种需要随之产生这一时期，资本主义国家中许多企业尽管采取了 泰勒的科学管理，但劳资纠纷和罢工还是此起彼伏，此种情况是促使资产阶级的管理学者深入研究决定工人劳动效率的关键因素的原因。在这种背景下，20 世纪 30 年代，人本主义的组织理论就应运而生。 人本主义组织理论的提出 [单选、辨析] 所谓人本主义组织理论，是以社会心理学及行为科学的理论和研究为主要依据，对人在组织中的本性和需要、行为和动机以及工作中的人际关系进行分析研究的组织理论，其研究内容主要包括： 组织中人的社会心理因素、行为动机； 工作者个人的工作生活质量、激励方法及效果、人性与组织等； 人本主义组织理论的主要思想 梅奥的人际关系学说 梅奥的人际关系学说 [简答] 人际关系学说的主要观点 (1)工人是“社会人”而不是“经济人” (2)企业中存在“非正式组织” (3)满足工人的社会欲望，提高工人的士气，是提高生产效率的关键 (4)采用新型的领导方法 ☆ 梅奥认为：组织可以分为“正式组织”和“非正式组织”两种。 正式组织，是指为了实现组织总目标而担当有明确职能的机构，这种组织对于个人有强制性，这是古典组织论者所强调和研究的。 梅奥的人际关系学说 人际关系学说认为，职工在共同工作和共同生产中，必然产生相互之间的人际关系，产生共同的感情，自然形成一种行为准则或习惯，要求个人服从。这就构成了“非正式组织”，这种非正式组织对于工人的行为影响很大，是影响生产效率的重要因素。 巴纳德的非正式组织理论 [单选] 对于个人目标和组织目标的不一致，巴纳德提出了 “有效性”和“能率” 两条原则。 [单选] 巴纳德提出了“组织人”的概念，对行政人员最重要的要求就是忠诚，或者受“组织人格”的控制。 马斯洛的需要层次论 [单选、多选] ★ 马斯洛把人的需要划分为五个层次: 生理的需要 安全的需要 感情的需要(归属和爱的需要) 尊重的需要 自我实现的需要 马斯洛的需要层次论的基本论点 (1)人是有需要的动物，其需要取决于他已经得到了什么，尚缺少什么，只有尚未满足的需要能够影响行为。换言之，已得到满足的需要不能起激励作用。 (2)人的需要都有高低层次，某一层次的需要得到满足后，更高层次的需要才会出现。马斯洛认为，在特定的时刻，人的一切需要如果都未得到满足，那么满足最主要(基本)的需要就比满足其他需要更迫切。只有排在前面的那些需要得到满足，才能产生更高一级的需要。而且只有当前面的需要得到充分满足后，后面的需要才显出其激励作用。 [简答、论述] 需要层次论在组织管理实践中的应用 在组织管理的实践中，了解员工的需要是应用需要层次论对员工进行激励的一个重要前提。由于在不同组织中、不同时期的员工以及组织中不同员工的需要存在差异性，且经常变化。因此，管理者应该经常用各种方式进行调研，弄清员工未得到满足的需要是什么，然后有针对性地进行激励。 赫茨伯格的双因素理论 [单选、多选] 激励因素属于 工作本身 和 工作内容 方面的因素，是指能带来积极态度满意、自我实现和激励作用的因素，它包括 成就、赏识、挑战性的工作、责任和进步 等五种因素。 [单选、多选] 保健因素属于工作环境和工作条件方面的因素，主要包括公司政策、管理措施、监督、人际关系、工作条件、工资、福利等，没有激励作用 ★ 需要层次理论与双因素理论的关系 赫茨伯格的双因素理论与马斯洛的需要层次理论具有对应关系： 马斯洛提出的 高层次需要 其实就是赫茨伯格的所谓 激励因素。 马斯洛列举的为维持生活所必须满足的 低层次需要 则相当于 保健因素。 ★ 双因素理论的应用 (1)直接满足。这种满足是通过工作本身和工作过程中人与人的关系得到的。它能使员工学习到新的知识和技能，产生兴趣和热情，使员工具有光荣感，责任心和成就感，因而，可以使员工受到内在激励，产生极大的工作积极性。对于这种激励方法，管理者应该予以充分重视。这种激励的措施虽然有时所需的时间较长，但是员工的积极性一经激励起来，不仅可以提高生产效率，而且能够持久，所以，管理者应该注意充分运用这种方法。 (2)间接满足。这种满足不是从工作本身获得的，而是在工作以后获得的。例如晋升、授衔、嘉奖或物质报酬和福利等，就都是在工作之后获得的。间接满足虽然也与员工所承担的工作有一定的联系，但它毕竟不是直接的，因而在调动员工积极性上往往有一定的局限性，常常会使员工感到与工作本身关系不大而满不在乎。研究者认为，这种满足虽然也能够显著地提高工作效率，但不容易持久，有时处理不好还会发生副作用。 麦格雷戈的X理论一Y理论 [简答] 麦格雷戈的X理论一Y理论 X理论的主要观点： (1)一般人生来就是懒惰、不求进取的，希望工作越少越好，所以总是设法逃避工作。 (2)多数人都没有雄心壮志，愿意接受别人的指挥或指导，而不愿主动承担责任。 (3)多数人的个人目标都是与组织的目标相矛盾的，必须用强制、惩罚的办法，才能迫使他们为实现组织目标而努力。 (4)激励只在生理和安全需要层次上起作用，只有金钱和地位才能鼓励他们努力工作。 (5)人习惯于守旧，反对变革，绝大多数人只有极少的创造力和想象力。 (6)人是缺乏理性的，一般不能控制自己，易受外界或他人影响。 Y理论的主要观点： (1)人并不是生来就懒惰的，而要求工作和劳动是人的本能。 (2)人们具有自我控制和自我监督的能力，即使没有外界的压力和处罚的威胁，他们也一样会努力工作以期达到目的。 (3)人们愿意为集体的目标而努力，在工作上会尽最大的努力，以发挥创造力、才智等。 阿吉里斯的人性与组织理论 [单选、辨析] “组织学习”理论，是阿吉里斯对于组织变革问题的一种继续思考和研究的结果。 [单选、辨析] 阿吉里斯的组织学习，目的是要营造出适应当代社会发展的新型组织，最终效果是要实现员工的个性发展、组织的协调一致、效益的内外平衡(组织内部效率和外部效应的平衡)。 阿吉里斯的组织学习理论的影响 在人际管理的诸多著作中，我们发现阿吉里斯的著作对人性与组织间的关系做了最精致而全面的论述。但是，就当前的观点来看，论述并没有超越工具理性观点的束缚。然而，阿吉里斯所特别强调的组织学习有望最终产生连阿吉里斯本人可能也未曾预料到的深远的影响。 通过他的理论，我们甚至可以在工具理性和对工具理性的批判之间建立起新的联系，其理论对 公共组织 和 私人组织 的理论(尤其是组织变迁方面)已经产生了实际影响。 戈尔姆比斯基的公共组织发展理论 单选 罗伯特·戈尔姆比斯基 把组织发展看作公共部门组织成长与变迁的理论起点，其著作 《人管理与道德》 是其关于行政伦理的早期研究成果。 多选 实验室途径中有 五个 引导个人与组织改变的价值取向: (1)接受以相互接近和开放沟通为基础的询问; (2)行为选择的意识和认知; (3)权威的合作性概念; (4)互相帮助的关系; (5)人际关系中的真诚态度 早期 外国行政组织思想 人物 其思想或原则 柏拉图、《理想国》、《政治家篇》 ①社会分工是国家行政组织存在的基础②无学识者不能治国③治国者应以教育为“第一要务”④依法行政 亚里士多德、《政治学》 ①首次提出将议事权力、司法权力和行政权力相区别②提出设置行政机构的依据③行政组织的职能的思想④行政人员的任用原则⑤建立行政监督机构⑥崇尚法治 马基雅维利、《君主论》《讲话集》、第一个论述过国家行政组织管理原则的人利 ①群众支持原则②组织内聚力原则③组织领导者必须具有超出常人的能力原则④持续存在下去的原则 官房学派 ①建立统一、完整有效的行政组织制度与方法②选用优秀的人才担任国家官职③国家行政机构应将管辖的事务分部门来管理，简化礼仪和行政手续；④加强国家及政府的权力，人民须服从行政管理 卢梭 《社会契约论》 ①政府与公民的关系：强调政府官员是人民的仆从②政府与法律的关系：强调政府行为必须以法律为依归 汉密尔顿 《联邦党人文集》 ①扩大行政部门的权力②建立强有力的行政组织 密尔 ①衡量行政组织工作好坏的标准：能否促进社会利益的增长②界定了政府的职能③行政组织的分工要合理④政府工作是专业性业务，要有专业性人才担任 传统时期，产生于 19 世纪末 20 世纪初 外国行政组织思想 人物 其思想或原则 威尔逊 “西方行政学”创始人 ①明确行政组织的职能、任务和范围②改进政府机关的组织结构与工作方法③行政组织应成为公众信赖的机关 泰罗 “科学管理之父”、《科学管理原理》 ①管理职能与作业职能相分离①管理职能的专门化③组织工作要计划化、标准化、程序化④组织管理中的例外管理 法约尔 《工业管理与一般管理》 ①组织与管理密切相关②管理理论应用范围③组织的层级结构④组织管理的五要素⑤14条组织管理原则 韦伯 “组织理论之父” ①合法的权威的三类型：传统权威；超人权威；法理型权威②官僚制组织的特征（是法理型权威最适宜的组织形式。） 古立克、厄威克 ①首次提出“组织理论“的学科名称②组织管理的 7 项要素和 8 项原则 行为科学时期： 外国行政组织思想 人物 其思想或原则 梅奥 ①“社会人”理论②非正式组织③组织成员的满足度 巴纳德 “社会系统学派”创始人 ①组织的本质是一个协作系统②组织三要素理论③权威来自接受④组织平衡的思想 西蒙“决策理论学派”创始人 ①组织的功能就是决策②组织的目标是追求决策的合理性③组织平衡论④组织影响论③组织设计论 现代： 外国行政组织思想 人物 其思想或原则 柏森斯 ①社会系统中的组织四方面的特质：适应环境、达成目标、统一协调、形态维持②组织的三层次：决策层级、管理层级、技术层级 卡斯特、罗森茨韦克 ①组织是一个开放的系统②组织是一个整体系统③组织的权变观念 雷格斯 最先运用“生态理论” ①三种行政组织模式：融合性；棱柱形；衍射型（农业社会一过度社会一工业社会）②外部生态环境与公共行政之间的制约关系 帕金森定律、彼得原理 课本P74-76 新公共行政学 ①对传统公共行政学“效率至上”的反思与批判②公平之上，组织变革③公共行政组织的四种基本运作过程 企业家政府理论 ①掌舵不是划桨；②要妥善授权，而非事必躬亲；③注重引入竞争机制；④注重目标使命；⑤重产出而不重投入；⑥树立“顾客意识”；⑦重收益、集资、赚钱；⑧重事前预防，不是事后救补；⑨重分权模式和合作式组织；⑩重视市场机制调节，并非仅靠行政指令控制； 彼得斯 改革理论：政府治理的四种模式 休斯 改革理论：新公共管理模式的六大特征 登哈特 改革理论：公共行政组织的思想 人本主义组织理论简评 人本主义组织理论的基本观点 (1)组织的心理一社会性。 (2)组织是一个协作平衡系统。 (3)非正式组织的影响力。 (4)组织的沟通。 (5)组织的人格整合性。 人本主义组织理论的优点 (1)强调“人性”作用而非“机械”的作用 (2)强调“动态”而非“静态” (3)强调“心理”而非“生理” (4)强调“组织功能”而非“组织结构” (5)既重视“正式的”，也重视“非正式的” 人本主义组织理论的缺陷 首先，人本主义组织理论家们多是抽象地研究人的本性和人的行为，并用封闭的观点来研究组织，没有将其与组织条件、外部环境、社会制度或生产关系联系起来 其次，人本主义组织理论研究的对象是人，人有思想、有意识、变化多样，差异甚大，从而带来研究结果的可靠性及置信度等问题; 最后，人本主义组织理论提出的一些命题，像满意的工人是生产能力较高的人、正式结构限制自我实现的满足等，也受到现代组织理论家们的批判因此，人本主义组织理论存在着一定的局限性，但是他们在很多方面弥补了古典组织理论的不足，丰富了组织理论的研究内容和范围。 五、网络型组织理论 多选、简答 网络型组织之所以会出现在20世纪的后期，并迅速成为组织研究的核心，以及在现实经济实践中扮演越来越重要的角色，有其深层根源。 ★ 多选、简答 网络型组织产生的深层根源 网络型组织可归纳为以下五点 (1)时代背景特征：知识经济时代的非理性、不确定性特征 (2)传统模式弊端：科层制组织日益显现的弊端 (3)信息技术发展：为网络型组织提供了直接的技术支持 (4)企业实践基础：发达国家大型企业的组织结构调整 (5)学科理论基础：相关学科的理论发展 单选、简答、辨析 网络型组织的含义 网络型组织是一种基于共同目标或价值取向的合作竞争型的准市场组织，是介于市场和企业之间的一种制度安排。 它以独立个体或群体为结点，以彼此之间复杂多样的经济联接为线路形成互相依赖、动态灵活的分工协作系统，网络型组织中的企业行为由相互之间的关系所决定，本质上是一种价值互补关系。 ★ 多选、简答 网络型组织的特点 (1)网络型组织是企业及社会组织之间的一种制度安排 (2)其形成具有很强的自组织性。 (3)信息技术在网络型组织中至关重要 (4)交互作用的网络关系能够达到价值和能力的互补 (5)网络结点及其联结方式具有多样性和层次性 (6)具有动态开放性、仓创新性和边界模糊性 (7)组织成员具有共同目标 (8)自学习性是其生存发展的重要源泉 (9)信任与协调是其运行的基本保障 (10)强调以客户需求为导向 (11)网络型组织是超越了法人实体的多边联系 ★ 网络型组织的构成要素 网络型组织的构成要素应从网络运行的环境、机制和条件，网络的形成发展和演化等方面综合考虑，将网络型组织的构成要素分为 有形要素 和 无形要素。 其中，有形要素包括网络结点信息技术平台、其他有形资源。 无形要素包括网络战略目标、管理运行机制、网络组织文化、其他无形资源。 ★ 简答 网络型组织的治理机制 (1)利益相关者共同参与。利益相关者共同参与是网络有效治理机制的核心。 (2)简单灵活且具动态性和前瞻性。网络型组织必须体现动态性、平等性、复杂性，更多依靠契约或合同来管理，并建立牢固的信任关系积极发展和谐的人际关系，从而建立起一种“软硬结合”的新型协调方式。 (3)网络型组织的治理机制是介于自动调解和强制调解之间。作为介于市场与企业之间的准市场中间边际组织，网络型组织的治理机制也介于二者的自动调节机制与强制调节机制之间，并加之于自身所特有的社会调节机制。 (4)重视隐含契约在网络型组织治理过程中的重要作用。 单选、辨析 隐含契约包含着四个主要因素：限制性进入、共同文化、信任与声誉，它们对网络治理机制具有综合的作用。 简答 网络型政府组织的产生背景及其含义 (1)第三方公共服务领域的发展是网络型政府组织产生的决定性因素 (2)协同政府的出现为政府网络化组织模式的发展提供了内在驱动力 (3)数字化革命的到来为网络化行政组织模式提供了技术支持 (4)公民选择的多元化与个性化是网络化政府组织模式产生的外部需求 单选、辨析 网络型政府组织是指一种借助数字化技术手段，公共服务体现公民选择权和自主权，具有高公私合作和高网络管理能力的组织模式。 单选、多选、辨析 网络型政府组织的类型可以按照以下两种标准进行分类：政府的参与程度 和 集成者由谁担任。 其中，按政府参与程度从高到低可分为 服务合同式、供应链式、专门类型式、头渠道性伙伴关系式、联结交换台式、信息传播式。 ★ 按集成者由谁担任可分为政府作为 集成者的网络型组织、网络内部组织成员作为集成者的网络型组织、第三方组织作为集成者的网络型组织。 网络型政府组织的优势：(1)专门性(2)创新性(3)迅捷性与灵活性(4)扩大的影响力 简答、论述 网络型政府组织的挑战 (1)达成一致目标的挑战 (2)提供适度监督的挑战 (3)防止沟通失败的挑战 (4)进行充分协调的挑战 (5)克服数据不起的挑战 (6)提升政府管理能力的挑战 (7)维持稳定性与灵活性的挑战 简答、论述 构建网络型政府组织的措施。 (1)确定使命与战略。在启动一个网络型组织模式之前，最根本的是确定其使命和战略。 (2)启动战略。政府官员在启动战略的时候,可以采用的包括资金、召集能力、人力和技术资源以及政府权威在内的资源。 (3)选择参与者。为网络选择网络参与者即合作伙伴的时候，要严格根据特定的标准来评估其价值观和文化兼容性、经营能力和声誉以及亲近顾客的能力等。 (4)确定正确的组织模式。无论选择怎样的政府参与程度，也不管集成者是谁,政府都必须在网络型组织中保持积极的参与以及保留一定的监督职责。 六、行政组织目标 行政组织目标概述 外部目标是行政组织的宗旨和合法性所在，内部目标则是实现外部目标的依托。组织目标是判断组织活动合法性的依据，是衡量组织效果与效率的准则。 行政组织目标的特征有 强制性、服务性、和谐性、复杂性、动态性。行政组织目标的作用体现为 导向作用、激励作用、整合作用、管理工具作用。 ★ 行政组织目标的含义 行政组织 目标 是指行政组织为了实现特定的 未来状态 而设定的一种可以 激励 组织及其成员投入特定资源，并且可以用作 组织管理工具 的公共导向。 行政组织目标的结构和类型 战略目标 具有很强的未来指向性且激励作用明显。积极目标是一种具有较强的发展性和激励性的目标。 行政组织目标的 结构 可分为 纵向目标与横向目标、外部目标与内部目标、战略目标与战术目标。 行政组织目标的 类型 有消极目标、积极目标、经济目标、文化目标和社会目标。 行政组织的外部目标与内部目标 ★ 行政组织的外部目标 (1)维护社会公平。 行政组织追求的社会公平目标应该是终极价值和工具性价值的统一。行政组织的使命就是提供和维护有利于公平的生产行为激励机制和社会正义供给制度。 (2)提高社会生产效率。 行政组织应致力于协调和平衡对社会公平和社会生产效率的追求，通过特定的制度安排实现两者的和谐共处行政组织提高社会生产率的机制要包括：制定产业政策，调控投资规模和速度，协调区域发展，改革人事管理体制 等等。 (3)回应社会公众的要求。 能否及时、有效地回应社会公众的需求是判断一个组织运转情况是否良好的主要标准。首先，行政组织应当把回应社会公众作为一种理念坚持下来：其次，行政组织应当把回应社会公众要求的目标纳人工作议程中去，把任务在组织成员中间进行分解，使组织成员能够根据自己的工作职责自主地回应社会公众的要求；最后，行政组织还要建立、完善和实施考核机制，系统、双向、开放地考察其回应效果。 (4)提供公共服务。提供公务服务是行政组织的安身立命之所在，这是它区别于其他组织的显著特征。德国著名经济学家瓦格纳提出了政府职能将随着社会经济的发展而不断丰富，从而导致公共支出随着国民产出的增长而不断增长的判断，即著名的“瓦格纳定律”。 ★ 行政组织的内部目标 (1)管理资源。 在新公共管理理论指导下，行政组织的资源被赋予了和私人组织的资源相同的管理使命，即提高资源使用效率，节省管理成本，实现效率最大化，主要途径是实现严格的绩效管理、内部市场化、授权与分权，以及引进竞争机制。 (2)绩效管理。 行政组织不仅追求效率、效能和效益，它还要追求公平性、回应性、参与性和公共性。绩效管理的主体一般指行政组织的领导层、上级组织和社会公众。绩效管理的原则主要是：效率与公平并重，效率与民主兼顾，经济增长与社会发展同步。 (3)机关管理。 主要内容有：安全保卫、文秘通信、机关后勤、财务与资产、对外交往、办公设备、机关成员的福利与医疗保健等方面的事务。 机关管理的主要原则是：服务、高效、廉洁、科学化、制度化。 (4)组织发展。 组织发展是政府部门提高活力和办事效能，更好地满足社会公众的公共服务要求的一种主要途径，体现了政府管理的进步和行政组织的生命力。推动组织发展的策略包括：精心设计，全面发动与有效动员精心组织。 行政组织目标管理 ★ 目标管理的含义 目标管理是一项围绕组织目标开展的系统管理活动，它的目的在于提高实现组织及其成员个人目标的效率，它采取的主要管理方式包括目标制定过程中的共同参与、目标执行过程中的责任与控制。 ★ 企业组织与行政组织目标管理的差异 由于 所有权 上的根本不同，企业组织一向坚持效率和利润导向，而行政组织由于承担着政治责任，要兼顾政治多元性和回应性，加之行政组织的目标具有模糊性，因而通常表现为效率低下，进取心不足。 随着实施目标管理的呼声日益高涨，源自企业组织的目标管理被大量引入行政组织中。 目标执行的前提条件及其具体开展实施 (1)目标执行的前提条件： 组织及其成员的自我控制能力强； 组织认同感强； 组织目标得到组织领导的重视 目标明确。 (2)具体开展目标执行 目标与人力配置。包括目标分解和人力配置。 目标与组织资源配置。包括分析目标的资源要求和配置组织资源。 组织协调与监管。两种原因可能会造成协调与监管困难，即目标认同冲突和组织。 目标修正。修正组织目标的主要程序是发现问题和修正目标。 ★ 目标管理的效果分析 优点：(1)奖励作用明显；(2)管理成本低；(3)资源配置效率高；(4)有利于组织发展。 不足：(1)容易偏重于短期目标(2)设置目标存在困难；(3)管理权变性差；(4)容易导致管理缝隙。 七、行政组织机构 行政组织结构概述 行政组织结构的含义 单选 行政组织结构是行政组织各要素排列组合的方式它是各要素的分工合作关系。 单选 人是行政组织中最基本的物质要素 多选 人、目标、权责三者的最初结合，就是职位。 多选、论述 人、目标、权责三者的最初结合，就是职位。 职位，就是根据工作目标的需要，具有一定权力和相应责任的工作岗位，它由行政组织的个体成员充任。职位是构成行政组织结构的基本要素，行政组织的整体框架，皆由行政组织的各种职位排列组合而成，由它组合形成一个单位、部门、层级、整个国家行政系统这四个层次的行政组织结构。 现将其如何具体排列组合为四个层次，分述如下： 第一个层次是由行政组织的基本要素和细胞，即职位——工作人员的排列组合，形成一个行政工作单位。职位就包含了这个工作人员的工作目标、责任、权力，及其在工作单位中所处的地位作用和关系。 工作职位排列组合的有机性，主要要求职位的工作性质相同、程序相关，便于完成该工作单位的总体目标。 第二个层次是由各个工作单位的有机排列组合形成一个工作部门。其排列组合的根据是各单位的目标、责任、权力及其在分工中的地位关系，并以这种组合形成一个部门。工作单位排列组合的有机性，也要体现在每个工作单位的工作性质相同、程序相关，便于完成该部门的总体目标。 第三个层次是由各个行政部门之间的有机排列组合构成一级政府组织。其排列组合的根据是各个工作部门的目标、责任、权力及其在分工中的地位关系，并以此而形成一级政府。各个部门排列组合的有机性，主要体现在各个部门的目标是否与社会的各种需求一致，社会对政府的各种要求能否从各个部门中得到满足。 第四个层次是由各级政府之间的有机排列组合形成一个国家的政府系统。它是各级政府的目标、责任、权力及其在分工中的地位关系的排列组合，并以此综合而成一个国家政府系统的目标和它在整个社会中的地位关系。 行政组织结构中这四个层次的要素排列组合是紧密相连的。它们之间的排列组合，既是相互联系、相互依存的，又是有严密的逻辑顺序、不可颠倒的。其中以职位排列为基础，以形成一个国家的整体行政组织系统为目的。 行政组织结构的功能 单选 良好的行政组织结构 是完成行政组织目标、提高行政效率的物质基础。 良好的行政组织结构应以职能为中心。 ★ 行政组织结构的功能 (1)合理的组织结构能有效地满足行政组织目标的需要。 (2)合理的组织结构有利于稳定工作人员的情绪，调动工作人员的积极性。 (3)合理的组织结构能使组织保持良好的沟通关系。 (4)合理的组织结构是提高微观和宏观行政效率的前提条件。 (5)合理的组织结构有助于推动行政方式的创新。 合理的组织结构应具备的条件有 (1)任务与组织平衡； (2)各个组织、人员之间按比例配置； (3)分工明确，合作良好； (4)适应环境，具有弹性 多选 影响行政组织结构的因素有：组织战略、组织规模、组织所利用的技术等。 战略结构 (一)战略与结构组织结构是行政组织实现其目标的手段，由于组织目标取决于组织的战略,因此，组织的结构往往围绕组织战略来设计。简单易行的组织战略往往导致组织结构比较松散、简单和程度较低的正规化，复杂多变的组织战略往往导致组织结构的复杂化和程度较高的正规化，创新性的组织战略往往导致较少的组织层级和较高的组织结构弹性。 规模与结构 (二)在其他条件不变的情况下，组织规模的扩大往往导致组织结构正规化程度的提高、组织横向幅度更为宽广和纵向层级的增加。规模的扩大往往给组织领导带来更多的内部管理和外部任务压力，因此，组织往往借助于增加组织幅度或层级来应付这些任务和要求。规模较小的组织由于较小的内部管理和外部组织任务压力，往往追求扁平化的组织结构。 技术任务与结构 (三)行政组织的存在是为了解决行政问题，将行政投入转化为行政产出。因此行政组织所使用的技术和所要解决的问题对行政组织结构有着重要的影响。可以从行政组织在运行过程中遇到的例外情况的数量和行政组织为解决例外问题而探索有效方法的过程这两个因素对行政组织结构进行分析。 行政组织的纵向结构 [辨析]行政组织的宏观纵向分工反映不同层级政府之间的分工。 政府为了有效地发挥行政组织的功能，首先要将国家所辖地域分成许多块，由不同的行政组织进行管理(在联邦制国家，是先有联邦成员单位再有联邦政府)。这就是行政组织的纵向分工，即以层级制为基础的垂直分工。为此，除了设置管理全国社会事务的中央行政组织外，还设有管理局部地区的地方行政组织。 宏观纵向分工的特点：行政组织的层级越高，管辖地域的范围越广，其数量越少。 当今世界比较大的国家，其行政组织纵向结构一般是四级。如各国最高行政组织，即中央行政机关，只能有一个。层级越低，管辖地域的范围越窄，但组织的数量越多。如我国最基层的政府是乡政府，其数量就以数万计。所以，宏观的垂直分工是以管辖地域的大小为分工的内容。 一国行政组织的宏观纵向分工并非一成不变，而是随着经济社会条件的变化而演进。在我国，唐朝与清朝的宏观纵向组织层次就不同；中华人民共和国成立后，政府层次数量也经历过几次调整。为此，我们需要总结行政组织宏观纵向分工的影响因素。 ★ 【多选】 影响行政组织宏观纵向分工的因素：(1)政体；(2)国家发展战略；(3)外部性 1．政体。一般而言，实行中央集权制的国家，由于给予地方政府的自主权较少，中央政府需要处理的行政事务繁多，为了减轻中央政府的工作压力，往往借助于增加行政组织的层次来分散压力。实行联邦制或邦联制的国家，由于权力下放，地方政府的自主权较大，行政事务的处理压力对于中央政府而言较小，因此政府间层次数量较少。如实行中央集权的法国就比实行联邦制的美国的政府间层次多。 2.国家发展战略。在国家政体既定的情况下，国家的发展战略对行政组织宏观纵向分工发挥着重要影响。当国家需要集中人力、物力应付重大问题时，中央集权的理念往往占据上风，宏观纵向分工往往倾向于减少组织层次，以提高行政效率。反之，则相反。 3.外部性。政府是提供公共物品和克服外部性的制度设计，政府通过税收一支出机制筹集公共资金用于提供公共物品，矫正外部性。事实上，公共物品的外部性具有差异性，这种差异性体现为外部性的强弱和需求差异的大小。因此，应当根据公共物品的外部性强弱和需求差异的大小设置不同级别的行政组织。 外交、国防、社会保障等外部性强、需求差异小的物品与服务应当由 中央政府 负责提供，高等教育、高速公路等外部性较强、需求差异大的物品与服务应当由 地方政府 负责提供，而公安、基础教育、环境保护等外部性弱、需求差异大的物品与服务应当由 基层政府 提供。 行政组织的微观纵向分工 [单选]微观纵向分工的特点：它们之间的分工关系以 职能的隶属关系 为准 行政组织的微观纵向分工是指各级政府或各个部门 内部层级 的分工。 微观纵向分工的原因是：各级政府或各个部门承担本辖区范围内或本部门的行政任务，为完成任务，达到目标，就必须将任务层层分解，直至落实到每一个职位。 随着公共行政改革的深入，行政组织微观纵向分工出现了新的趋势，有代表性的分工模式包括顾客导向、组织扁平化等。新的分工强调分权、责任统一和目标导向原则，组织内部的纵向结构表现为重视战略决策和具体执行，将组织的精力和资源向战略分析与决策以及一线的具体执行人员倾斜,从而出现了两头大、中间小的新形态。 行政组织纵向分工的职责分配关系 多选、辨析 行政组织纵向分工的职责分配关系是： (1)最高层次的行政组织为决策层； (2)中层行政组织为协调指挥层； (3)基层行政组织为技术操作层。 (1)最高层次的行政组织为决策层，负责制定本部门行政的总目标、总方针、总政策和总的实施方案,负责本机关人、财、物总的分配及其政策,以尽最大努力满足社会对本部门的需要,最优地完成本部门的工作目标。因此,最高层次的行政组织,是一个开放的、面向社会的行政组织。 (2)中层行政组织为价调指挥层，负责执行本部门最高行政组织制定的总决策、目标、方针和政策,以此为依据结合本单位具体工作对象的实际,制定本单位的具体工作目标、工作方案,并负责组织、协调、指挥等实施工作。因此,中层行政组织为半封闭半开放系统,既要使本层级行政组织与上级行政组织保持一致,又要满足本单位工作对象的具体要求。 (3)基层行政组织为技术操作层，其任务是执行中层行政组织的实施方案，在中层行政组织的协调、指挥之下，负责具体的带技术操作性的工作。其组织基本为封闭型，采用什么技术方法执行任务，纯属行政组织内部问题。 ★ 论述 行政组织结构的优缺点。 优点： (1)分层负责，使各级政府在各自管辖地域范围内，能做到事权集中，统一指挥； (2)行动迅速，决策及时，有利于就地监督控制； (3)能发挥各层级行政组织的积极性、创造性，根据本地实际情况开展工作； (4)各层级行政首长负责全面管理工作；有于培养全面的行政管理人才。 缺点： (1)各层级行政首长管辖事务过多，责重事繁，难于事事精通； (2)容易形成地方的块块分割，不利于各地经济和文化的交流与发展； (3)容易犯地方主义的错误，不利于中央对地方的宏观控制； (4)容易导致信息传递失真，难以直接有效地实现组织目标，降低行政组织的反应速度，无法体现结果导向。 行政组织的横向结构 【单选、论述】行政组织的横向分工是行政组织的部门间分工。 现代行政管理的特征是在高度分工的同时又高度综合。任何一个国家的行政组织为完成各种行政任务，在纵向分工构成层级化的基础上，必须进一步进行科学的横向分工，以适应分门别类地处理不同行政事务即不同职能的需要。这种横向分工构成了行政组织的 横向结构，即行政组织的 部门化。 【单选、论述】 行政组织的横向分工是行政组织的部门间分工。 横向分工有宏观分工与微观分工之分。宏观的横向分工是指一级政府内的部门分工，微观的横向分工是指一个部门内部的各个机构和职位的划分，它形成组织的机构系列和职位系列。 在不同层级的行政组织中均有部门划分，如中央政府有部、委、办，省政府有厅、局、委、办，在每个厅、局、委内又有各个处、室，而在各个处、室内又有各个职位的划分。 ★ 行政组织横向分工的必要性 (1)适应各项社会事务管理的需要。 (2)适应行政管理专业化、技术化的需要。 (3)适应行政管理综合协调、宏观管理的需要。 (4)适应行政管理程序的需要。 【简答、论述】行政组织横向分工的种类 (1)按业务性质分工，如中央政府划分出财政部、外交部等 (2)按管理程序分工，划分出咨询、决策、执行、信息、监督等部门 (3)按管理对象分工，如政府经济行业主管部门的设置 (4)按地区分工，如以行政区划为基础设置地区行政组织。 （1）按行政业务性质进行分部化的方式,有其优缺点。 其优点是：1.符合行政分工专业化的原则。每个部门只负责某一项业务工作,有利于行政人员熟悉本专业工作,提高行政效率。2.有利于统一行政业务的方针、政策和法规。同一性质的业务由同一单位管理,使行政组织易于统一同一性质的行政业务的方针、政策、法规,避免“政出多门”的混乱状态。 3.体现事权一致的原则,便于协调。同一性质的行政业务由同一单位管理,做到事权归一,行政工作更易于协调,使本部门能对现有设备、器材、人力作更经济有效的统一调配。 缺点： 1.如业务事权过于集中,容易形成条条分割。同一性质的业务工作归同-部门管理如忽视部门之间的沟通，就不利于不同业务性质工作之间的合作，协调,不利于行政组织总体目标的实现。 2.如分工过细,易造成部门林立。如对业务性质的分工划分过细，设置部门过多,必然造成部门林立,不利于经济节约的原则,更不利于部门之间的合作、协调。 3.如业务性质不清，易产生组织冲突。有些业务性质混淆不清，不易作出明确的划分因此,难以完全科学地根据业务性质的异同设置行政组织。这就使部门之间的职责难以划清,而职责不清则是产生行政组织冲突的最好土壤 ★ 行政区划是否科学合理,主要取决于以下三个方面的因素： 1.要有利于各地区人民和各民族的安定团结 2.要有利于国家政权的统一和巩固 3.要有利于调动地方政府的积极性,充分发挥地方政府的作用 行政组织横向结构的优缺点 优点： (1)职能不同，分工管理，使行政组织成员能在“专”的基础上精通业务。 (2)从上到下形成“条条”，便于对同一业务进行统一管理。 (3)各部门分工负责，便于各层级行政首长集中精力考虑全局的大问题 缺点： (1)易形成各部门的“条条”分割，不利于部门间的沟通、协调 (2)自上而下的各部门形成的“条条”伸向各个基层，不利于地方层级的行政组织因地制宜地贯彻上级政策。 行政组织的层级制形成管理层次，职能制形成管理幅度，二者之间是反比例关系。 ★ 处理管理层次和管理幅度的关系取决的因素： 1.行政组织纵向层次的高低 2.下属的工作性质及难易程度 3.领导者的领导水平 4.被管理者的素质高低 5.集权、分权与授权程度 6.下级单位所在地的集中程度 7.交通和信息传递状况，技术设备与工作条件等 1.管理幅度与管理层次有关。行政组织的纵向一般可以分为高层、中层和基层三个层次。由于每一层次在行政管理中的地位、职能、管理方式的不同,所管理的幅度也应不同。 1.管理幅度与管理层次有关 高层行政组织处于核心地位,起领导作用,其职能是从事决策、计划、协调、监督等政务工作，用宏观管理的方式，以简驭繁，可有较大的管理幅度； 中层行政组织处于中介地位,起上传下达的作用,其职能是从事组织、指挥、协调、监督等政务和事务工作,既有决策,又有执行,用中观管理方式来协调管理繁杂的任务，其管理幅度应小于高层行政组织; 基层行政组织起执行性作用,其职能是从事大量的、具体的事务性处理工作,是用微观的、技术的管理方式来处理大量繁杂的、具体的行政任务。因此,其管理幅度应小于中层。 2.下属工作性质及难易程度制约着管理幅度与管理层次。 如果所管理的工作有较大的稳定性、常规性、重复性,则领导者的管理幅度可适当加大,层次可减少;如果所管理的工作较复杂、难度大且不稳定,领导者的管理幅度可适当地减少，管理层次则要适当增加 3.领导者的领导水平与能力直接制约着管理幅度 管理幅度的大小与领导者的水平和能力成正比例。如果领导者知识渊博、水平高、能力强,领导者的管理幅度可适当加大;反之,领导者的管理幅度应适当减少。与之相适应,管理层次则相应减少或增加。 4.被管理者的素质高低也制约着管理幅度。 如果被领导者的素质高、工作能力强，能独立胜任工作,无须领导经常督促便能圆满完成任务，领导者管理幅度可适当加大。反之领导者的管理幅度则应适当小些。与之相应,也影响着管理层次的多少。 5.集权分权与授权程度影响着管理幅度与管理层次。 集权型组织的权力主要集中在上级机关，使上级机关的工作量增大，故其管理幅度不能太宽,其层次必然要加多;分权型组织，权力较松散，上级机关集中管大事，具体事务较少，因此管理幅度可较宽，管理层次则可减少。 其次，组织内部是否充分授权，如能充分授权给下级，领导者比较超脱，管理幅度可以加大;反之,不授权或授权不多,均需加大领导的协调、指导、监督等工作量,管理幅度应适当减少。与之相应,则影响管理层次。 6.下级单位所在地的集中程度及交通和信息传递状况影响着管理幅度。 下级机关或人员的工作所在地较集中、交通较方便、信息传递较迅速，领导者可适当加大管理幅度。反之,则可适当减少。 7.技术设备与工作条件也制约着管理幅度与管理层次。行政组织中配备的技术设备越先进、工作条件越好子，领导者的管理幅度可以适当加大。反之则应减少。 上述因素都是确定管理幅度大小与管理层次多少的重要参数。正确处理管理幅度与管理层次二者的关系,应根据各个国家、各个地区、各个部门的具体情况综合确定，总的目标是保持行政管理的有效性。 八、行政组织体制 行政组织体制概述 行政组织结构中的各个层级、各个部门之间的权力分配关系的制度化即行政组织体制。 行政组织体制的地位与作用 (1)行政组织结构是行政组织的载体，而行政组织权力分配关系则是行政组织结构的灵魂和核心，也是整个行政组织运行的动力。 (2)行政组织权力分配关系科学与否，是否与时代需要一致，关系着行政组织阶级能和社会职能完成的好坏、关系到行政组织效率的高低。 ★ 不同行政组织体制的划分标准有： 1.中央与地方行政组织权力分配关系的不同(集权制、分权制与均权制) 2.行政组织中掌握最高决策权的人数多察(首长制、委员会制、混合制) 3.行政组织中同一层级的各个行政部门所隶属领导的不同(完整制与分离制) 4.城市政府行政首长的产生及职权不同(名誉市长制与市经理制) 集权制、分权制与均权制的含义 集权制是中央行政组织对地方行政组织有完全的指挥监督权，基本特征是中央政府高度集权,严格控制全国各地行政事务，地方政府没有或极少有自主权,以法国为典型。 分权制是地方行政组织对本地方行政事务有自主决定权，中央政府组织一般不加干涉，基本特征是地方政府受中央政府的控制较小，在行政业务上具有较大独立性，其地方事务可完全根据地方需要实施管理，以美国为典型。 均权制是中央行政组织与地方行政组织的权力保持平衡，基本特征是折中于中央集权与地方分权二者之间，主要根据事权的性质进行合理的划分，维持中央与地方之间的协调、配合关系。 ★ 【多选、辨析】 集权制的优点 (1)政令统一,统筹全局，防止政出多门。 (2)层级节制,指挥灵便，令行禁止，有利于提高效率。 (3)集中全国的人力、财力、物力用于重点建设，避免人财物分散盲目建设及资源浪费 集权制的缺点 (1)事事听从中央政府安排，必然压抑地方政府的积极性，不利于地方政府因地制宜地处理本地事务。 (2)中央严密控制地方,易导致中央机关专制和个人独裁。 (3)层次繁多,事事层层汇报,易费时误事,不能及时、果断地处理行政事务。 (4)下级对上级唯命是从,过分依赖,不利于下级人员工作责任心及工作能力的培养。 (5)无法有效满足地方对公共物品和服务的差异性需求,妨碍了地方政府行政方式的创新。 集权制的优点是政令统一，层级节制，集中全国力量用于重点建设；分权制的缺点是易形成地方本位主义、加剧地区间不平衡，中央统一的政策、法律难以有效贯彻；均权制的优点是发挥集权制与分权制之长,而避二者之短。 分权制的优缺点 1.分权制的优点： (1)地方政府能够因地制宜、灵活机动地处理本地事务。 (2)分权分工,可防止上级专断与个人独裁 (3)分级治事,符合民主原则,可发挥下级人员的主动性，激发其责任心,培养其独立工作能力 (4)可以有效满足地方对公共物品和服务的差异性需求 (5)有利于发挥地方国家权力机关对地方政府的监督作用，培育公民的参与精神,完美对地方政府的监督机制。 2.分权制的缺点： (1)地方分权过度,易形成地方本位主义,甚至导致国家分裂 (2)分权过度,必导致全国各地经济的畸形发展,加剧地区间的不平衡 (3)地方权限过大,上有政策下有对策，中央统一的政策、法律难以有效贯彻。 均权制的优缺点 1.均权制的优点:可扬集权制和分权制之长,而避二者之短。既可保证中央的政令统一与指挥灵便，又可因地制宜，充分发挥地方或下级的积极性、主动性。 2.均权制的缺点:若均权不当,则会扬集权制和分权制之短,而避二者之长。既不利于中央的统一指挥,也不利于地方积极性的发挥。 【简答】集权制、分权制与均权制的正确运用。 (1)集权制、分权制、均权制的正确运用,实际上是正确划分中央政府与地方政府权力分配关系问题 (2)影响中央与地方分权关系的主要是两大因素：是社会的需要,其中主要是经济体制的需要。这是决定任何一个国家中央与地方分权模式的根本因素。二是一个国家的国家结构形式。凡为联邦制国家，一般均实行分权制;凡实行单一制的国家,多实行集权制。 首长制委员会制与混合制的含义 根据行政组织中掌握最高决策权的人数多寡，行政组织体制可分为首长制委员会制与混合制。 (1)首长制,行政组织的法定最高决策权由行政首长一人执掌，以美国总统制为典型。 (2)委员会制,行政组织的法定最高决策权由两个以上人员组成的集体或委员会执掌,以瑞典为典型 (3)混合制,行政组织的事权一部分由委员会集体讨论决定，另一部分由行政首长个人决定。 首长制，又称一长制或独任制，是指行政组织的法定最高决策权由行政首长一人执掌的行政组织体制。其基本特征是行政首长对行政机关各种事务拥有最终决定权，一人决定一切行政事务，其他领导成员均为行政首长的助手或幕僚，协助行政首长行使职权,只有建议权,而无决定权。美国的总统制是首长制的典型。 委员会制，又称合议制，是指行政组织的法定最高决策权由两个以上人员组成的集体或委员会所执掌的一种行政组织体制。其基本特征是行政组织的决策是由两个以上的地位平的委员所负责，行政组织的最高决策权属于全体委员，一切行政措施均由委员会按照“少数服从多数”的原则集体讨论决定。（瑞士是实行委员会制的典型国家。） 混合制,又称委员会和首长并立制，是指行政组织的事权一部分由委员会集体讨论决，另一部分由行政首长个人决定的一种行政组织体制。其基本特征是行政组织中既设有合议制的委员会,又设有专门的行政首长，重大问题的决策权由委员会集体讨论行使，具体问题的决策权由行政首长个人行使。 首长制的优点：事权集中，权责统一、易于保密； 委员会制的优点：集思广益、协调一致、互相监督； 混合制的缺点：若运用不当，会兼有首长制与委员会制之弊，即个人专断、以权谋私，权责不清、争功诿过。 完整制与分离制的含义 (1)完整制，是指同一层级地方政府的各个行政部门均受同一行政组织首脑机关领导的一种行政组织体制。其基本特征是指挥、控制权集中于本层级的行政组织,本层级地方政府的首脑机关对该层级的所有工作部门实行一元化领导。 (2)分离制,是指同一层级地方政府的各个行政部门，分属两个以上行政组织领导的行政组织体制。分离制是实行二元领导的组织体制。我国行政组织体制基本上属于分离制,我国很多行政机关均实行“双重领导”或“双重负责”制。 完整制的优缺点 1.完整制的优点： (1)在同一级政府内权责集中,指挥统一,可令行禁止,防止迟缓推。 (2)在同一级政府的统一领导下,各部门相互合作、协调配合,可减少单位间的摩擦与冲突,并避免单位间的工作重复 2.完整制的缺点 (1)权力过分集中于地方政府,易形成一级行政首长的个人专权 (2)易形成地方本位主义,不利于上级方针政策的贯彻落实,不利于中央政府对全国的宏观控制。 分离制的优缺点 1.分离制的优点： (1)领导权力分散,并互相牵制,可防止一级行政首长的独裁专断 (2)实行二元化领导,既有利于上级方针政策的有效贯彻,也有利于下级政府因地制宜地加以实施 2.分离制的缺点 (1)权力分散,易导致多头指挥、政令冲突,使得任何一个领导机关均指挥不灵。 (2)政出多门,易导致下级无所适从,或利用矛盾为已所用。 在当今市场经济条件下，完整制与分离制的正确运用 (1)完整制与分离制各有利弊,主要应根据国家结构形式——单一制或联邦制的不同而不同。一般而言,在当今市场经济条件下,实行单一制与分权制国家的高级地方政府主要适宜采用完整制。 (2)自我国开始由计划经济体制转向社会主义市场经济体制的改革以后，在中央政府与地方政府之间逐渐实行了按事务的宏观、微观性质进行分工,凡属纯地方性的微观事务，就只属地方政府领导，无须向中央政府一一请示,因此对这些部门可实行完整制领导：而那些纯属宏观调控性的事务，则应由中央政府管理,地方政府不得染指，不存在对这些事务的双重领导问题。 (3)只有需中央与地方共同管理的事务部门，才实行分离制,既归本级政府首脑机关领导，又归中央政府同类部门领导至于地方政府之间的部门领导体制问题，按此理类推，视不同情况分别采取分离制或完整制。唯此才能适应市场经济的需要，从而也才有利于提高行政效率。 名誉市长制与市经理制的含义 (1)名誉市长制，又称委员会制,是指城市政府仅设立一个名誉市长，行政及立法实权皆由民选的市议会或民选的委员会所执掌的行政组织体制。其基本特征是否定“权力分立”，实现“立法与行政的统一&quot;。 (2)市经理制，又称委员会经理制，是指城市的立法权由民选的市委员会或市议会所掌握，再由市委员会或议会聘任一名市经理执掌行政权的行政组织体制。该体制产生于美国。 市经理制的优点 (1)有一个统一而高度负责的行政首长,便于统指挥,提高行政工作效率 (2)行政首长由市政专家担任,有利于提高城市管理的科学化水平 (3)市经理对民选的市委员会负责，市委员会对选民负责，使得专家的特长与选民的意志得以较好的结合。 名誉市长制的优点是可有效避免行政与立法机构之间对立与冲突，缺点是各行政部门之间的工作难以协调，行政失去了立法的控制与监督，难以保证议员的能力和专长适宜其所从事的行政工作。 行政组织按行政职权的大小可分为 统率机关与被统率机关。 被统率机关按业务性质可分为业务机关(又分综合管理机关与专门管理机关)与辅助机关; 统率机关的性质和职责 (1)性质:统率机关即行政首脑机关,是指具有决策、组织、指挥、协调、控制与监督等权力的机关。统率机关是各级行政机关的指挥与决策中心在整个行政机关中发挥统率作用。行政首长是统率机关的代表。 (2)职责：1.计划决策;2.组织指挥;3选人用人;4.编制财务预算；5.负有相应的行政责任；6.积极开展对外联系 被统率机关的性质和职责 (1)性质：被统率机关是指在行政首长的统一领导下，具体执行统率机关所制定的决策及命令的机关。被统率机关具有执行性与辅助性的特点。 (2)职责：忠实地贯彻执行行政首脑机关的决策与命令，圆满地完成行政首长所交办的各项任务。 以行政业务性质分类 【辨析】 业务机关是与社会民众发生直接关系的组织辅助机关，是间接为实现整个行政组织目标服务的机关,其服务对象是 行政机关自身。 (一)业务机关 1.业务机关的性质。业务机关,指活动内容就是实现整个行政组织的目标、任务的机关，它直接履行政府的政治、经济、文化、教育、卫生、科技、社会服务职能，是与社会民众发生直接关系的组织。 2.业务机关的职责。业务机关在同级政府或上级同类部门的领导下,专门负责领导和管理某一方面的行政事务。其具体职责主要有如下几项：计划、法制建设、执行、考核、报告。 (二)辅助机关 1.辅助机关的性质。辅助机关是指活动内容直接为行政首长和业务机关服务、间接为实现整个行政组织目标服务的机关。如各级人民政府办公厅(室)、法制办、信息中心、政策研究室、人事局、统计局、机关事务管理局等,其服务对象不是社会民众，而是行政机关自身。 2.辅助机关的职责。协助行政首长处理日常事务;深人实际,收集研究信息;上传下达,综合协调;管理本机关的人、财、物。 3.辅助机关的分类。辅助机关是在行政首长直接领导下的服务机关，根据服务对象的不同,又可分为两大类 (1)为行政首长服务的办公及参谋机关 (2)为业务机关自身工作和生活服务的机关。 行政组织按 行政活动程序 可分为 决策机关、执行机关、咨询机关、信息机关与监察机关。 其他划分标准,如行政层级(中央与地方行政机关)、设置的时间(常设机关与临时机关)、行政组织特殊性(派出机关、分支机关、合署办公机关)。 (一)决策机关 决策机关是指在行政活动中作出决定、制定规划、发布命令的机关如国务院、地方各级人民政府等。决策机关是行政机关体系的统帅,其职权同前述统率机关的职权基本相似。 一个行政组织只能有一个决策中心，决策不能多头。否则，就会政出多门,使下属人员无所适从。决策权力集中,容易明确决策责任,有利于降低决策成本、提高决策效率和增强政策方案的协调性。 (二)执行机关 执行机关是指对决策机关作出的指示、命令、决议等加以贯彻和实施的机关。执行机关一个相对概念，如国务院各部、委对国务院,地方各级人民政府的各个工作部门对地方各级人民政府首脑机关,都是执行机关 咨询机关的含义和主要任务 (1)咨询机关是指为决策机关提供意见和建议的机关，通常由专家、学者、政府组织的代表、民众代表组成,以保证决策的科学性、民主性。 (2)咨询机关的主要任务是在广泛调查研究的基础上，对政治、经济、文化、社会等各个领域的问题进行预测、分析与论证，为行政首长决策提供建议或方案，或对需要由首长进行决策的问题进行审议。咨询机关是决策中心的辅助机关，必须从法律上确保其具有建议权和审议权。 (四)信息机关 信息机关是指专门负责收集、加工、储存与传递有关人、财、物等各方面信息的机关，如统计局等。信息是一种宝贵的资源，现代决策离不开信息；信息的可靠性与及时性，往往直接影响到决策的正确与否。 因此,信息机关在现代行政机关体系中占有相当重要的地位。以前,我们对这类机关重视不够，今后应进一步加强信息机关的建设，逐步建立适合我国国情的完善的信息系统。由于信息机关是一个技术性很强的组织，故必须配备训练有素的专门人才。 (五)监察机关 监察机关分为两种一是负责对整个行政机关、行政工作人员以及由国家行政机关任命的其他人员(主要指国有企业、事业单位的领导干部)进行监督、检查的机关; 二是负责对社会组织、企事业单位和公民遵守国家法律、执行首脑机关发布的决议与命令的情况进行监督、检查的机关。前者如国家监察委员会后者如市场监督管理局等。 (一)以行政层级分类 以行政层级为标准分类，行政组织可分为中央行政机关与地方行政机关。 1.中央行政机关。 (1)中央行政机关的性质。中央行政机关是指活动范围涉及全国的行政机关,如我国的国务院、朝鲜的政务院、美国的总统等。中央行政机关是一个国家的最高行政机关，全国各级地方行政机关均受其统一领导。 (2)中央行政机关的职权。中央行政机关代表整个国家行使国家行政权力,执行全国性公务。它有权依据宪法与法律，管理全国范围内的一切政治、经济、文化和社会事务。 2.地方行政机关。 (1)地方行政机关的性质。地方行政机关是指活动范围仅涉及-定行政地域范围的行政机关,如我国地方各级人民政府、日本的各级地方自治体等。 (2)地方行政机关的职权。地方行政机关负责管理特定行政区域内的政治、经济、文化与社会事务。我国地方行政机关是地方各级人民政府，它们根据“双重负责制”(即既要向同级地方人大负责并报告工作,又要对上级行政机关负责并报告工作)的原则开展工作。 (二)以行政组织设置的时间分类 以设置的时间为标准分类，行政组织可分为常设机关与临时机关。常设机关即永久性行政机关，是管理经常性行政事务的机关。国务院各部、委及地方各级人民政府的厅、委、局均属于常设的职能机关。 临时机关是为解决某一临时性专门问题而设置的机关。些且问题被解决或任务已完成，该类机关随即撤销。需要注意的是，统率性行政机关要加强对临时机关的内部统一管理和综合协调，对临时机关组成人员进行周密的考核和监督，防止考核和监督的疏漏。最后需要根据任务完成的情况逐步缩减临时机关，从人员和经费上为撤销临时机关做好准备，防止机关数量膨胀。 (三)以行政组织的特殊性分类。 以行政组织的特殊性为标准分类，行政组织中绝大多数均为普遍性的机关，但也有二些特殊性质的机关,如派出机关、分支机关与合署办公机关。 1.派出机关，是指上级人民政府根据工作需要，在其所辖区域内设立的代表机关。如我国的地区行政公署是省政府的派出机关，街道办事处是市辖区政府或不设区的市政府的派出机关。派出机关并非一级地方政权，也无一级独立财政。 2.分支机关,是指中央机关设在各地的分支机构。如中国人民银行分设于各地的跨省区分行，财政部和审计署分布于全国的驻XX省特派员办事处。 3.合署办公机关,是指两个或两个以上机关,因工作性质较接近、联系较紧密所组成的联合机构。如&quot;中共中央军事委员会”&quot;中华人民共和国军事委员会”，“xx省民族事务委员会”“xx省宗教事务局”则属于合署办公机关,俗称“两块牌子、一套班子”。 【简答】临时机关的作用与撤销 临时机关是为解决某一临时性专门问题而设置的机关。统率性行政机关要加强对临时机关的内部统一管理和综合协调，需要根据任务完成的情况逐步缩减临时机关，从人员和经费上为撤销临时机关做好准备，防止机关数量膨胀。 九、行政组织的设置与自身管理 行政组织设置的指导思想和原则 行政组织设置的指导思想 行政组织设置的原则 是指人们在设置或改进某一行政组织时，所要遵循的一般准则或指导规范。它是人们对组织规律的科学总结，反映了组织设置和组织运行的基本要求。 行政组织设置的原则，应遵循以下指导思想: (1)主观性与客观性的对立统一; 行政组织设置原则应该是主观性与客观性的对立统一，它要求我们注意各流派的行政组织设置原则既有主观偏见，又包含有对组织规律的认识，因而，要批判性地运用它们来指导实践，并在实践中检验其真伪。 (2)科学性与政治性的对立统一; 行政组织设置的原则应反映行政组织发展中的某些普遍、共同规律,因而具有科学性：行政组织设置的原则又必须反映特定社会中统治阶级的根本利益，因而具有政治性。 在阶级社会里,行政组织设置原则的科学性与政治性既对立又统一。因此,我们必须注意：第一,自觉地把人民大众的根本利益放在首位，将其作为我国行政组织设置原则的基础;第二,充分认识各流派行政组织原则中的阶级局限性，认真学习与借鉴其中的科学性成分。 (3)稳定性与变动性的对立统一。 行政组织设置的原则，作为一种指导性的规范，具有一般的、普遍的性质，它反映了行政组织设置的一般规律，凡是环境与性质相同或相近的行政组织都可运用这些相同或相近的组织原则。 但是,行政组织的环境又是复杂、具体、多变的,在不同环境下的同一性质的行政组织、相同环境下的不同的行政组织子系统，都不可能适用完全一样的组织原则。 因此,我们既要提出一般的行政组织设置原则，又要根据组织环境的发展变化与组织系统的具体特点，相应地选择和运用不同的具体组织原则;既要反对借口遵循传统而不肯改革旧的组织原则的做法，也要反对借口学习外国经验而照搬、照抄西方组织原则的行为。 不同时期的行政组织设置的一般原则 传统理论时期的行政组织设置原则 (1)组织目标的原则 (2)指挥统一的原则 (3)层级节制与幅度适中的原则 (4)权责相称的原则 (5)授权的原则。 (6)专业分工的原则。 (7)精简节约的原则。 行为科学时期的行政组织设置原则 (1)以人为本的原则。人是行政组织的核心，是其中最活跃的因素。任何组织设计与管理都要着眼于最大限度地满足人的多方面需求，促进其全面发展与优化。 (2)人与组织平衡的原则。行政组织对组织成员的要求以及组织成员对组织的贡献，应与行政组织对人的满足程度基本平衡。 (3)参与、沟通、激励的原则。人是经济人，但更是社会人。行政组织的活力来源于组织成员的全心投入，来源于他们对组织目标的认同感。行政组织要创造各种机制使组织成员介人组织决策与管理的过程，要实现各层级、各部门间的信息传递与交流，达到相互信任与理解；对组织成员的管理方式，激励往往比惩罚更重要。 (4)正式组织与非正式组织互动的原则。在行政组织中，除了法定的正式组织之外，还存在通过友谊、感情等渠道形成的非正式组织。非正式组织既有激发工作热情、缓解紧张情绪等正功能，又有传播谣言、抵制管理等负功能。正式组织与非正式组织处于不停顿的互动之中。行政领导的职责在于引导非正式组织积极的一面，控制其消极的一面。 ★ 系统权变理论时期的行政组织设置原则：(1)系统的原则;(2)整体的原则;(3)开放的原则;(4)封闭回路的原则; (5)权变的原则。 行政组织设置原则的作用 ★ 行政组织设置原则的作用 (1)有助于设计与建立科学、合理的行政组织结构 (2)有助于指导与规范行政组织的日常管理 (3)有助于改革与完善行政组织 ★ 人员、目标、权责关系三者的排列组合方式决定行政组织结构 任何一个行政组织都有基本相同的要素，即人员、目标、权责关系，这三者的排列组合方式决定行政组织结构。 组织结构是否合理、科学，对行政组织功能的大小、好坏会产生重大而直接的影响。人们在行政组织的设置过程中，如果能熟练掌握并科学运用行政组织设置原则中的有关内容，就能在设置新的行政组织的过程中，减少盲目性、主观性，增加自觉性科学性。 中国行政组织设置的原则 ★ 【单选、辨析】为人民服务是我国行政组织设置的基本原则 为人民服务是我国行政组织设置的根本宗旨，要求将为人民谋利益作为组织设置与组织全部活动的出发点和归宿。 各级各类行政组织的建立，目的在于更好地进行创造性的工作，保障国家主权的独立完整，维护安定团结的政治局面，促进政治、经济、文化建设事业的长期、稳定、协调发展，从而不断满足人民群众日益增长的美好生活需要，促进社会全面发展。 职能原则 根据组织职能设立相应的机构，围绕组织职能确立组织结构，根据职能的发展变化适时地调整行政组织。 ★ 【简答】职能原则的内容。 根据组织职能设立相应的机构。 行政组织职能是行政组织所要达到的目标或结果。在我国，任何行政组织的设置都要根据客观实际的需要，都是为了完成一定的组织目标，实现特定的组织职能。一定要因事设位、因事择人，反对因人设位、因位生事。 行政组织职能是行政组织所要达到的目标或结果。只有坚持机构设置与组织职能之间的一致性,才能控制机构的总量,确保机构设置的必要性、严肃性和科学性,才能减少乃至避免内耗，保证行政效率的提高。 围绕组织职能确立组织结构。 要根据组织职能的难易程度来确定组织的规模、大小、繁简在机构的层次划分及部门分工时，要把总职能逐级分解为部门职能和个人职能根据具体职能来设置机构与职位。 只有围绕职能来设计组织结构,才能形成用总职能指导分职能、用分职能支持总职能的良性循环，达到以职能为中心的、既分工又合作的优良组织结构。 根据职能的发展变化适时地调整行政组织。 随着组织目标、组织职能的发展、变化或消亡,我国行政机构的设置也应相应地增加、调整或撤销。在机构设置上、人员编制上,要反对“一劳永逸”的思维,适时的改革与究善应成为组织建设中一项经常性的工作。 ★ 统一原则的内容 (1)机构设置要统一 (2)领导指挥要统一 (3)职责与职权要统一 ★ 系统原则的内容 1.保持整体功能，2.坚持平衡，3.坚持开放，4.管理封闭回路。 ★ 效能原则的内容 1.机构设置和人员编制要尽量精简 2.层级与幅度要适中 3.进行专业化分工 4.简化办事程序 ★ 法制原则的内容 1.政府机构的设置及其体制要有法律上的根据和保障。 这种法律的依据主要体现在《中华人民共和国国务院组织法》和《中华人民共和国地方各级人民代表大会和地方各级人民政府组织法》这两个基本法律文件之中;另外，其他一些具有一定法律效力的各种条例和地方性法规，对于中央政府机构和地方各级政府机构都作了具体的规定。 2015 年，《地方各级人民代表大会和地方各级人民政府组织法》修订通过，为政府机构改革与机构设置工作确立了新的符合社会主义市场经济要求的法律规范和法律保障。 2.机构的设置与变更要依照法定的程序进行。 我国的《国务院组织法》和《地方各级人民代表大会和地方各级人民政府组织法》对政府机构设置的程序均有具体规定，各级人民政府均不得违反，不得擅自增设或减少机构，要坚决杜绝领导者个人决定增设机构的人治现象。 行政组织自身管理的一般方法 行政组织自身管理方法的含义、依据和意义 ★ 行政组织自身管理方法的含义。 行政组织自身管理的方法是指行政组织为保障行政目标的实现，对行政组织自身及其成员进行控制与管理的方法、措施和手段的总和。 行政组织的管理方法，事实上包括两个方面的内容: 一是行政组织对系统内部的自身管理; 二是行政组织对社会的管理。 ★ 确立行政组织自身管理方法的依据 (1)经济上的依据，主要指经济发展的性质与水平。 (2)政治上的依据，主要指政体的影响 (3)理论上的依据，集中于一点，主要指如何看待组织中的人 ★ 研究行政组织自身管理方法的意义 1.行政组织自身管理的方法是行政领导控制与管理行政组织的工具。 2.做好行政组织的自身管理是行政组织有效实施社会事务管理的前提。 规制型管理 规制型管理是一种采用严格的规章制度来约束行政组织成员的行为，以高效完成工作任务的管理方法。 ★ 规制型管理方法的主要内容包括: (1)组织标准化; (2)工作秩序化; (3)管理规范化。 组织标准化的内容包括: (1)分工专业化; (2)工作指标化; (3)人员统一化。 规制型管理的评价: 规制型管理盛行于工业社会，它追求理性和效率；其目的是排除人的情感因素对组织运行的影响，尽可能地消除偶然性，使行政组织成为一种客观系统。这种管理方法力图在无序中建立秩序，适应了工业社会的需要。 但是,其缺陷也是十分明显的： 第一,规制型管理造就了一种刚性的官僚系统,就像一部机器,没有灵活性和主动精神，只有齿轮之间的被动运转； 第二，采用标准化的管理和服务，忽视人的差异性和多样性； 第三,排除了竞争的必要与可能，组织成员照章办事，墨守成规,以致造成得过且过、不负责任的结果； 第四,依靠条块分割的专业化单位来解决不断出现的新老问题，导致机构不断膨胀，职能交叉重叠。 情感型管理 情感型管理是一种在行政组织中有选择性地增加情感投入，满足组织成员的感情和心理需要，以提高组织绩效水平的管理方法。 在组织管理中适当地运用一定的情感因素，不仅可以满足组织成员本身的需要，而且可以大幅度地提高组织的绩效水平。 中国传统的情感管理方法: (1)强调亲亲相爱，组织和睦，组织和睦，即君礼臣忠，亲亲敬长，朋友有信 (2)强调自我修养，克己复礼，克已复礼，认为组织成员要努力具备“仁、恕、恭、谦、宽、直、信、忠”等品质，即要有爱心、宽容、恭敬、谦让、宽厚耿直、信义、忠诚等品质。 当个人利益与组织利益发生矛盾时，则应克制自己，服从群体。 ★ 情感型管理中最基本的方法: (1)激励; (2)沟通; (3)参与; (4)协调 ★ 情感型管理的评价 情感型管理方法是为了弥补规制型管理方法的不足而产生的，它深化了人们对组织的理解和认识推进了行政组织管理的发展与工作效率的提高。 情感型管理不应与规制型管理相对立，它是在规制型管理的基础上发挥作用的。同时，从某种意义上说，规制型管理也重视人的因素。 规制型管理排斥个人的主观好恶，用同样的规则对待所有的人，为组织成员营造了一种公平竞争的环境。这是对人的最大尊重，使所有组织成员都可以充分发挥自身潜力，投人到业绩创造之中。因此，我们必须正确地把握这两种管理方法之间的关系。 市场化管理的含义 市场化管理是与信息社会相适应的新型管理方法，它主张将市场机制引入行政组织的管理之中，即在行政组织内部形成若干自主性较强的工作单元，创造一种竞争性环境，从而激发组织成员的潜能，提高效率。 行政组织内部管理市场化的特点: (1)权责明确; (2)结果导向; (3)合同约束; (4)用户至上。 中国行政组织自身管理的方法 民主集中制 民主集中制的含义主要有: (1)行政组织的自身管理要民主; (2)行政组织的自身管理要在高度民主的基础上应实行高度的集中 重人与重制度相结合 重人与重制度相结合的表现 (1)在行政组织诸要素中，人与制度是两个主要的和基本的方面。 (2)我们强调在行政组织的自身管理中尊重人，理解人、关心人，把人视为组织管理的第一要素，绝不意味着忽视制度因素在组织自身建设当中的作用。 (3)总之，只有相互联系地使用重人与重制度的方法，才能取得良好的结果，才能使行政组织内部出现既有集中又有民主、既有纪律又有自由、既有统一意志又有个人心情舒畅、生动活泼的理想局面。 目标管理 目标管理是指行政领导和一般组织成员共同参加工作目标的制定，并在工作中实行自我控制以努力完成工作目标的方法。 1.目标管理最早由美国人彼得·德鲁克提出 20世纪60年代以后被成功地运用于日本的企业管理，70年代以后由于采用了电子计算机技术，使之更趋全面与成熟。 2.我国在行政管理中运用目标管理方法是 20 世纪 80 年代以后。 ★ 目标管理的意义 在行政组织的自身管理中，坚持民主与集中、重人与重制度相结合的方法，组织目标的顺利实现也就有了现实的保障和坚实的基础。 行政组织目标，作为某一行政组织所欲达到的指标或结果，对行政组织的管理具有重要的意义与作用，主要表现为: (1)它规定行政组织前进的方向; (2)它激励行政组织成员的工作热情； (3)它提供组织与个人工作考核的依据； (4)它增进组织内各部门、各层次、各成员间的协调; (5)它影响行政组织 结构的设计与调整，制约组织中人、财、物的具体配备; (6)它是行政领导对行 政组织及其成员进行计划 (5)它影响行政组织结构的设计与调整，制约组织中人、财、物的具体配备; (6)它是行政领导对行政组织及其成员进行计划协调、指挥与控制的前提和基础。 目标管理的种类 ★ (1)根据目标在时间上的不同行政组织目标可以区分为 长期目标、中期目标与短期目标。 长期目标的有效期一般在5年以上，中期目标的有效期一般在 2-5 年，短期目标的有效期一般在 2 年以下。 (2)根据目标结构上的不同，行政组织目标可以分为 总目标、部门分目标与个人目标。 总目标是行政组织的整体目标，分目标是行政组织中各组成部门的目标； 个人目标则是总目标、分目标指导下的个人预期结果。 (3)根据目标层次上的不同，行政组织目标可以区分为 战略目标与战术目标。 战略目标在宏观上决定了组织的根本性任务，是战术目标的指导；战术目标则是战略目标的细化，它确定组织在某一阶段内的具体任务。 (4)根据目标形式上的不同，行政组织目标还可以区分为 定性目标与定量目标。 一般来讲，越是短期目标、分目标、个人目标与战术目标，其内容越应该量化；反之，其他目标的完全量化则有一定困难，只能表现为不同形式、不同程度上的定性与定量的结合。 ★ 目标管理的方法：制定目标；执行目标；检查成果；反馈 应注意的问题： 1.形成整体、单位和个人三位一体的目标网络，使总目标能够指导控制分目标和个人目标;反过来，使分目标与个人目标又能支持总目标。目标本身要做到尽量明确、具体、标准化。目标的控制手段应与目标本身配套。目标还应具有一定的挑战性 (2)目标制定的过程必须真正贯彻双向沟通、民主协商的精神，要相信一般组织成员的思想觉悟与工作水平。 (3)目标的制定与执行过程中应注意权、责、利相结合。使组织成员不仅享有目标的制定权，同时也享有自我控制权，并意识到自己应担负的行政、法律责任。目前，在中国行政组织的自身管理中，特别要注意将目标管理方法与现实中已被证明是行之有效的岗位责任制结合起来。 十、组织激励 组织激励理论的产生 组织激励的概念界定 组织激励 是组织为了组织目标的实现，结合组织成员人的个性特点和管理情境，运用制度设计、领导、组织沟通等手段，来激励和规范员工行为的一种组织管理活动。 组织激励的出发点是满足组织成员的各种需要。成员的需要有高额的薪酬、优厚的福利、舒适的工作环境、和谐的人际关系等。 组织激励的过程 组织激励是“以人为中心的管理的核心”，是组织根据人的需要，通过设计适当的奖惩制度，创造必要的环境，借助信息沟通来激发、引导、保持与组织目标一致的行为，抑制和规范偏离组织目标的行为的管理过程，是组织在管理过程中的一种职能行为。 员工受激励的水平是组织效率的重要决定因素之一，是企业生存与发展的关键，管理思想的实质是激励，激励是企业管理的核心问题。 员工受激励的水平是组织效率的重要决定因素之一,是企业生存与发展的关键,管理思想的实质是激励,激励是企业管理的核心问题。 组织激励的价值 (1)吸引优秀的人才。 (2)调动员工的积极性。 (3)留住优秀人才。 (4)增强组织的凝聚力 组织激励的五力模型 组织激励的五力模型是指驱动力、推动力、压力、规范力及自我激励。 组织激励的主要思想 内容型激励理论 ★ 研究需求或可满足需求的事物，也称需要理论，主要代表有 马斯洛的需求层次理论、奥尔德弗的 ERG 理论、麦克利兰的成就需要理论、赫茨伯格的激励一保健双因素理论。 ERG 理论与马斯洛需要层次理论的区别 第一，ERG理论表明了多种需要可以同时并存。 第二，马斯洛提出的需要层次是一种刚性的阶梯式上升结构，即认为较低层次的需要必须在较高层次的需要满足之前得到充分的满足，二者具有不可逆性。 第三，ERG理论还提出了一种叫作“挫折一退化”的思想。 20世纪50年代，美国心理学家 麦克利兰 提出人的需要由 权力、友好和成就 三种类型构成。 成就需要指人们追求卓越、实现目标、争取成功的内部驱动力。决定一个人的成就需要的因素有两个:直接环境和个性。 权力需要指影响、控制、指挥别人行为的需要。权力需求是管理成功的基本要素之一，麦克利兰将组织中管理者的权力分为两种：一是个人权力，二是职位性权力。 过程型激励理论 1968年美国行为科学家 洛克 首次提出目标设置理论。目标设置理论认为目标也是激励人行动的主要原因，目标具有导向性，完成目标可以满足人的情绪和愿望，具体的、具有挑战性的目标能激发人的工作热情，具有一定难度和挑战性的目标，一旦被人们所接受，能激发个体的自我效能感，产生较大的激励作用。洛克和莱瑟姆 开发了目标设置与绩效的模型。 期望理论的公式及含义 1964年，弗鲁姆在《工作与激励》一书中提出期望理论。他认为激励性取决于效价和期望，是二者的乘积。效价指完成某项工作可能获得的奖励大小，期望则指评价自身能力可以完成某项工作的可能性。 激励的力量用M表示，个体对工作的效价用V表示，期望值用E表示，其公式如下所示: M=V∗EM=V * E M=V∗E 在对期望值进行分析过程，如下所示 1234E(高) * V(高) = M(高)E(低) * V(高) = M(低)E(高) * V(低) = M(低)E(低) * V(低) = M(高) 这个公式说明:假如一个人把某种目标的价值看得很大，估计能实现的概率也很高，那么这个目标激发动机的力量越强烈。怎样使激发力量达到最高值。弗鲁姆提出了人的期望模式:“个人努力——个人成绩(绩效)——组织奖励(报酬)——个人需要。”在这个期望模式中的四个因素，需要兼顾 三个方面 的关系：努力和绩效的关系；绩效与奖励的关系；奖励和个人需要关系。 公平理论的启示 首先，影响激励效果的不仅有报酬的绝对值，还有报酬的相对值。 其次，激励时应力求公平，使员工投人回报比等式在客观上成立，尽管有主观判断的误差，也不致造成严重的不公平感。 最后，在激励过程中应注意对被激励者公平心理的引导，使其树立正确的公平观，是要认识到绝对的公平是不存在的，二是不要盲目攀比。 行为改造型激励理论 强化理论的行为原则。 第一，经过强化的行为趋向于重复发生。 第二，要依照强化对象的不同采用不同的强化措施。 第三，分阶段设立目标，并对目标予以明确规定和表述。 第四，及时反馈。 第五，正强化比负强化更有效。 ★ 强化包括三种类型：正强化、负强化和自然消退 强化理论的应用 在组织安全管理中，应用强化理论来指导安全工作，对保障安全生产的正常进行可起到积极作用，需注意以下五个方面： 第一，应以正强化方式为主。 第二，采用负强化(尤其是惩罚)手段要慎重。 第三，注意强化的时效性。 第四，因人制宜，采用不同的强化方式。 第五，利用信息反馈增强强化的效果。 影响归因的因素 第一，信息因素。 第二，因果关系信念。 第三，动机因素。 第四，归因偏差。 综合性激励理论 综合激励模型的因素 第一，能力和素质 第二，工作条件 第三，角色感知 F=Vit+Eia∗Via+Eia∗∑(Eej∗Vej)F = V_{it} + E_{ia} * V_{ia} + E_{ia} * \\sum(E_{ej} * V_{ej}) F=Vit​+Eia​∗Via​+Eia​∗∑(Eej​∗Vej​) F为激励力量，ViV_iVi​ 为任务本身所提供的内在报酬的效价。 iii 为内在，ttt 为任务本身 1986年，布朗(RABaron)在《组织中的行为》一书中提出了效价(Value)——手段(Instrument)——期望(Expectancy)理论，简称 VIE 理论。布朗认为激励是人们以下三种信念的结果：一个人努力的结果是绩效(期望)；一个人因有绩效这一个媒介而得到报酬(手段)；一个人得到报酬后，看到报酬的价值(效价)。 综合激励模型的特点 (1)个人是否努力以及努力的程度不仅仅取决于奖励的价值，而且还受到个人觉察出来的努力和受到奖励的概率的影响。 (2)工作的实际绩效取决于能力的大小、努力程度以及对所需完成任务理解的深度。 (3)奖励要以绩效为前提，不是先有奖励后有绩效，而是必须先完成组织任务才能给予精神的、物质的奖励。 (4)奖惩措施是否会产生满意，取决于被激励者认为获得的报酬是否公正。 (5)个人是否满意以及满意的程度将会反馈到其完成下一个任务的努力过程中。 组织激励的特质与功能 组织激励的特质 1.组织激励的层级性。 2.组织激励的互动性。 3.组织激励的多元性。 这些激励方式包括物质激励、晋升激励、荣誉激励、信任激励、目标激励、责任激励、成就激励、情感激励等。 组织激励的现实功能 1.激励能够调动人的热情和积极性 2.激励能激发人的潜能，提高人的能力 3.激励能提高个体的工作绩效，营造良好的组织氛围，增强组织的整体效能 组织激励理论的缺陷 组织激励理论家们多是抽象地研究人的本性和人的行为，并用封闭的观点来研究组织，没有将其与组织条件、外部环境、社会制度或生产关系联系起来。 组织激励理论研究的对象是人，人有思想、有意识、变化多样，差异甚大，从而带来研究结果的可靠性及置信度等问题。 组织激励理论提出的一些命题，如强化理论，只讨论外部因素或环境刺激对 行为的影响，忽略人的内在因素和主观能动性对环境的反作用，具有机械论的色彩等，受到现代组织理论家们的批判。 十一、创建学习型组织 学习型组织理论的产生 学习型组织的源起 ★ 学习型组织产生的原因 (1)时代背景:传统科层制组织模式逐渐不适应时代发展的步伐 (2)物质基础:新技术革命带来了客观环境的巨大飞跃 (3)理论基础:相关学科理论萌生了学习型组织理论的胚芽 (4)管理理念:从“物本”管理到“人本”管理。 (5)社会风潮:“学习成风”，终身教育、终身学习等观念渐成主流 (6)人文条件:社会价值观由“物质主义”转变为“后物质主义” 学习型组织的定义 学习型组织是一种 高度柔性的、有机的、扁平精简的、弹性化且人性化 的组织，通过在组织内部形成全员学习的组织文化，充分激发组织成员个体和组织整体的创新性思维和创造性能力，从而全力实现组织的共同愿景，取得可持续的组织发展。 学习型组织与组织学习 学习型组织与组织学习之间的差别。 学习型组织理论在一定程度上借鉴和发展了组织学习理论的许多思想和观点。 组织学习集中在对组织内部个人和集体学习的方法分析上，侧重于理解和掌握。 组织中学习的本质和过程；而学习型组织作为一种新型的管理模式，是精神或文化表征的展现，它更多地注重于如何识别、促进和评估组织内的学习过程，推动组织变革，创造和保持竞争优势。 学习型组织与传统科层制组织 学习型组织与传统科层制组织之间的不同之处。 主要选项 学习型组织 科层制组织 组织核心 共同愿景 共同目标 成功标准 持续经营或发展 最大利润或效率 竞争优势 学习能力 组织效率 决策重心 下移 偏上 组织层级 较少 较多 组织制度 柔性(灵活性) 刚性(强制性) 组织结构 扁平团队式 直线职能式 组织关系 平等和谐 等级鲜明 组织界限 渗透式 固定式 管理风格 参与式 专制式 组织文化 开放、合作 服从、竞争 组织成员· 多样化 相似性 组织人才观 合作 竞争 组织人数 少 多 组织奖励 团队 + 个人 个人 2. 学习组织的建立与发展 组织的学习智障 组织的学习智障主要表现 (1)局限思考 (2)归罪于外 (3)缺乏整体思考的主动积极性 (4)专注于个别事件 (5)习而不察 (6)完全凭经验学习 (7)团队的迷思 第一项修炼——自我超越 自我超越是建立与发展学习型组织的第一项修炼。自我超越的修炼是学习型组织的精神基础。 自我超越修炼的方法 (1)建立个人愿景 (2)保持创造性张力 (3)看清结构性冲突 (4)诚实地面对真相 (5)运用潜意识 第二项修炼——改善心智模式 心智模式的特点: (1)根深蒂固; (2)影响认知和行为; (3)每个人的心智模式都必定有欠缺之处。 ★ 改善心智模式修炼的方法 (1)辨认跳跃式的推论 (2)练习左手栏 (3)兼顾探询与辩护 (4)对比拥护的理论与使用的理论 第三项修炼——共同愿景 共同愿景修炼的方法 (1)鼓励建立个人愿景 (2)在组织内塑造整体图像 (3)融人企业理念 (4)学习双向沟通技术 (5)忠于事实 第四项修炼——团队学习 团队学习是发展组织成员整体搭配与实现共同目标能力的过程。它是学习型组织最基本的学习形式。 团队学习修炼的方法: 深度会谈、讨论团队学习是发展组织成员整体搭配与实现共同目标能力的过程。它是学习型组织最基本的学习形式。 在现代组织中，所谓的团队是指一小群具有不同技能的人相互依存地工作在一起，这群人认同于某一共同目标，为了达成此目标，他们贡献自己的能力，扮演好自己的角色，彼此分工合作，沟通协调，齐心努力，并为这一目标的达到与否共同承担成败的责任。 团队学习的修炼要学会运用 深度汇谈(即真诚交流) 与 讨论。这是两种不同的团队交谈方式。 1.深度会谈 为了确保有效的深度会谈，一般认为以下三项条件是必要的: (1)悬挂假设; (2)所有参与者必须视彼此为工作伙伴; (3)一个深度会谈的辅导者必须做好一个“过程顾问”的许多基本工作。 2.讨论 讨论是提出不同的看法，并加以群护。在学习型组织中，讨论指观点的充分撞击，最后形成一个较为统一的认识和观点。在有效的讨论活动中，人人都是赢家，个人可以获得独无法达到的见解。 用学习型组织的术语来说，以共同意义为基础的“新心智”开始呈现，一个代表组织共同意义的汇集开始不断发展壮大。 深度会谈与讨论基本上是能互补的。 通常，人们用深度会谈来探讨复杂的问题，用讨来就某些问题达成协议。一个学习型的团体要善于交叉运用深度会谈与讨论这两种方式能力。 在团队学习过程中,常常会因为组织成员的习惯性防卫而降低学习的质量。习惯性卫是根深蒂固的习性，用来保护自己或他人免于因为说出真正的想法而处于窘境或受到胁。 只有当团队能够以“自我揭露”和“兼顾反思与探询”成功地处理习惯性防卫时，团队房员才可以更加了解彼此的思考，更好地进行团队学习。 第五项修炼一一系统思考 系统思考是学习型组织的灵魂。系统思考要求人们运用系统的观点看待组织的发展。它引导人们，从看局部到纵观整体，从看事件的表面到洞察其变化背后的结构，以及从静态的分析到认识各种因素的相互影响，进而寻找一种动态的平衡。 ★ 系统思考的法则 (1)今日的问题来自于昨日的解 (2)越用力推则系统反弹力越大 (3)恶化之前常先好转 (4)显而易见的解往往无效 (5)权宜之计的对策可能比问题更糟 (6)欲速则不达 (7)因与果在时空上并不紧密相连 (8)寻找小而有效的杠杆解 (9)鱼与熊掌可以兼得 (10)系统具有整体性而不可分割 (11)不可绝对归罪于外。 系统基模包括: 1.反应迟缓的调节环路基模; 2.成长上限基模; 3.舍本逐末基模(特例:转嫁负担给帮助者); 4.目标侵蚀基模; 5.恶性竞争基模; 6.富者愈富基模; 7.共同悲剧基模; 8.饮鸠止渴基模; 9.成长与投入不足基模 整合五项修炼，创建学习型组织 系统思考与其他四项修炼的关系 (1)自我超越与系统思考是相辅相成的。 (2)系统思考对于有效确立和改善心智模式也同样重要。 (3)如果没有系统思考的配合，建立共同愿景的修炼会缺乏重要的支撑。 (4)系统思考的观点和工具对团体学习极为重要。 (5)系统思考也需要有自我超越、改善心智模式、共同愿景与团 队学习四项修炼来发挥它的潜力。 五项修炼的地位、作用与相互关系。 系统思考是学习型组织的灵魂。它为个人或组织提供了一个健全的大脑，一种完善的思维方式，自我超越、改善心智模式、建立共同愿景、团队学习，都因为有了系统思考的存在而连在一起，共同达到组织的目标。 其中；改善心智模式 和 团队学习 这两项修炼是基础，自我超越 和 建立共同愿景 这两项修炼形成向上张力。系统思考是创建学习型组织的核心。 3. 创建学习型政府组织 在政府中创建学习型组织的必要性。 (1)创建学习型组织是政府应对全球化挑战的需要。 (2)创建学习型组织是增强政府核心竞争力的需要。 (3)创建学习型组织是政府改革和创新的辅助手段 (4)创建学习型组织是提高政府公务员素质的重要途径 (5)政府创建学习型组织是创建学习型社会的关键所在。 在政府中创建学习型组织的障碍与难点 (1)政府组织中的体制性障碍 (2)政府组织成员的 “自利经济人” 倾向 (3)政府组织中的 “官僚文化” (4)政府组织中的技术障碍 ★ 整合运用五项修炼来建构学习型组织 (1)改善政府心智模式，为创建学习型组织打造坚实基础。 (2)激励政府组织成员自我超越，形成创建学习型组织的向上张力。 (3)创建共同愿景，在政府组织成员中树立全局观念和打造团队精神。 (4)建立良好的组织学习机制，促进政府组织的团队学习。 (5)建立和完善政府学习机制的相关配套机制。 (6)合理运用信息技术，加强电子政府的建设，开展电子学习。 十二、政府流程再造 业务流程再造(BPR) 是指对企业的业务流程作根本性的思考和彻底重建，其目的是在成本、质量、服务和速度等方面取得显著性的改善，使得企业能最大限度地适应以顾客、竞争变化为特征的现代企业经营环境。 ★ 业务流程再造具有四个重要特征: (1)根本性的; (2)彻底的:不是改进,而是革命; (3)显著性的:不是提高,而是飞跃; (4)以流程为中心的。 这四个特征中,流程 是最重要的。 政府流程再造作为一种新的管理理念应用于政府管理中 其着眼点在于一个个政府流程，把政府流程作为最基本单位，以剖析政府组织的整体运作过程和管理模式。 其根本目标在于通过对政府流程的梳理和重组，以显著提高政府组织绩效。 政府流程再造的内涵 (1)以公众为出发点。 (2)以流程为中心。 (3)以“服务链”为纽带。 (4)以“扁平化”组织模式为目标 “扁平化”组织模式的特点 (1)扁平化。 (2)弹性化。 (3)开放性。 (4)动态适应性 ★ 政府流程再造的产生背景 (1)官僚制弊病日益突出。 (2)信息技术的发展与进步所带来的影响。 网络的出现和普及,为政治民主提供了新的技术基础。网络为公民提供了积极参与政治的技术手段。公众参与政府决策的变化直接带来了政府自身行为方式的改变，而这正是政府流程再造发生的最大背景之一。 ★ 政府流程再造的特点 (1)政府流程再造是多向互动的系统工程。 (2)政府流程再造强调政府绩效和服务质量的显著提高。 (3)政府流程再造强调对现代网络信息技术的应用 ★ 政府流程再造的过程 (1)准备阶段。首先是要明确政府流程再造的目的和范围,这是政府流程再造的准备阶段,也是流程再造成功的基础环节。 (2)项目启动与计划阶段。成立业务流程再造小组;制订流程再造实施计划;就公众对本部门所提供公共服务的需求进行分析;设置政府流程再造的绩效目标。 (3)分析诊断阶段。对现有的公共服务及相关支持流程的描述和分析能够使组织和组织成员对组织目标有一个明确的理解和认识。 (4)新的政府业务流程设计阶段。分析并定义新流程的初步方案;建立新流程的原型和设计方案;设计人力资源;信息系统的分析和设计。 (5)流程再造实施阶段。重组组织结构及其运行机制；信息系统的实施；培训员工；新旧流程切换。 (6)对流程再造结果的检测评估阶段。组织的业务流程再造实施后，要评价再造成功与否，一方面，可以从直观感受方面直接获得结果；另一方面，要着力于对流程输出各项指标的评估。 ★ 政府流程再造的意义 (1)政府流程再造是实现政府职能转变的需要 (2)政府流程再造是推动政府机构改革的需要。 (3)政府流程再造是提高行政绩效、降低行政成本的需要。 (4)政府流程再造是推进电子政务建设的需要 电子政务是信息技术于政府部门运用并引起政府管理变革的综合性结果和现象集合，是在流程再造、顾客导向、企业化、分权、竞争等各种创新理念指导下的政府改革的一种新形态。 ★ 政府流程再造与电子政务之间的关系 (1)政府流程再造是电子政务的逻辑前提。 (2)电子政务的发展是影响政府流程再造的重要因素。 政府流程再造与电子政务之间的相互影响。 政府流程再造的顺利推进为电子政务的实施扫清组织结构甚至部分体制和文化的障碍，从而有力地推动政府电子政务目标的实现。 而信息技术的发达和电于政务的发展则为政府流程再造提供了更有利的技术背景和更高的起点。 同时，它所带来的政府流程的新变化也将更多的困难和挑战摆在了政府流程再造实践的面前，而政府流再造，作为新一轮政府改革的重要趋势和路径，面对这些问题时无法采取回避态度，只能直面应对，并学着克服。 ★ 中国政府流程再造的实践 (1)初始阶段:效率政府建设时期。这一阶段的特征是单一部门内部的流程调整，要体现在某些政府流程的精简或者取消。 (2)深化阶段:整体性政府建设时期。这一阶段的特征是跨部门的流程优化,在跨部门、跨层级的大范围内实现政府信息、资源共享和协同办公。 (3)突破阶段:智慧政府建设时期。智慧政府就是指在大数据和人工智能技术的支持下，建立智慧数据平台整合和共享信息，建立一个以数据为核心，“政府一市场一社会”多元协作共治的治理格局。 【单选、辨析】 一站式服务中心以民众需求为中心的流程设计，打破了政府职能和部门界限,将相关政府部门提供的公共服务项目整合在一起，不仅极大地方便了公众，降低了公众在获取公共服务过程中的难度和成本也有效地打破了传统官僚制的壁垒，促进了部门之间的信息共享和沟通协作，理顺了政府流程关系。 行政审批制度改革将 办证、登记、挂号、过户、结算、报批项目、资质认定 等具体事项整合到行政服务大厅中。 ★ 中国政府流程再造面临的挑战与问题 (1)地方政府流程再造动力失衡 (2)政府系统复杂，职能部门间存在目标差异 (3)信息技术改造与行政体制存在脱节 (4)绩效评估制度不完善，人为割裂流程 从具体实践上看,政府流程再造最根本的风险或许在于,我们要如何在解构原有官僚制组织结构和文化的同时，又不破坏原有制度设计中能够彰显和保障公共精神的那些构想以及价值。 同时又能在新的社会、经济、技术背景下,与整个发展社会趋势保持一致,并能够成为引领社会变革的方向和指标，这是我国政府流程再造改革中必须正视的挑战，也是必经的道路。 十三、行政组织改革 美国改革 美国行政组织改革的背景。 (1)从二战后到20世纪 70 年代末,美国政府行政职能的扩张引起公众的不满。 (2)美国政府规制过多过滥,抑制了组织及其工作人员的积极性和创造性。 (3)信息技术的发展为行政组织的变革创造了有利条件。 (4)国际环境的变化也促使美国行政组织出现了一些新变化。 美国行政组织改包括: (1)政府职能市场化; (2)放松规制 (3)放权与分权并行; (4)精简机构 政府职能市场化表现在: (1)公共服务民营化; (2)政府业务合同化 美国行政组织改革的特点。 美国行政组织改革以放松规制为其突出特点。放松规制的改革为私营部门管理理念的导人提供了空间,如引进效率观念、服务意识和竞争机制,开拓了新的思路;放松规制适应了信息时代政府管理的需求;美国放松规制的改革,并不是放松或废除所有的规制。 英国改革 背景：当代英国的行政改革大致可分为撒切尔夫人政府改革时期、工党布莱尔政府改革时期和卡梅伦政府改革时期。 撒切尔夫人的“竞争性政府”改革。 撒切尔政府改革主要是借助私营部门的管理方法来改革政府公共部门,它以提高政府管理效率、转变政府职能为目标,以引进市场机制和竞争为手段,目的是打造一个“竞争性政府”。改革的主要方向是公共服务的市场化。 布莱尔的“合作型政府”改革 1997年上台的布莱尔政府的改革背景是建立在对以往行政改革的经验的反思之上布莱尔上台所推行的改革，试图既借鉴企业竞争文化以推进公共服务的高效率，又能超越新自由主义的框架，希望秉承工党所主张的“第三条道路”。工党的“第三条道路”是在继续保守党政府的改革大方向的前提下,顺应环境变化的需要并总结前段改革经验的基础上,进行了渐进调整。 卡梅伦的“开放公共服务”改革。卡梅伦政府改革的具体做法包括： (1)去中心化; (2)分权治理; (3)强化问责。 ★ 英国行政组织改革的内容 (1)重新界定和优化行政组织职能,将部分职能市场化。 (2)以加强中央宏观调控权为宗旨,调整中央与地方行政组织之间的关系。 (3)以效率为中心，改革行政组织的内部管理体制。 英国行政组织改革的特点。 (1)非常注重学习私营企业的管理经验。 (2)注重循序渐进 (3)改革方案具有很强的针对性和操作性 日本改革 日本行政组织改革的背景 (1)过度的规制抑制了民间的创新和活力。 (2)随着经济增长速度的减慢,日本出现了持续的财政困难和财政赤字。 (3)中央政府对地方政府干预较大,限制了地方自治和市民自治的健康发展 (4)国际环境的变化对政府提出了挑战。 (5)社会问题的日趋繁多和严重,使日本政府面临着新的难题 日本行政组织改革的主要内容。 (1)放松国家规制，调整官民关系，缩减政府职能及机构 (2)推动地方分权,重新调整中央与地方的关系 (3)建立防止行政机构膨胀的机制 (4)建立公务员交流制度,纠正条条行政的弊端。 中国改革 ★ 当代中国行政组织改革的背景 (1)社会主义市场经济体制的逐步建立,要求行政组织进行相应的改革。 (2)民主化政治体制的改革为我国行政组织的改革提供了广阔的空间。 (3)传统的行政组织体制,使行政效率低下,导致社会公众不满,为行政组织改革提供了社会动力。 (4)国外行政改革的理论与实践给我国行政组织改革提供了有益的经验和借鉴。 (5)知识经济时代的到来,给我国的行政组织改革带来了机遇和挑战。 中国行政组织改革的主要内容。 (1)理顺行政组织与其他组织的职能关系 (2)理顺行政组织内部的职能关系 (3)行政组织职能转变 (4)行政组织机构的改革 ★ 中国行政组织改革的主要经验 (1)坚持以适应 社会主义市场经济 体制为改革的目标，把转变政府职能作为机构改革的关键。 (2)坚持精简、统一、效能的原则，把精兵简政和优化政府组织结构作为机构改革的重要任务。 (3)坚持渐进的、稳妥的改革方针，坚持统一领导，分级负责，分步实施，从实际出发因地制宜地进行改革。 (4)坚持机构改革与于部人事制度改革相结合，制定配套的政策措施，妥善安排分流人员，优化干部队伍结构。"},{"title":"中国近代史纲要","path":"/2023/12/25/中国近现代史纲要/","content":"03708 中国近代史纲要 类别 题型 题量 分值/题 总分 选择题 单项 25题 2分 50 非选择题 简答题 5题 6分 30分 非选择题 论述题 3选2 10分 20分 概览 第一章 反对外国侵略的斗争 1840 ~ 1949 打天下 1840 ~ 1919 鸦片战争到五四运动前夜 1919 ~ 1949 五四运动到新中国成立 1949 ~ 现在 守天下 孙中山 1894年——檀香山——兴中会——孙中山——中国第一个资产阶级革命组织——标志着资产阶级革命民主派的诞生。 1905年——日本东京——孙中山、黄兴、宋教仁——同盟会一近代中国第一个 全国性的资产阶级 性质的政党。 辛亥革命成功后袁世凯窃取胜利果实为了挽救共和 1913年 反对袁世凯刺杀宋教仁和“善后大借款”—发动了“二次革命&quot; 1914年 日本东京 孙中山 中华革命党 1915年 为反对袁世凯称帝 发动了护国战争。 1917年和1921年 为捍卫《临时约法》、恢复国会 发动了第一次护法运动和第二次护法运动。 1919年 中华革命党 改组为 中国国民党。"},{"title":"马克思主义基本原理概述","path":"/2023/12/19/马克思主义基本原理概述/","content":"马克思主义基本原理概述 一、绪论：马克思主义是关于无产阶级和人类解放的科学 ★ 什么是马克思主义？ 马克思主义是由马克思、恩格斯创立的，为他们的后继者所发展的，以反对资本主义、建设社会主义和共产主义为目标的科学的理论体系，或者简要地说，它是关于无产阶级和人类解放的科学。 ★ 马克思主义的构成？ 马克思主义主要包含了三方面的内容：马克思主义哲学(科学的世界观和方法论——原则)、马克思主义政治经济学(揭示了资本主义的发展规律——中介)、科学社会主义(核心地位——结论)。三者相互渗透、互相统一的。诞生于 19 世纪 40 年代中期。 马克思主义的理论品质——与时俱进 马克思主义活的灵魂——实事求是 人民性 人民至上 是马克思主义的政治立场 实践性 马克思主义的科学性和革命性都是以 实践性为基础 的 革命性 彻底的批判精神和鲜明的 无产阶级立场(政治立场) 科学性 科学的世界观和方法论基础 ，即 辩证唯物主义和历史唯物主义 马克思主义的产生和发展 马克思主义为什么会产生？ 客观条件：工业革命的深入推动了资本主义的迅速发展，导致其内部矛盾的尖锐化 阶级基础：工人阶级(无产阶级)作为一支独立的政治力量登上历史舞台 公开问世的标志 ：1848年2月( 19世纪40年代)，马克思、恩格斯发表《共产党宣言》 ★ 马克思主义理论的直接来源 马克思主义理论 理论来源 代表人物 哲学 德国古典哲学 黑格尔辩证法、费尔巴哈唯物主义 政治经济学 英国古典政治经济学 亚当·斯密、大卫·李嘉图 社会主义哲学 英法空想社会主义 圣西门、傅立叶、欧文 自然科学前提(间接理论来源)：细胞学说、能量守恒与转化定律、生物进化论。 简答：马克思主义在实践中不断发展 马克思主义之所以是发展着的理论，是由它的理论本性决定的。 首先，马克思主义不是脱离实际的抽象的思辨体系，它永远面对现实世界，面对实际生活，关注和研究时代提出的最迫切的问题，总结新的实践经验，提出新的理论观点。 其次，马克思主义不是宗派主义体系，它能正确地对待各种非马克思主义，甚至反马克思主义的学说，对它们进行批判地研究，剔除其中错误的观点，吸收其积极合理的内容。 再次，马克思主义不是故步自封的体系，它具有自我批评意识，它能根据时代的变化、实践的发展和科学的进步，发现自身的历史局限性和不完善的地方，把自身提高到与时代和实践的需要更加适应的水平。 马克思主义的鲜明特征 ★ 马克思主义的理论品质——与时俱进 与时俱进就是党的全部理论和工作要体现时代性，把握规律性，富于创造性。 站在时代的前列，把握时代的特点，认真研究和探索现实中的问题 以马克思主义的立场、观点、方法为指导 富于创造精神，适应新形势、新任务的要求 ★ 坚持与时俱进的意义 决定着党和国家的前途命运 创新是一个民族进步的灵魂，是一个国家兴旺发达的不竭动力，也是一个政党永葆生机的源泉 实践基础上的与时俱进、理论创新是社会发展和变革的先导 ★ 马克思主义的鲜明特征——科学性与革命性的关系 根源于革命性的要求，并且通过革命性表现出来 以科学性为前提和基础，并且靠科学性来保证 马克思主义的根本 理论特征 是 以实践为基础 的 科学性和革命性的统一 马克思主义的科学性与革命性的统一 马克思主义的理论特征 马克思主义的根本 理论特征 是 以实践为基础 的 科学性 和 革命性 的统一。 革命性：集中表现为彻底的 批判精神，还表现为它具有鲜明的 政治立场。 科学性：它不带任何偏见，清除一切狭隘性和片面性的弊端，力求按照世界的本来面目去如实地认识世界，揭示自然界和人类社会发展的客观规律，并根据对客观规律的认识去能动地改造世界。 马克思主义的科学性还在于它的深刻性。 马克思主义之所以具有科学性，不仅仅在于它揭示了自然界和人类社会发展的客观规律，而且还在于它经受了实践的检验并随着实践的发展而不断发展。 马克思主义的理论品质 党的十六大报告明确指出，与时俱进 是马克思主义的 理论品质。 马克思主义的社会理想 理想的分类：生活理想、职业理想、道德理想、社会理想。 其中 社会理想 是最根本的，是全部理想的核心。马克思主义的社会理想是推翻资本主义、实现 社会主义 和 共产主义。 实现共产主义是长期的远大的 最高理想； 走中国特色社会主义道路，把我国建设成为富强、 民主、文明、和谐的社会主义现代化国家，相对于最高理想来说，是近期的具体理想，即全国各族人民的 共同理想； 马克思主义的 最高理想 与全国各族人民的 共同理想 的关系：两者之间即相互区别又相互联系，是 辩证统一 的关系： ①共同理想是实现最高理想的 必经阶段和必要基础。 ②实现共同理想，必须坚持以最高理想为 根本方向。 学习、运用和发展马克思主义 ★ 学习马克思主义的态度和方法 努力学习和掌握马克思主义的 基本立场、观点、方法 坚持理论联系实际的马克思主义学风(学习马克思主义的根本方法) 自觉将马克思主义内化于心、外化于行 ★ 自觉学习和运用马克思主义的方法一坚持理论联系实际 原因： 实践性决定的 目的决定的 怎么做： 把马克思主义的基本原理作为指导，去观察和分析社会实际。 在实际工作中必须反对经验主义和教条主义两种倾向。 马克思主义是行动的指南 (1)马克思主义不是教条，它并不提供对一切问题的现成答案。 (2)把马克思主义作为行动的指南，就必须从客观存在的实际情况出发，而不能从 马克思主义的一般原理 出发。 (3)在中国现阶段，把马克思主义作为行动的指南，就是要用马克思主义的立场、观点、方法来研究和解决我国改革开放和现代化建设中的实际难题。 马克思主义的目的和根本方法 树立正确的世界观、人生观、价值观。 掌握认识世界和改造世界的伟大工具。 全面提高人的素质。 指导 中国特色社会主义 伟大实践。 根本方法：理论联系实际 在新的历史条件下丰富和发展马克思主义 1.现实社会主义的变化向马克思主义提出的研究课题； 2.当代资本主义的新变化向马克思主义提出的研究课题； 3.经济全球化向马克思主义提出的研究课题； 4.世界新技术革命向马克思提出的研究课题； 5.我国的改革开放和现代化建设向马克思提出的研究课题； ★ 马克思主义的当代价值 观察当代世界变化的 认识工具 指引当代中国发展的 行动指南 不是教条 遵循实际 用马克思主义的立场、观点、方法来研究和解决实际问题 引领人类社会进步的 科学真理 二、马克思主义哲学 —— 思考这个世界是什么 第一章：世界的物质性及发展规律 (唯物主义辩证法) 物质及其存在形态 ★ 什么是物质？ 就是不依赖于人类的意识而存在，并能为人类的意识所反映的客观存在(客观实在性)。 意义： 物质是 不依赖于意识 的 客观实在，同唯心主义划清了界限 物质是 可以被人们认识 的，同不可知论划清了界限 客观实在性是一切物质的 共性，克服了旧唯物主义物质观的局限性 ★ 什么是哲学？ 人们对包括自然、社会和人类思维在内的 整个世界 的根本看法和根本观点，是世界观、方法论和价值观的统一。 哲学的基本问题？ 第一方面：物质和意识哪个是本原？这种哲学上属于本体论的问题，是最重要的方面。 第二方面：思维和存在的同一性问题，思维能否认识存在的问题，即世界可不可以认识的问题。这种哲学上属于认识论问题。 恩格斯第一次明确指出：“全部哲学 ，特别是近代哲学的重大的基本问题，是 思维和存在(意识和物质) 的关系问题。” (1)存在和思维 究竟谁是 世界的本原，即物质和精神何者是第一性、何者是第二性的问题。对这一问题的不同回答，构成了划分 唯物主义和唯心主义 的标准。 (2)存在和思维 有没有 同一性，即思维能否正确认识存在的问题。对这一问题的不同回答，构成了划分 可知论和不可知论 的标准。 哲学的其它问题？ 世界如何存在 形而上学：认为世界上事物都是 彼此孤立 的，静止不变的，否认事物内部矛盾的存在。 辩证法：认为世界上的事物都是相互联系的、运动发展的，发展的根本原因在于事物的内部矛盾。 世界统一性问题 一元论：本原只有一个 统一 二元论：本原不只有一个 不统一 形而上学唯物主义还有四个局限性：机械性、形而上学性、直观性、不彻底性 ★ 物质的存在形态 运动 是物质的根本属性和存在方式；时间和空间 是物质运动的存在形式；绝对性和相对性。 时间具有 一维性(持续的、顺序的)，不可逆；空间具有 三维性(广延性、伸张性)。 世界是物质的，物质是运动的，运动是有规律的，规律是可以被认识的，认识是螺旋式上升、曲折前进的。 ★ 意识的本质 是人脑的机能和属性，人脑是意识的物质 是客观世界的主观印象，是人脑对客观世界的反映 是社会的产物，是自然界长期发展的产物 ★ 物质与意识的辩证关系 ①物质，就是不依赖于人类的意识，并能为人类的意识所反映的客观存在 ②意识是人脑的机能和属性 ③物质决定意识 ④意识对物质具有反作用 ⑤主观能动性和客观规律性的统一 ★ 物质与意识的辩证关系——意识对物质具有反作用(能动作用) 具有目的性和计划性(指定学习计划) 具有主动性、创造性(主动学习) 对于人的生理活动具有一定影响作用(抵抗瞌睡，认证学习) 能通过指导实践改造客观物质世界——根本途径(参加考试) ★ 物质与意识的辩证关系——主观能动性和客观规律性的统一 尊重客观规律 是正确发挥主观能动性的 前提。 认识和利用客观规律又必须充分发挥人的主观能动性。 简答：辩证唯物主义和历史唯物主义是彻底的唯物主义一元论，其基本思想 承认世界的统一性，坚持一元论,反对二元论； 认为世界统一于物质，坚持唯物主义一元论，反对唯心主义一元论； 认为世界是运动发展的、无限多样性的统一，克服了旧唯物主义把 世界的本原归结为某一种或某几种具体的物质形态的局限性； (辩证唯物主义和历史唯物主义关于世界物质统一性的原理，是人类 认识长期发展的结晶，不断地被自然科学和哲学长期发展所证明) 运动是物质的 根本属性 和 存在方式，物质与运动不可分割。一方面世界上不存在脱离运动的物质，世界上的一切事物无一不是处在运动中。另一方面：世界上也不存在没有物质的运动。 简答：承认事物相对静止的存在具有重要的意义 (1)只有承认相对静止，才能理解事物的多样性，区分开不同的事物； (2)只有承认相对静止，才能认识事物分化的条件和生命现象的产生； (3)只有承认相对静止，才能理解绝对运动；(总之，世界上的事物都是绝对运动和相对静止的统一，是动中有静，静中有动) 实践的基本特点： (1)客观性； 实践是客观的感性物质活动。 (2)自觉能动性； 实践是主体有意识、有目的的活动。(单选) (3)社会历史性。实践是社会性的、历史性的活动。 简答：社会生活在本质上是实践的，原因是什么？ 马克思主义认为，实践是人类社会产生、存在和发展的基础。 ① 劳动实践是人类和人类社会产生的决定性环节； ② 物质生产实践是人类社会得以存在的基础； ③ 实践活动是推动社会发展的动力。 事物的联系和发展 联系和发展的观点是唯物辩证法的总观点和总特征。 客观性、普遍性、多样性、条件性 ★ 事物的变化发展：新事物的产生与旧事物的灭亡(新事物不可战胜的原因)。 (1)新事物符合事物发展的必然趋势，新事物有新的要素、结构和功能，它适应已经变化了的环境和条件；旧事物它的各种要素和功能已经不适应环境和客观条件的变化，走向灭亡就成为不可避免的。 (2)新事物是在旧事物的“母体”中孕育成熟的，它既否定了旧事物中消极腐朽的东西，又保留了旧事物中合理的、适应新条件的因素，并添加了旧事物所不能容纳的新内容。这也正是新事物在本质上优越于旧事物、具有强大生命力的原因所在。 (3)在社会历史领域，新事物是社会上 先进的、富有创造力 的人们创造性活动的产物，它从根本上符合人民群众的利益和要求，能够得到人民群众的拥护，因而必然战胜旧事物。 符合事物发展规律；以旧事物为基础，为母体；符合人民利益，得到拥护。 内容与形式：从 构成要素 和 表现方式 上反映事物的一对基本范畴 本质与现象：揭示事物 内在联系 和 外在表现 的一对范畴 原因与结果：揭示事物引起和被引起关系的一对范畴 必然与偶然：揭示事物 产生、发展和衰亡过程中 的 不同趋势 的一对范畴 现实与可能：反映事物的 过去、现在和将来 关系的一对范畴 ★ 简述内容与形式的辩证关系 内容是指构成事物一切要素的总和 形式是指把内容诸要素统一起来的结构或表现内容的方式 内容决定形式 形式对内容又有巨大的反作用 内容与形式两者之间辩证统一，相互联系 ★ 本质和现象的辩证关系 本质是事物的根本性质 现象是事物的外部联系和表面特征 本质决定现象 现象表现本质 本质与现象两者之间辩证统一，相互联系 对立统一规律是事物发展的 根本规律 矛盾分析方法 是认识世界和改造世界的根本方法 事物发展的动力和源泉是事物的 内部矛盾 唯物辩证法 与 形而上学 的根本对立和斗争的焦点在于 是否承认矛盾是事物发展的动力 对立统一规律——基本属性 对立统一规律是唯物辩证法的 实质和核心，从根本上回答了事物为什么会发展的问题。 ★ 对立统一规律是唯物辩证法的实质与核心。 (1)对立统一规律揭示了事物普遍联系的根本内容和发展变化的内在动力。 (2)对立统一规律是贯穿于唯物辩证法其他规律和范畴的中心线索，是理解它们的钥匙。 (3)矛盾分析法是最根本的认识方法。 对立统一规律——矛盾的同一性和斗争性 ★ 对立统一规律——内因和外因 内因：事物的内部矛盾，事物发展变化的根据，是 第一位 的原因。 外因：外部矛盾，事物发展变化的条件，是 第二位 的原因。 外因通过内因而起作用。外因的作用无论多大，也必须通过内因而起作用。 意义：是我们党制定和执行独立自主、自力更生以及对外开放方针的重要理论基础。 中国的发展离不开世界，对外开放是建设中国特色社会主义的一项基本国策。 对立统一规律——矛盾的普遍性和特殊性 普遍性(共性、一般)：始终存在于一切事物中 特殊性(个性、个别)：不同阶段上各有其特点(具体问题具体分析) 矛盾的普遍性和特殊性在一定条件下可以相互转换 普遍性 存在于 特殊性 之中，通过 特殊性 表现出来；普遍性由 特殊性 组成。 矛盾的普道性和特殊性辩证关系的原理，是建设中国特色社会主义的理论基础。在中国建设社会主义，必须从中国的国情出发，把科学社会主义的一般原理同中国具体实际结合起来，在实践中开辟建设中国特色的社会主义道路。 ★ 对立统一规律——矛盾的不平衡性 不同矛盾 主要矛盾：处于支配地位、对事物发展起决定作用的矛盾 次要矛盾：处于从属地位、对事物的发展起次要作用的矛盾 同一矛盾 主要方面：处于支配地位、起着主导地位 次要方面：处于被支配的地位 ★ 主次矛盾关系原理：主次矛盾之间的辩证关系 主要矛盾是矛盾体系中处于支配地位、对事物发展起决定作用的矛盾 次要矛盾是矛盾体系中处于从属地位、对事物的发展起次要作用的矛盾 主要矛盾规定和影响着次要矛盾的存在和发展 次要矛盾对主要矛盾有制约作用 它们在一定条件下可以相互转化 两者是相互联系、辩证统一的 ★ 对立统一规律——“两点论”和“重点论” 坚持重点论：在认识复杂事物的发展过程时，要着重地抓住主要矛盾；在研究某一矛盾时，要着重地把握矛盾的主要方面。 坚持两点论：在认识复杂事物的发展过程时，既要看到主要矛盾，又不忽略次要矛盾；在认识某一矛盾时，既要看到矛盾的主要方面，又不忽略次要矛盾的次要方面。 坚持统一：看问题、办事情既要全面，又要善于抓住重点。 ★ 对立统一规律——唯物辩证法的实质与核心 对立统一规律揭示了 事物普遍联系 的 根本内容 和 发展变化 的内在动力。 对立统一规律是贯穿于唯物辩证法 其他规律 和 范畴 的中心线索，是理解它们的钥匙。 矛盾分析法是 最根本的认识方法。 ★ 量变质变规律——辩证关系 量变是质变的必要准备 质变是量变的必然结果 量变和质变是相互渗透的 质量互变规律要求我们在社会中主义建设和改革过程中，把 远大的理想和目标 同 有步骤、分阶段地踏实苦干、稳步前进 的精神结合起来，反对急躁冒进、急于求成。否则会欲速则不达，得到的结果往往事与愿违。 否定之否定规律 揭示了事物的发展是前进性和曲折性的统一 第二章：实践与认识及其发展规律 实践与认识 ★ 马克思主义的认识论同唯心主义认识论、不可知论、旧唯物主义区别开来 认识的过程是反映与创造的统一，这是辩证唯物论的 反映论的能动性 的突出表现，也是区别于机械唯物论反映论的 根本标志。 唯物论的反映论与唯心论的认识论的对立 可知论与不可知论的对立，思维能够认识并能够正确认识现实世界 辩证唯物论的能动的反映论与旧唯物论的机械的反映论的对立 实践是主体能动地改造和探索客体的客观物质活动 实践：马克思主义哲学同旧唯物主义和唯心主义的根本区别。 旧唯物主义：直观性，离开人的实践活动去理解世界，忽视了人的主体性、能动性。 唯心主义：片面夸大人的主体性、能动性，把意识看成是世界的本原，它当然也不可能坚持实践的观点。 实践的特征： 客观性(直接现实性)：实践是客观的感性物质活动 自觉能动性：实践是主体有意识、有目的的活动 实践的三种基本形式：物质生产实践、社会政治实践(处理社会关系)、科学文化实践 ★ 实践是推动认识发展的动力 新的需要、新的研究课题 思维能力的发展 新的经验和新的观察、研究物质的手段 认识的本质 辩证唯物主义认识论认为，认识的本质是 主体在实践基础上对客体的能动反映。 实践关系：改造和被改造的关系 认识关系：反映和被反映的关系 实践在认识活动中的决定作用：实践是认识的基础，从而引起了认识论的革命 实践是沟通主体和客体的桥梁，认识作为主体对客体的反映，只有在主体和客体相互接触、相互作用的情况下才能发生，而能使主体和客体相互接触、相互作用的唯一途径就是实践。 实践是推动认识发展的动力 ★ 感性认识和理性认识是辩证统一的 感性认识是对事物表面的、直接的、具体的、个别特性的反映 理性认识是对事物本质的、全体的、间接的、概括的反映 感性认识有待于发展和深化为理性认识 理性认识依赖于感性认识 感性认识和理性认识相互渗透、相互包含 ★ 从感性认识上升到理性认识的基本条件 调查：投身实践，深入调查，获取十分丰富和合乎实际的感性材料 思考：必须经过思考的作用，运用理论思维和科学抽象，将感性材料加以去粗取精、去伪存真形成概念和理论的系统。 认识运动的第一次飞跃 ：感性认识到理性认识 认识运动的第二次飞跃 ：理性认识到实践 认识的第二次飞跃比第一次飞跃具有更加重大的意义(把理论用于实践) ★ 认识过程的多次反复和有限与无限的辩证统一 有限性： 每个时代的个人每一次具体的认识是有限的 每个时代的个人的每一次具体的认识，由于 受主客观条件 的限制，都是有限的 无限性： 无限性整个人类无止境的世代更替的认识是无限的 辩证统一： 整个人类认识的无限性，存在于每个时代个人的认识的有限性中，并通过无数有限性的认识而得以实现。 真理与价值 ★ 真理的客观性 真理的客观性指真理的内容是对 客观事物 及其 规律 的 正确反映。 实践是检验真理的 ★ 真理的绝对性和相对性 真理是一个过程。任何真理都是绝对性和相对性的辩证统一，二者相互联系、不可分割。 真理的发展过程就是 由相对真理走向绝对真理 的过程。 ★ 逻辑证明与实践检验的关系 逻辑证明：是指运用已知的正确概念和判断，通过一定的推理，从理论上确定另一个判断的正确性的逻辑方法； 实践检验是通过实际去验证结果的正确与否； 逻辑证明对实践检验起到帮助作用； 实践检验是逻辑证明的终极环节； 两者互相补充，辩证统一； 坚持实践是检验真理的唯一标准，并不否认逻辑证明在认识和探索真理中的作用。 承认逻辑证明的作用，并不是说逻辑证明是检验真理的标准，更不能用逻辑证明代替实践标准。 ★ 真理和价值在实践中的辩证统一 真理体现的是认识与认识对象的关系，是认识与对象相一致、相符合； 价值表示客体具有对人有用或对主体有意义的属性； 真理能够指导社会实践； 价值必须以真理为前提； 真理与价值的统一； 真理的价值表现在 真理的功能：指导实践的功能、再认识的功能、教育和激励的功能 认识世界和改造世界 ★ 认识世界和改造世界及其辩证关系 认识世界：主体能动地反映客体，获得关于事物的本质和发展规律的科学知识，探索和掌握真理； 改造世界：人类按照有利于自己生存和发展的需要，改变事物的现存形式，创造自己的理想世界和生活方式； 二者关系： 1.正确 认识世界 是有效 改造世界 的必要前提； 2.在改造世界的实践中才能不断地深化、拓展对世界的正确认识； 3.认识世界和改造世界的统一，决定了 理论与实践 必须相结合； 一切从实际出发是马克思主义 认识论 的 根本要求。 ★ 党的思想路线与马克思主义哲学认识论是统一的（三原则一标准） 思想路线，是指一个阶级及其政党作为指导思想并用以支配行动的认识路线 党的思想路线坚持了 一切从实际出发 的原则； 党的思想路线坚持了 理论联系实际 的原则； “实事求是” 这四个大字是党的思想路线的核心，也是马克思主义哲学的精髓和活的灵魂，它充分地体现了马克思主义认识论的根本原则； 党的思想路线坚持了 实践是检验真理的唯一标准； 实现理论创新和实践创新的良性互动 实践创新为理论创新提供不竭的 动力源泉； 理论创新为实践创新提供科学的 行动指南； 努力实现理论创新与实践创新的良性互动； 第三章、人类社会及其发展规律 社会基本矛盾及其运动规律 ★ 生产方式 在社会发展中的决定作用 原始社会：人类从动物界分离出来的根本动力和人类区别于动物的 根本标志； 奴隶社会：人类和人类社会得以 存在和发展 的基础； 封建社会：形成人类一切 社会关系 的基础； 资本主义社会：决定社会制度的性质和 社会制度 的更替； ★ 社会存在和社会意识的辩证关系 社会存在决定社会意识，社会存在是社会意识内容的客观来源； 社会意识是人们进行社会物质交往的 产物，并 反作用 于社会存在； 社会存在和社会意识是 辩证统一 的。 社会存在和社会意识的关系问题，是划分 历史唯物主义 和 历史唯心主义 的根本标准。 ★ 社会存在 社会存在是指社会物质生活条件的总和：地理环境、人口因素、生产方式 地理环境影响社会的发展 第一，地理环境通过对生产的影响，加速或延缓社会的发展。 第二，地理环境还可以通过对军事、政治的影响，在一定程度上制约不同国家社会的发展。 人口因素对社会发展的制约和影响作用 第一，一定数量的人口是社会物质生产的必要前提。 第二，人口状况能加速或延缓社会的发展。 生产方式在社会发展中的 决定作用 人类从动物界分离出来的根本动力和人类 区别于动物 的根本标志； 人类和人类社会得以存在和发展的基础 形成人类一切社会关系的基础 决定社会制度的性质和社会制度的更替 ★ 社会意识 社会意识是社会生活的 精神方面，是社会存在的 反映。 不同层次(社会存在的程度和特点)： 名词 定义 内容 社会心理 是低层次的社会意识，是自发的、不系统的、不定型的社会意识 人们的感知、情绪、情感、心态、习俗等(感性认识) 社会意识形式(思想体系) 是高层次的社会意识，是自觉的、系统的、定型的社会意识 包括政治法律思想、艺术、宗教、哲学、科学等(理性认识) 不同主体： 名词 定义 内容 个体意识 社会成员的个人意识 社会成员个人的自我意识和个人对生活于其中的社会环境和自然环境的反映的对象意识 群体意识 社会群体的意识 群体的自我意识和群体对其所处社会关系的反映的对象意识 是否是对特定经济基础的反映(存在的方式不同) 名词 定义 内容 个体意识 意识形态 包括政治思想、法律思想、道德、宗教、艺术、哲学和绝大部分社会科学 ，有一定的阶级性。 群体意识 非意识形态 包括自然科学、语言学、逻辑学等，没有阶级性。 分类角度 不同层次—社会存在的程度和特点 不同主体 是否是对特定经济基础的反映—存在的方式不同 意识分类 社会心理与思想体系 个体意识与群体意识 意识形态与非意识形态 ★ 社会意识——相对独立性 非完全同步性：社会意识往往落后于社会存在 ，先进的社会意识能在一定程度上预见社会发展的趋势 不平衡性：社会经济发展水平较高的国家，某些社会意识形式的发展水平可能较低 历史继承性：任何时代的社会意识都和以前时代的社会意识有联系 相互作用：社会意识各种形式之间相互作用、相互影响 能动性：社会意识对社会存在具有反作用或称能动性 ★ 生产力和生产力系统 生产力是人类在 生产实践中 形成的改造和影响自然以使其适合社会需要的物质 力量。 ① 独立的实体性因素【1704单选】 ② 运筹性的综合因素：分工协作、经济管理等【 1904单选】【 1610单选】 ③ 渗透性因素，主要指 自然科学 ④ 准备性因素，主要指 教育 生产力具有复杂的系统结构。其实体性(基本)因素包括 ： 一是劳动资料，也称劳动手段。衡量生产力水平的客观尺度是 劳动工具的状况【1910单选】 二是劳动对象。(劳动过程中被加工的东西) 三是劳动者。 ★ 生产关系和生产关系体系 生产关系是指人们在物质生产过程中结成的 经济关系。 ★ 生产资料所有制形式 起着 决定作用。 是生产劳动得以进行的前提； 决定整个生产关系的性质； 决定人们在生产中的地位及其相互关系； 决定产品的分配方式。 ★ 生产力与生产关系的辩证统一 生产力决定生产关系；生产关系反作用于生产力；生产力和生产关系之间的矛盾运动； ★ 经济基础与上层建筑之间的关系 上层建筑：政治、法律、艺术、道德、宗教、哲学等意识形态以及与这些意识形态(观念)相适应的 政治法律制度和设施(政治) 的总和 经济基础：一个社会中占统治地位的生产关系各个方面的总和 在整个上层建筑中，政治上层建筑 居 主导地位，国家政权 是核心。 经济基础决定上层建筑； 上层建筑对经济基础具有反作用； 上层建筑必须适合经济基础发展要求的规律，是无产阶级政党制定正确的路线、方针、政策的理论依据。正确理解和运用这个规律，对于我国正在进行的经济体制改革和政治体制改革以及其他方面的改革，具有重大的指导意义。 社会形态的内涵及划分 社会形态 是关于社会运动的具体形式、发展阶段和不同质态的范畴，是同生产力发展一定阶段相适应的经济基础与上层建筑的统一体。 社会 历史发展 的 决定性 与 选择性 的关系 决定性(历史决定论)：非直接的，只是作为一种趋势、一种平均数而存在；何种可能性成为现实，取决于人的自觉活动和主体选择 选择性(主体选择的作用)：人们对具体模式和途径的选择 ★ 社会形态更替的统一性和多样性 统一性： 同一社会形态的不同国家和民族的历史发展具有的 共同性、普遍性； 大致相同的生产力发展水平，大致相同的生产关系体系，大致相同的上层建筑； 多样性： 不同国家和民族的历史发展具有 不同的特点； 在经济、政治和文化发展上都有 自己的民族特色； 社会历史发展的动力 ★ 什么是社会基本矛盾，简述社会基本矛盾，是社会发展的基本动力。 社会基本矛盾 就是指贯穿社会发展过程始终，规定社会发展过程的基本性质和基本趋势，并对社会历史发展起根本推动作用的矛盾(根本动力)。 (2)社会基本矛盾是历史发展的根本动力。生产力和生产关系之间的矛盾、经济基础和上层建筑之间的矛盾是人类社会的基本矛盾。这两对矛盾制约和决定着其他各种社会矛盾，决定着整个社会的面貌，决定着社会发展的必然阶段和客观趋势，决定社会形态由低级到高级的演进。所以社会基本矛盾是社会发展的基本动力。 生产力和生产关系起着主导作用。 阶级斗争在阶级社会发展中的作用 阶级斗争是阶级社会发展的 直接动力，物质利益的对立 是阶级斗争的根源。 社会革命是阶级斗争的最高表现 社会革命和改革的实质和作用 社会革命的实质是 革命阶级推翻反动阶级 的统治，用新的社会制度代替旧的社会制度，解放生产力，推动社会发展。 社会革命根源于社会基本矛盾的尖锐化。(生产力与生产关系) 从历史上看，暴力革命 是社会革命的基本形式。 革命的特点： 由低级向高级发展的决定性手段； 人民群众在革命时期能发挥出创造历史的巨大的主动性和积极性； 革命阶级在革命斗争中受到锻炼和改造，成为 建设新社会 的基础； 社会改革是生产力与生产关系、经济基础与上层建筑矛盾运动的必然产物； 可以巩固新生的社会制度或使原有的社会制度持续存在并获得一定程度的发展； 为新社会制度的诞生作量变和部分质变的准备； 伴随着人们思想观念和价值取向的变更； ★ 社会改革的普遍性和特殊性 普遍性：存在于有史以来的各种社会制度中； 特殊性：具有根本不同的性质和特点(主动自觉、群众利益、制度内) 中国的社会主义改革是一场广泛深刻的伟大变革，从性质上看，它是 社会主义制度 的自我完善和自我发展(我国社会主义社会基本矛盾的性质和特点决定的)。 ★ 中国的改革是和 发展、稳定相统一 的过程 稳定是前提 改革是动力 发展是关键(也是目的) 人民群众在历史发展中的作用 自然属性 是指人的肉体存在及其特性；社会属性 是指在社会实践活动中人与人结成的各种社会关系(决定人的本质)。 人性和人的本质 劳动是人的本质 —— 一般本质。区别于动物的根本标志和特征，是能制造和使用生产工具从事生产劳动。 人的本质是一切社会关系的总和，有阶级性的 —— 具体本质 人的需要即人的本质 —— 具体本质 两种历史观在 历史创造者问题上 的对立 ①两种历史观：唯物史观 与 唯心史观 的对立 ②历史创造者：群众史观 与 英雄史观 的对立 ③错在哪：马克思主义哲学产生以前，占统治地位的历史观是 英雄史观。这种历史观从社会意识决定社会存在的基本前提出发，否认物质资料的生产方式是社会发展的决定力量，抹杀人民群众 的历史作用，宣扬少数英雄人物 创造历史。 人民群众之所以是历史的创造者，最根本的原因在于 人民群众 是 社会生产力的体现者。 人民群众在创造历史过程中的 决定作用 社会变革 的决定力量 物质财富 的创造者 精神财富 的创造者 无产阶级政党的群众路线 1.群众路线的基本出发点和最终归宿是：“一切为了群众”【 1604单选】 2.群众路线 是我们党的生命线和根本工作路线，也是我们党的优良传统。 3.“从群众中来，到群众中去”是无产阶级政党的 领导方法，也是群众路线的基本工作方法。 4.群众路线是我们党在革命、建设、改革时期不断取得胜利的不可缺少的重要法宝。 5.推进党的作风建设 ，核心是保持党同人民群众的血肉联系。 6.党的 根本宗旨 是全心全意为人民服务。 ★ 杰出人物的历史作用 个人在历史上的作用存在差别。有的人作用大些，可称为“历史人物”；有的人作用小些，可称为“普通个人”。 先进阶级的政治代表人物，能够提出社会发展的先进思想和主张；(周恩来) 某些占统治地位的 剥削阶级 的 代表人物，他们的一些主张和改革措施，也对社会发展起某些 促进和推动 作用；(李鸿章) 杰出的科学家、思想家、理论家、教育家、文学艺术家等的创造性活动及其成果，有力地推动了历史的发展和社会的进步。(钱学森) ★ 正确认识和评价杰出人物的历史作用 1 历史分析：必须 深入了解 他们所处的历史条件，坚持历史主义原则； 2 必须对他们做 阶级分析； 3 用必然性与偶然性 辩证统一 的观点来分析杰出人物及其历史作用； 4 对他们的历史作用要做 全面的分析与评价，既不能肯定一切，也不能否定一切。 三、马克思主义政治经济学 第四章、资本主义的本质和规律 商品经济和价值规律 ★ 商品经济得以产生的社会历史条件 商品经济 存在社会分工，生产资料和劳动产品属于不同的所有者(决定性的条件)。 最初的商品经济，是在社会生产力发展的基础上，随着社会分工和生产资料私有制的产生而出现的。 ★ 商品的二因素——使用价值和价值 使用价值是一种物品能够满足人们某种需要的属性，即物品的 有用性。反映的是人与自然之间的物质关系，是商品的 自然属性。 凝结在商品中的 无差别 的 一般人类劳动 ，即人的脑力和体力的耗费。价值反映商品生产者之间的关系，是商品的 社会属性。 使用价值 不同的商品之所以能按一定比例相交换，就是因为它们都具有价值。商品最本质的因素是 价值。 ★ 劳动二重性 具体劳动：生产一定使用价值的具体形式的劳动人与自然的关系，是劳动的自然属性(木匠的劳动生产出木器) 抽象劳动：撇开一切具体形式的、无差别的一般人类劳动，即人的脑力和体力的耗费商品生产者的社会关系，是劳动的 社会属性。 价值的唯一源泉是活劳动，即活的抽象劳动。 ★ 商品价值量的决定以及同劳动生产率的关系 商品价值量：商品的价值是凝结在商品中的无差别的一般人类劳动，价值量 是由劳动者生产商品所耗费的劳动量决定的，而劳动量则按照 劳动时间 来计量。 社会必要劳动时间：现有的社会正常的生产条件下 ，在 社会平均的劳动熟练程度和劳动强度 下制造某种 使用价值 所需要的劳动时间。 劳动生产率：是指劳动者的 生产效率或能力，通常由单位劳动时间内生产的产品数量或生产单位产品所耗费的劳动时间来表示； 社会必要劳动时间决定商品的价值量； 商品的价值量与生产商品所耗费的劳动时间成正比； 商品的价值量与劳动生产率成反比； 商品价值量 简单劳动 和 复杂劳动 的关系 简单劳动：不需要经过专门训练和培养； 复杂劳动：需要经过专门训练和培养，具有一定文化知识和技术专长的劳动者所从事的劳动； 形成商品价值的劳动，是以 简单劳动 为尺度。 ★ 货币及货币职能： 货币是在长期交换过程中形成的 固定充当一般等价物的商品。 最基本的职能：价值尺度、流通手段 其它职能：支付手段、贮藏手段、世界货币 价值规律及其作用： 价值规律是商品经济的 基本经济规律。 价值规律就是商品按照由 社会必要劳动时间 决定的 价值进行交换 的规律。 作用： 调节 社会资源的配置 促进 社会生产力的发展 引起和促进 商品生产者的分化 商品经济的基本矛盾： 私人劳动 和 社会劳动 的矛盾构成私有制商品经济的 基本矛盾。 (1)私人劳动和社会劳动的矛盾决定着商品经济的 本质及发展过程。 (2)私人劳动和社会劳动的矛盾是商品经济其他一切矛盾的基础。 (3)私人劳动和社会劳动的矛盾决定着 商品生产者 的命运。 资本主义经济制度的本质 资本主义经济制度的产生 在封建社会末期小商品生产者两极分化条件下资本主义生产关系的产生 商业的发展对资本主义生产关系的产生起了重要促进作用 资本原始积累加速了资本主义生产关系的形成 资产阶级 政治统治 的 建立 和资本主义 生产方式支配地位 的 形成，标志着资本主义制度的最终确立 资本的原始积累 所谓资本原始积累，就是生产者与生产资料相分离(用暴力手段剥夺农民的土地、掠夺货币财富)，资本迅速集中于少数人手中，资本主义得以迅速发展的历史过程。 劳动力成为商品与货币转化为资本的原因 普通货币 ：在商品交换过程中起着媒介的作用，不会发生价值的增殖 资本的货币 ：先用货币购买一定数量的商品，然后再将商品卖出，换回更多的货币，实现了价值的 增殖(剩余价值m )。 劳动力成为商品，是货币转化为资本的前提。 劳动力成为商品的基本条件 劳动力是指人的劳动能力，是人的脑力和体力的总和。 劳动者是自由人，能够把自己的劳动力当作自己的商品来支配； 没有别的商品可以出卖，劳动者丧失了一切生产资料和生活资料自由得一无所有，没有任何实现自己的劳动力所必需的物质条件。 ★ 劳动力商品的特点与货币转化为资本——劳动力的价值 是由 生产、发展、维持 和 延续劳动力 所必需的 生活必需品 的 价值 决定的； 劳动力价值的 最低界线 是由生活上 不可缺少的生活资料 的价值决定的； 还有一个重要的特点，就是它包括 历史和道德 的因素。 ★ 劳动力商品的特点与货币转化为资本——劳动力商品的使用价值 劳动力商品在使用价值上有一个很大的特点，就是它的使用价值是价值的源泉，它在消费过程中能够 创造 新的价值，而且这个新的价值比劳动力本身的价值更大。 普通商品不会创造新的价值，劳动力商品会创造价值。 资本主义生产过程是 劳动过程 和 价值增殖过程 的统一 第一步：劳动过程 第二步：价值增殖过程 资本主义所有制的含义及本质 资本主义所有制：生产资料归资本家所有的一种 私有制形式。 本质：资本的本质不是物，而是体现在物上的 资本主义生产关系。是雇佣劳动赖以存在的基础，是资本与雇佣劳动之间 剥削与被剥削 关系的体现。这就是资本主义所有制的本质。 不变资本和可变资本 生产资料形式和劳动力形式。根据这两部分 资本 在 剩余价值生产 中所起的作用不同，资本区分为不变资本和可变资本。 不变资本和可变资本——区分的意义 它进一步揭露了剩余价值的源泉和资本主义的 剥削实质。 揭示资本家对工人的剥削程度提供了科学根据，正确地表明资本主义剥削程度的是 剩余价值率( *m' = m/v* )。 剩余价值率就是 剩余价值 和 可变资本 的比率或者 剩余劳动时间 比上 必要劳动时间。 资本家要获得更多的剩余价值，可以通过两条途径： 一是提高剩余价值率，即提高对工人的剥削程度； 二是增加可变资本总量，以雇用更多工人，扩大剥削范围。 ★ 剩余价值生产的两种基本方法 剩余价值规律 是资本主义的基本经济规律。 绝对剩余价值：在雇佣工人的必要劳动时间不变的条件下，由于工作日的绝对延长而生产的剩余价值，个别企业工人由于提高劳动强度而生产的剩余价值。 相对剩余价值：在工作日长度不变的条件下，由于缩短必要劳动时间、相应延长剩余劳动时间 而生产的剩余价值，叫作相对剩余价值。 相对剩余价值生产是以 社会劳动生产率提高 为条件的。 超额剩余价值是指企业由于提高劳动生产率而使商品的个别价值低于社会价值的差额。 剩余价值转化为利润 利润是剩余价值的转化形式，它表现为全部预付资本的产物，因此，剩余价值与预付总资本的比率就是利润率。利润率是剩余价值率的转化形式。 从数量：剩余价值=利润 剩余价值率=剩余价值/可变资本 利润率=剩余价值/预付总资本 所以 ：剩余价值率大于利润率 ★ 平均利润的形成和本质 部门之间的竞争形成平均利润； 平均利润率 = 社会的剩余价值总额 ÷ 社会预付总资本； 全社会额度剩余价值在各生产部门资本家之间的重新分配，体现着整个资产阶级剥削整个工人阶级的经济关系。 平均利润进一步 掩盖了资本主义 剥削关系。 相关利润概念区分 商业资本：资本主义社会的流通领域中发生作用的职能资本 商业利润：商业资本家从事商业经营活动所获得的利润 借贷资本：从职能资本的运动过程中暂时闲置而游离出来的货币资本 ，为获取利息而借贷出去时 ，就转化为借贷资本。 利息：职能资本家使用借贷资本而让给借贷资本家的一部分剩余价值 ，它是剩余价值的特殊转化形式。 职能资本家通过使用借到的货币资本从事生产经营活动，可以获得平均利润。但是，这个平均利润不能由职能资本家独占，而必须分割为两部分：一部分是借贷资本家获得的利息，另一部分是职能资本家获得的企业利润。 银行资本：一是银行资本家自己投入的资本，即自有资本；二是银行吸收的存款，即借入资本。 银行利润：银行利润在数量上相当于银行资本家 自有资本 所获得的平均利润。 农业资本家租种土地所有者的土地，雇佣农业工人从事农业生产经营，农业工人所创造的剩余价值划分为两部分： 一部分以平均利润形式由农业资本家所占有，另一部分超额利润以地租形式由农业资本家缴纳给土地所有者。 ★ 资本积累 把剩余价值转化为资本，或者说，剩余价值的资本化，就是资本积累。 剩余价值 是资本积累的源泉。 资本主义 简单再生产 和资本主义 扩大再生产 实质 资本家用无偿占有工人创造的剩余价值，进行资本积累来增大资本的规模，以便继续占有更多的剩余价值，从而占有不断增大的资本来扩大对工人的剥削和统治。 ★ 资本积累的必然性： 追求剩余价值(利益动力) 竞争(外界压力) ★ 资本积累的后果： 资本 有机构成 的提高； 相对过剩人口 的形成； 严重的 贫富两极分化。 资本有机构成: 1.由生产的 技术水平 所决定的 生产资料 和 劳动力 之间的比例，叫作资本的 技术构成。 2.从价值形式上看，资本可分为不变资本和可变资本，这两部分资本价值之间的比例，叫作资本的 价值构成。 3.由资本的 技术构成 决定并反映技术构成变化的资本价值构成，叫作资本的有机构成，通常用c ：v来表示，其中 c 为不变资本，v为可变资本。 ★ 影响资本周转速度的快慢有两个因素 资本周转时间的长短：生产时间和流通时间越短，资本周转速度就越快。反之，生产时间和流通时间越长，资本周转速度就越慢。 生产资本的构成：依据其价值周转方式的不同，划分为 固定资本 和 流动资本 两个部分。 社会总产品 社会在一定时期所生产的 全部物质资料 的 总和。 社会总产品的实现，即社会总产品的补偿，它包括社会总产品的 价值补偿 ** 和 物质补偿。 资本主义经济危机 实质：生产相对过剩的危机。 根源：生产的社会化与生产资料私人资本主义 占有形式之间的矛盾。 资本主义政治制度和意识形态 ★ 什么是资本主义意识形态？它的本质是什么？ 资本主义意识形态是资产阶级对世界和社会的系统看法和见解，是资本主义社会中占统治地位的思想体系，它具有鲜明的阶级性。 资本主义意识形态是建立在资本主义经济基础之上的，是为资本主义私有制和雇佣劳动制度服务的，因此本质上是 维护资本主义剥削制度 的思想体系。 资本主义政治制度及其本质 资产阶级民主从来没有也不会从根本制度上保障劳动人民的根本权利和自由，劳动人民由于受 物质条件 和 资产法律条件 的限制，实际上也不可能享受他们应有的民主权利。 资本主义意识形态的历史进步性和阶级局限性 历史进步性：战胜封建社会的生产方式，推动 社会生产力大幅度发展，促进了社会进步，使人民群众享有了比在封建专制主义条件下更多的社会政治自由。 阶级局限性：维护资产阶级统治 的政治制度，法律名义上的平等掩盖着事实上的不平等，民主是 金钱操纵 下的民主。 利己主义是资本主义意识形态的核心 利己主义成为资本主义道德的基本原则 第五章、资本主义的发展及其趋势 资本主义从自由竞争到垄断 资本主义的发展经历了两个阶段：自由竞争资本主义和垄断资本主义。 生产集中与垄断的形成 所谓垄断，是指少数资本主义大企业为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制。 资本主义促进了生产力发展和生产社会化程度的提高，这种社会化生产力的发展又从客观上要求生产和资本不断扩大规模、日益集中。这是生产力发展的内在要求，也是垄断产生的物质条件和基础。 生产集中：生产资料集中于少数大企业 资本集中：大资本吞并小资本 垄断产生的原因 为了获得高额利润 形成对竞争的限制 为了避免两败俱伤 垄断和竞争的区别 不同角度 自由竞争 垄断条件下的竞争 竞争目的 主要是为获得更多的利润或超额利润，不断扩大资本的积累 为获取高额垄断利润，并不断巩固和扩大自己的垄断地位和统治权力 竞争手段 主要运用经济手段，如通过改进技术、提高劳动生产率、降低产品成本 除了采取各种形式的经济手段外，还采取非经济的手段，使竞争变得更加复杂、激烈 竞争范围 主要是在经济领域 ，而且主要是在国内市场 国际市场上的竞争越来越激烈 ，不仅经济领域的竞争多种多样 ，而且还扩大到经济领域以外进行竞争 特征 / 规模大、时间长、手段残酷、程度激烈，而且具有更大的破坏性 垄断利润和垄断价格 垄断利润 获得的大大超过平均利润的高额利润 垄断资本的实质在于获取垄断利润 来自无产阶级和其他劳动人民所创造的剩余价值 垄断价格 垄断利润主要是通过 垄断组织制定的垄断价格 来实现的 垄断高价是指垄断资本在出售自己产品时规定的超过商品价值和生产价格的垄断价格 垄断低价是指垄断资本在购买生产资料时规定的低于其价值和生产价格的垄断价格 ★ 垄断利润的来源 加强对 其他国家劳动人民 的剥削和掠夺从国外获取利润； 对 本国 无产阶级和其他劳动人民剥削的加强； 国家政权进行有利于垄断资本的再分配，从而将 劳动人民创造的国民收入 的一部分变成垄断资本的收入； 通过垄断高价和垄断低价来控制市场获得一些 其他企业 特别是非垄断企业的利润。 (速记：本国人民+企业+他国人民+国民收入) 垄断不会消灭竞争的原因 首先，竞争是商品经济存在和发展的 基本条件和核心机制，有商品经济就必然存在竞争。 其次，从垄断资本主义社会中现实的经济主体来看，虽然在某些部门存在着垄断组织，但也还存在未形成垄断的部门及大量的非垄断企业，这些经济主体之间必然存在着激烈的竞争关系，即使是已形成垄断的部门，也绝大部分是几个垄断企业并存，它们之间本质上依然是相互竞争的关系。 要点速记 ：垄断来自于竞争 ，但没有消除竞争 ，因为经济条件、维持条件(竞争)、生 产条件(复杂多样)都没有改变。 重要的垄断组织形式 卡特尔，即通过生产或经营同类产品的一些大型垄断企业之间较稳定的垄断协议形成的、在生产或流通的某个或某些环节实行垄断的组织形式。 辛迪加，即把一些在法律上和生产上还是独立的大垄断企业在流通环节上统一起来 ，进行垄断经营的组织形式。 托拉斯 ，即垄断了某种商品生产和经营全过程的独立的大型垄断企业。 康采恩 ，即由一两个特大型垄断企业为核心 ，联合了各方面各领域一大批企业所形成的超大型垄断集团。 20世纪后半期：第二次世界大战后，随着生产社会化与国际化程度的提高，形成了新的垄断组织形式和垄断资本国经济组织的载体——跨国公司。 ★ 垄断资本主义的基本经济特征 两统治：垄断 在经济生活中占统治地位；金融资本 和 金融寡头 的统治。 两瓜分：瓜分世界 的资本家国际垄断同盟已经形成。最大资本主义大国已把世界上的领土瓜分完毕。 一输出：资本输出有了特别重要的意义。 资本输出：垄断阶段资本输出的必要性 ，在于“过剩资本”的出现 ，是资本输出的财力基础。 垄断资本主义的基本经济特征——金融资本与金融寡头 银行垄断资本 已成为社会经济生活中的 万能垄断者。 金融资本：垄断资本主义国家中社会经济生活各个方面实际上的统治者(主宰者——金融寡头) 国家垄断资本主义的形成 构成：国家政权和私人垄断资本融合 时间：第二次世界大战后 原因：垄断资本通过制定垄断价格获得 高额垄断利润，收入分配和财产的两极分化越来越严重，阶级矛盾不断尖锐化，而这势必引起社会的不安定，进而危及资本主义国家政权的稳固。 实质：国家垄断资本主义从 维护和巩固 资本主义经济制度，维护垄断资产阶级的整体利益和长远利益出发，借助国家政权的力量直接参与和干预社会经济生活，以保证垄断资产阶级获取高额垄断利润。 战后国家垄断资本主义大发展的原因 大规模经济建设：无法满足大规模经济建设所需要的巨额资金 公共设施：无能为力或不愿进行投资建设 科学研究项目：不愿涉足的领域 生产过剩：难以解决 社会化大生产：要求国家出面 经济利益关系：国家的再分配功能也越来越重要 要点速记 ：私人垄断资本力量不足+意愿缺失+生产过剩问题+国家的再分配功能。 ★ 国家垄断资本主义的主要形式有五种 国家直接掌握的垄断资本 国家和私人资本在企业内部的结合 国家和私人资本在企业外部的结合 宏观调节：财政政策、货币政策等经济手段 微观规制：法律手段规范市场秩序 ★ 资本主义国家对经济的 调控方式与手段 直接调节、控制和介入 间接调节与控制：主要是运用经济手段 四大市场：商品市场、资本市场、劳动力市场和外汇市场 国家垄断资本主义 宏观经济调控 的主要政策 财政政策：通过财政把一部分国民收入集中起来进行分配，从而对生产资源的使用、个人收入的分配以及整个宏观经济运行都有巨大的影响。财政收入与财政支出 货币政策：货币币值的稳定，是市场经济正常发展运行的必要条件。 一是对利率的调节，二是对货币流通量的调节 如何利用利率来实现对宏观经济的调节 调节过程：在经济过热时，适当提高利率，给经济降温。 相反，在需要刺激经济发展、走出萧条与不景气阴影的时候，则适当降低利率来刺激投资与消费。这就是逆经济方向的货币政策调节。 ★ 发达市场经济国家在调控货币量方面的三大手段或三个法宝 公开市场业务 最低准备金率政策 再贴现率政策 ★ 国家垄断资本主义的实质与作用 实质：国家垄断资本主义从 维护和巩固资本主义经济制度，维护 垄断资产阶级 的 整体利益和长远利益出发，借助 国家政权 的力量 直接参与和干预 社会经济生活，以保证垄断资产阶级获取高额垄断利润。 积极作用：社会生产力发展；突破私人垄断资本的狭隘界限；劳动人民生活水平有所改善和提高；加快国民经济的现代化进程。 消极作用：没有根本改变垄断资本主义的性质，更有利于维护资本主义制度。 垄断资本在世界范围的扩展的基本形式 商品资本的输出 借贷资本输出 生产资本输出 当代垄断资本主义国家更多地采取比较缓和和隐蔽的手法，打着所谓 援助 的旗号实现其对发展中国家的剥削、控制。 ★ 经济全球化的含义、原因、内容 含义：经济全球化是指在生产不断发展、科技加速进步、社会分工和国际分工不断深化、生产的社会化和国际化程度不断提高的情况下，世界各国、各地区的经济活动越来越超出某一国家和地区的范围而相互联系、相互依赖的过程。经济全球化的本质是 资源配置 的 国际化。 原因：科学技术的进步和生产力的发展；跨国公司的发展(自由程度大大提高)；各国经济体制的变革(资本流动的大幅增加)。 内容：国际分工进一步深化，企业 生产经营 全球化；贸易全球化；金融全球化； ★ 经济全球化的影响 经济全球化为发展中国家提供先进技术和管理经验。 经济全球化为发展中国家提供更多的就业机会。 经济全球化推动发展中国家国际贸易发展。 经济全球化促进发展中国家跨国公司的发展。 发达国家与发展中国家的差距在扩大 环境恶化与经济全球化有可能同时发生 国家内部和国际社会都出现不同程度的治理危机 爆发全球性经济危机的风险不断增加 ★ 第二次世界大战后资本主义新变化的表现 ★ 新变化的原因和实质 原因： 生产力：科学技术的发展 生产关系调整：工人斗争、 政府干预 上层建筑变化：经济基础的要求 实质： 资本主义的自我调节与完善，都是在资本主义制度框架内进行的(经济基础仍然是私人占有制) 当代资本主义借鉴社会主义所进行的某些 社会改良(在资本主义社会的胎胞里孕育和生长着的“新的社会因素”) 2008年国际金融危机以来资本主义的矛盾与冲突 经济发展“失调” 政治体制“失灵” 社会融合机制“失效” 原因和根源 ：资本主义基本矛盾 资本主义的历史地位和发展趋势 与封建社会相比 ，资本主义显示了巨大的历史进步性 资本主义将科学技术转变为强大的生产力 资本追求剩余价值的内在动力和竞争的外在压力推动了社会生产力的迅速发展 战胜封建社会自给自足的小生产的生产方式，推动了社会生产力的迅速发展，促进了社会进步 资本主义的历史进步性并不能掩盖其自身的 局限性 资本主义基本矛盾阻碍社会生产力的发展 资本主义制度下财富占有两极分化 资本家阶级支配和控制资本主义经济和政治的发展和运行，不断激化社会矛盾和冲突。 社会主义代替资本主义是一个 长期的历史过程 任何社会形态的存在都有相对稳定性，从产生到衰亡都要经过相当长的时间跨度。 资本主义发展的不平衡性决定了过渡的长期性。 显示出生产关系对生产力容纳的空间。 马克思指出：“ 发展社会劳动的生产力，是资本的历史任务和存在理由。资本正是以此不自觉地创造着一种更高级的生产形式的物质条件。 ” 四、科学社会主义 第六章、社会主义的发展及其规律 社会主义五百年的历史进程 空想社会主义的发展经历了三个阶段 第一国际与巴黎公社 马克思和恩格斯受世界上第一个 无产阶级政党 “共产主义者同盟”的委托起草并于1848年2月发表的《共产党宣言》，是社会主义思想史上的 第一个纲领性文件，它标志着科学社会主义理论公开面世。 1864年 ，国际工人协会(第一国际) 应运而生。马克思是第一国际的灵魂。在马克思指导下，第一国际大力支援各国的工人运动，支持反封建的民主运动和民族解放运动，影响日益扩大。 1871年爆发的 巴黎公社革命，是第一国际精神的产儿，是 无产阶级夺取政权 的 第一次伟大尝试。这场革命是在法国同普鲁士之间发生战争、民族矛盾和阶级斗争激化的情况下爆发的。 ★ 为什么说无产阶级革命是人类历史上最广泛、最彻底、最深刻的革命 最广泛：为绝大多数人谋利益的运动 最彻底：彻底消灭一切阶级剥削和阶级统治的革命；消灭私有制、建立公有制 最深刻：不断前进的历史进程 十月革命胜利与第一个社会主义国家的建立 十月革命实现了社会主义从理想到现实的伟大飞跃，开辟了人类历史的新纪元。它从根本上推翻了人剥削人、人压迫人的制度，建立起世界上第一个人民当家作主的社会主义国家。 此后 ，社会主义作为一种崭新的社会形态和社会制度登上历史舞台，引领着人类社会的发展方向。 社会主义在苏联一国的实践 **苏维埃俄国(列宁、斯大林)**是世界上第一个社会主义国家。 列宁提出社会主义可能首先 在少数甚至在单独一个资本主义国家 内获得胜利。 1921 年春，苏维埃俄国击退了外国武装干涉，平息了国内叛乱，开始了和平建设时期，实行新经济政策。社会主义苏联模式——斯大林 社会主义从一国到多国 第二次世界大战结束后，社会主义在世界范围内获得大发展，在欧洲、亚洲、拉丁美洲，先后有一批国家走上社会主义道路。 新时代中国特色社会主义 科学社会主义一般原则 ★ 科学社会主义一般原则及其主要内容 无产阶级革命的一般形式(即基本形式)：暴力革命 无产阶级政党的组织原则：民主集中制 社会主义社会要对社会生产进行有计划的指导和调节：按劳分配 社会主义的根本和首要的任务：解放和发展生产力 ★ 正确把握科学社会主义一般原则 必须始终坚持科学社会主义一般原则，反对任何错误倾向； 要善于把科学社会主义一般原则与 本国实际相结合，创造性地回答和解决革命、建设、改革中的重大问题； 紧跟时代和实践的发展，在不断总结新鲜经验中进一步 丰富和发展 科学社会主义一般原则； 在实践中探索现实社会主义的发展规律 社会主义首先在经济文化相对落后的国家取得胜利的原因 这些国家已具备了一定程度的社会化生产力，这是发生社会主义革命、建立社会主义社会的物质基础； 客观形势和主观条件，使得它们在特定的历史条件下能够获得革命的成功； 经济文化相对落后国家建设社会主义的长期性 生产力发展状况的制约 经济基础和上层建筑发展状况的制约 国际环境的严峻挑战 社会主义发展道路的探索和对社会主义建设规律的认识，需要一个长期的过程 ★ 社会主义发展道路多样性的原因 各个国家的生产力发展状况和社会发展阶段 历史文化传统的差异性 时代和实践的不断发展，是造成社会主义发展道路多样性的现实原因 ★ 社会主义在曲折中前进的原因 同一切新生事物一样，其成长过程必然不会一帆风顺； 对基本矛盾的认识及其矛盾的运动发展是一个长期曲折的过程； 世界经济政治形势 错综复杂的发展变化； ★ 马克思主义政党是新型的革命政党 马克思主义政党是科学社会主义与工人运动相结合的产物。 产生的条件：一是工人运动的发展，二是科学社会主义理论的传播。 马克思主义政党是工人阶级先锋队。 马克思主义政党是为 实现共产主义 而奋斗的党。 马克思主义政党是为 人民群众谋利益 的党。 马克思主义政党是按照 民主集中制 原则组织起来的团结统一的党。 第七章、共产主义崇高理想及其最终实现 共产主义社会的基本特征 社会生产力高度发展和物质财富极大丰富； 实行社会公有制和按需分配 经济的计划调节管理和商品经济的消失 阶级的消灭和国家自行消亡 精神境界极大提高 人的自由而全面发展 全人类的彻底解放 社会生产力的高度发展 ，是实现共产主义社会的根本条件和基础。 “各尽所能 ，按需分配”是共产主义社会的显著特征 彻底消灭阶级 ，只能在共产主义社会实现 ★ 精神境界极大提高的表现 摆脱了封建的、保守的思想观念的束缚，又摒弃了以利己主义为核心的资产阶级思想意识。 树立了以集体主义为核心的共产主义 人生观、价值观和道德观。 自觉劳动、遵守纪律，团结互助，诚实友爱，从社会公共利益出发。 共产主义社会的两个阶段：社会主义社会，共产主义社会； 社会主义社会是 共产主义社会的初级阶段，它与共产主义社会具有根本性质上的一致性。广义的共产主义社会包含 社会主义社会 和 共产主义社会。 实现共产主义是人类最伟大的事业 实现共产主义理想是广大人民群众的共同愿望； 实现共产主义，必须找到现实的阶级力量，这就是现代工人阶级或无产阶级； 无产阶级的解放与全人类的解放是完全一致的 (1)共产主义事业是崇高理想与科学理想的统一。 (2)共产主义伟大事业的实践。 社会主义是实现共产主义的必由之路 社会主义是共产主义的低级阶段 高级阶段是建立在低级阶段基础上的，没有低级阶段的发展，也不会有高级阶段的到来 坚持社会主义道路，坚持社会主义制度，是我们在当代世界为共产主义事业作出的重要贡献 共产主义远大理想和中国特色社会主义共同理想 远大理想：坚定共产主义 共同理想：建设中国特色社会主义 ★ 正确认识和把握共产主义远大理想与中国特色社会主义共同理想 首先，从时间上看，远大理想与共同理想的关系是最终理想与阶段性理想的关系。 其次，从层次上看，远大理想与共同理想的关系是最高纲领与最低纲领的关系。 我们党的最高理想和最终目标是 实现共产主义，这也是我们党的最高行动纲领。 最后，从范围来看，远大理想与共同理想的关系也是 全人类理想 与 全体中国人民理想 的关系。 ★ 共产主义远大理想和中国特色社会主义共同理想的关系 远大理想是现阶段共同理想的 奋斗目标 现阶段的共同理想是远大理想的 坚实基础 二者相辅相成，相互促进，有机联系和统一 坚定理想信念，投身新时代中国特色社会主义事业 习近平指出：“青年是标志时代的最灵敏的晴雨表，时代的责任赋予青年，时代的光荣属于青年。” 新时代的青年，必须坚定理想信念。习近平指出：“青年时代树立正确的理想、坚定的信念十分紧要，不仅要树立，而且要在心中扎根，一辈子都能坚持为之奋斗。” 当代青年要积极投身新时代中国特色社会主义事业，勇做担当中华民族伟大复兴大任的时代新人。"},{"title":"使用 VuePress2 搭建网站","path":"/2023/11/03/VuePress2搭建网站/","content":"本文基于 VuePress v2.0.0-rc7 版本，使用默认的内置主题 简介 VuePress 是一个以 Markdown 为中心的静态网站生成器。你可以使用 Markdown 来书写内容（如文档、博客等），然后 VuePress 会帮助你生成一个静态网站来展示它们。 一个 VuePress 站点本质上是一个由 Vue 和 Vue Router 驱动的单页面应用 (SPA)。 路由会根据你的 Markdown 文件的相对路径来自动生成。每个 Markdown 文件都通过 markdown-it 编译为 HTML ，然后将其作为 Vue 组件的模板。因此，你可以在 Markdown 文件中直接使用 Vue 语法，便于你嵌入一些动态内容。 在开发过程中，我们启动一个常规的开发服务器 (dev-server) ，并将 VuePress 站点作为一个常规的 SPA。如果你以前使用过 Vue 的话，你在使用时会感受到非常熟悉的开发体验。 以上摘自 VuePress 的官网。 构建 官方提供了可以通过 StackBlitz 在浏览器里直接使用 VuePress。 创建项目 创建项目有两种方式： npm 创建手动创建1npm init vuepress vuepress-site123456789mkdir vuepress-site &amp;&amp; cd vuepress-site# 初始化项目npm init# 安装 vuepress、打包工具和主题npm install -D vuepress@next @vuepress/bundler-vite@next @vuepress/theme-default@next# 创建 docs 文件夹和配置文件夹mkdir docs &amp;&amp; mkdir docs/.vuepress# 创建 VuePress 的配置文件touch docs/.vuepress/config.js 这样，一个简单的 VuePress 的网站就基本成型了，该文件夹的结构基本如下（README文件后面会讲，先让它在这里），接下来添加一些内容，然后运行起来看看效果如何。 123456├─ docs│ ├─ .vuepress│ │ └─ config.ts│ └─ README.md├─ .gitignore└─ package.json docs/.vuepress 是 vuepress 存放配置文件和公共静态资源的路径。 后文中我们引用的静态资源路径统一位于 docs/public/ 目录中，这也是官方根据相对路径默认查找的目录。 配置文件支持 ts 和 js，推荐使用 ts 获得更好的提示。 修改 package.json 添加脚本 添加以下脚本，便于本地运行/构建网站。 123456789&#123; &quot;scripts&quot;: &#123; &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;, &quot;docs:build&quot;: &quot;vuepress build docs&quot;, &quot;dev&quot;: &quot;set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vuepress dev docs&quot; &quot;build&quot;: &quot;set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vuepress build docs&quot;, &#125;, ...&#125; 如果使用的 NodeJs 版本较高，运行时可以设置 set NODE_OPTIONS=--openssl-legacy-provider 后再运行。 编写网站主页 一个好的网站内容是不可或缺的一部分。在 VuePress 中，markdown 源文件和网站的配置文件约定都存在项目的 docs 目录中，在此之外的文件 VuePress 默认不会读取。关于主页的配置可以阅读一下 官方文档说明。 浪子推荐主页直接放在 docs 的根路径中，名称可以是 README.md 或者 index.md 任选其一，至于原因，请查看官网这段描述。接下来我们补充主页内容，以 docs/index.md 为例(可以把 README.md 文件重命名或直接删除新建)： docs/index.md12345678910111213141516171819---# 标记主页home: true# logo，实际文件位于 docs/public/image/logo.pngheroImage: /image/logo.pngtagline: 标语，如果设置会覆盖配置文件中的站点描述 description# 主页可点击按钮，点击跳转对应页面actions: - text: 开始 → link: 相对于 docs 的文章链接，当然，你也可以放置一个 URL# 复制官网的例子features: - title: 简洁至上 details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。 - title: Vue 驱动 details: 享受 Vue 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。 - title: 高性能 details: VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。--- 这样，一个简单的主页就配置完成了，接下来我们对 docs/.vuepress/config.ts 文件进行修改，这是网站的配置文件。 docs/.vuepress/config.ts12345678910111213export default &#123; // 网站 favicon // 该图片的路径就是 docs/public/image/logo.png head: [[&quot;link&quot;, &#123;rel: &quot;icon&quot;, href: &quot;/image/logo.png&quot;&#125;]], // 网站的标题和描述 title: &quot;我的 VuePress 站点&quot;, // 如果主页配置了 tagline 选项，则该项配置被覆盖 description: &quot;使用 vuepress2 搭建的小站点，会是什么效果呢？真令人期待！&quot;, // 默认的打包工具 bundler: viteBundler(), theme: defaultTheme(),&#125; 然后运行 npm run dev 并 访问 http://localhost:8080 查看效果。 进阶配置 单语言站点配置 docs/.vuepress/config.ts1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465export default &#123; // base 的作用请看官网描述：https://v2.vuepress.vuejs.org/zh/guide/deployment.html#github-pages // base 只和部署有关，本地运行时可以忽略 base: &quot;/repo/&quot;, // 本地启动时预览的端口，默认 8080，可以自己修改 port: 8080, // favicon 可以设置在不同的语言中 head: [[&quot;link&quot;, &#123;rel: &quot;icon&quot;, href: &quot;/images/logo.png&quot;&#125;]], bundler: viteBundler(), // 主题配置 theme: defaultTheme(&#123; // 返回首页的路径，默认 /，一般不需修改 home: &quot;/home/&quot;, // 也可以设置为一个 URL，例如：https://gitlab.com/foo/image.jpg logo: &quot;/image/logo.png&quot;, // 仓库配置，可以是 github、gitee、gitlab 等，会自动识别 // GitHub 仓库，也可以设置为一个 URL，例如：https://gitlab.com/foo/bar repo: &quot;username/repo&quot;, // 源文件所在分支 docsBranch: &quot;dev&quot;, // 源文件所在的仓库的目录名称 docsDir: &quot;docs&quot;, // 替换一些英文的默认值 // 默认值： &quot;Edit this page&quot; editLinkText: &quot;帮助作者修改此页！&quot;, // 默认值： &quot;Last Updated&quot; lastUpdatedText: &quot;最后修改&quot;, // 默认值： &quot;Contributors&quot; contributorsText: &quot;贡献者&quot;, // 默认值： &quot;toggle color mode&quot; toggleColorMode: &quot;昼夜模式切换&quot;, // 默认值： &quot;Back to home&quot; backToHome: &quot;返回首页&quot;, // 侧边栏配置，显示列表深度 1，包含 &lt;h2&gt;，默认值 2 &lt;h3&gt; sidebarDepth: 1, // 侧边栏显示内容 sidebar: [ &#123; // 大标题，相当于分组，children 中的文档都属于此分组，该标题默认不可点击 text: &quot;指南&quot;, // 该项配置 children 的文章目录是否折叠，默认为 false 即不折叠，为 true 时自动折叠，不可与 link 共存 collapsible: true, children: [ &quot;/guide/index.md&quot;, &quot;/guide/如何学好算法.md&quot;, &quot;/guide/如何学好数据结构.md&quot;, ], &#125;, &#123; // 只要设置了 link 选项，text 就可以有点击事件了，点击跳转 link 配置的路径 text: &quot;进阶&quot;, // 不可与 collapsible 共存 link: &quot;/advanced/算法1.md&quot;, children: [ &quot;/advanced/数据结构.md&quot;, &quot;/advanced/算法1.md&quot;, ], &#125;, ], &#125;)&#125; 此时，目录结构应为： 1234567891011121314├─ docs│ ├─ .vuepress│ │ └─ public│ │ └─ config.js│ ├─ guide│ │ └─ index.md│ │ └─ 如何学好算法.md│ │ └─ 如何学好数据结构.md│ ├─ advanced│ │ └─ 数据结构.md│ │ └─ 算法1.md│ └─ index.md├─ .gitignore└─ package.json 多语言站点配置 多语言配置也很简单，下面只给一个示例，不再进行额外的说明了。另外，本文写的都是较为简单的配置，也可以编写函数完成高级配置，请自行查询资料。 docs/.vuepress/config.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990export default &#123; // base 的作用请看官网描述：https://v2.vuepress.vuejs.org/zh/guide/deployment.html#github-pages // base 只和部署有关，本地运行时可以忽略 base: &quot;/repo/&quot;, // 本地启动时预览的端口，默认 8080，可以自己修改 port: 8080, // 多语言配置使用 locales 为每种语言设置不同的信息，只要配置了该项，网站上方导航栏中会自动出现语言选项 // 语言键值对配置，不重复即可，该项配置只是为了说明网站支持多少种语言，具体的显示效果需要配置主题中的 locales 使用 // 可以使用的字段有 lang、title、descript、head locales: &#123; // / 较为特殊，在 vuepress 中是特例，网站默认使用的语言配置 &quot;/&quot;: &#123; lang: &quot;zh&quot;, title: &quot;多语言配置——中文大标题&quot;, description: &quot;爆竹声中一岁除 春风送暖入屠苏&quot;, head: [] &#125;, // 推荐使用 / 结尾，否则导航进入时可能出现 404 &quot;/en/&quot;: &#123; lang: &quot;en&quot;, title: &quot;English Language Title&quot;, description: &quot;i dont speak english&quot;, head: [] &#125; // 其它语言 ... &#125;, bundler: viteBundler(), theme: defaultTheme(&#123; // 也可以设置为一个 URL，例如：https://gitlab.com/foo/image.jpg logo: &quot;/image/logo.png&quot;, // 仓库配置，可以是 github、gitee、gitlab 等，vuepress 会自动识别 // GitHub 仓库，也可以设置为一个 URL，例如：https://gitlab.com/foo/bar repo: &quot;username/repo&quot;, // 仓库中源文件所在分支 docsBranch: &quot;dev&quot;, // 仓库中源文件的所在目录 docsDir: &quot;docs&quot;, // 侧边栏配置，显示列表深度 1，包含 &lt;h2&gt;；默认值 2 &lt;h3&gt; sidebarDepth: 1, // 如果是多语言，主题中也可以配置 locales 为不同的语言设置个性的标签。 // 这里根据上面的 locales 的键来配置不同语言的标签 locales: &#123; // 中文配置 &quot;/&quot;: &#123; selectLanguageName: &quot;简体中文&quot; // 替换一些英文的默认值 // 默认值： &quot;Edit this page&quot; editLinkText: &quot;帮助作者修改此页！&quot;, // 默认值： &quot;Last Updated&quot; lastUpdatedText: &quot;上次修改于&quot;, // 默认值： &quot;Contributors&quot; contributorsText: &quot;贡献者&quot;, // 默认值： &quot;toggle color mode&quot; toggleColorMode: &quot;昼夜模式切换&quot;, // 默认值： &quot;Back to home&quot; backToHome: &quot;返回首页&quot;, // 侧边栏 sidebar: [ &#123; text: &quot;指南&quot;, children: [ &quot;/guide/index.md&quot;, &quot;/guide/如何学好算法.md&quot;, &quot;/guide/如何学好数据结构.md&quot;, ], &#125;, ] &#125;, // 英文配置 &quot;/en/&quot;: &#123; selectLanguageName: &quot;English&quot; sidebar: [ &#123; text: &quot;Guide&quot;, children: [ &quot;/guide/index.md&quot;, ], &#125;, ] &#125; // other ... &#125; &#125;),&#125; 此时，目录的结构为： 123456789101112131415161718├─ docs│ ├─ .vuepress│ │ └─ public│ │ └─ config.ts│ ├─ en│ │ └─ guide│ │ │ └─ index.md│ │ └─ index.md│ ├─ guide│ │ └─ index.md│ │ └─ 如何学好算法.md│ │ └─ 如何学好数据结构.md│ ├─ advanced│ │ └─ 数据结构.md│ │ └─ 算法1.md│ └─ index.md├─ .gitignore└─ package.json VitePress 引用 VitePress 官网的一段话VitePress 灵感来源于 VuePress。最初的 VuePress 基于 Vue 2 和 webpack。借助 Vue 3 和 Vite，VitePress 提供了更好的开发体验、更好的生产性能、更精美的默认主题和更灵活的自定义 API。VitePress 和 VuePress 之间的 API 区别主要在于主题和自定义。如果使用的是带有默认主题的 VuePress 1，迁移到 VitePress 应该相对简单。VuePress 2 我们也投入了精力，它也支持 Vue 3 和 Vite，与 VuePress 1 的兼容性更好。但是，并行维护两个 SSG 是难以持续的，因此 Vue 团队决定将重点放在 VitePress，作为长期的主要 SSG 选择推荐。 由此可以看出，VitePress 的功能更加丰富，效果更加美观。当然，如果你的动手能力较强，使用 VuePress 也可以定制自己更加喜欢的主题。本文不进行过多比较，如何选择可以查看各自官网文档的展示效果，接下来简单的提下一些配置和概念的不同（都是在使用 默认主题 的前提下）。 在 VitePress 中： 主页的配置项 不会与配置文件中的配置（config.ts）重复而发生覆盖，各自独立。 VitePress 的静态资源目录是 ./docs/public 而不是 ./docs/.vitepress/public(当然该目录两者都支持自定义)。 VitePress 默认主题对于 md 的支持较多，例如数学公式、Github 标签支持、代码块的聚焦等（部分需要配置开启），还支持 自定义选项。 VitePress 的国际化配置更加简单直观，不区分网站的 locales 和主题的 locales 配置。 VitePress 的主页和以 / 结尾的文件夹在进行路由时默认寻找 index.md（不要使用 README.md），项目名称、摘要、宣传标语都在该文件指定，主页中不支持定义页脚信息。 VitePress 的定义 sidebar 侧边栏目录时推荐不加 .md 后缀。 VitePress 的配置文件中一个简单配置可能要写较多内容，而在 VuePress 中可以轻松配置（例如 Github）。 进行 VitePress 的配置时，同样推荐使用 ts + export default defineConfig(&#123;&#125;) 的方式获取来自提供支持的 IDE 的智能提示。 基于 VitePress 1.x 版本进行对比。","tags":["vuepress"],"categories":["瞎折腾"]},{"title":"解锁数字媒体：认识视频音频格式以及编解码","path":"/2023/10/17/视频编码格式/","content":"最近使用了 OBS Studio 录制了视频，忽然发现自己是个菜鸡，后来了解了一下流媒体视频的相关知识。 一、视频 视频格式 通常，判断一个文件最直观的方式就是看该文件的后缀。例如 MP4, MOV, MKV, TS 以及微软的 WMV 等，它们一般被称为视频封装格式。可以把它们理解成一个 container 或者说一个盒子，可以装入视频帧、音频、元数据、字幕等信息。 MKV：MKV 是一种非常灵活的容器，兼容 OBS Studio 支持的所有音频和视频编码器。它具有故障保护功能，即由于断电或其他原因导致的未完成录制仍可播放和恢复。不过，它在编辑软件中的支持度不高，在编辑软件中使用时可能需要重新复用。编辑软件支持不佳。 MP4/MOV：MP4 是互联网视频的事实标准。MOV 是其姊妹格式，在编解码器兼容性方面略有不同，主要用于 Mac 平台。MP4/MOV 需要对文件进行 &quot;最终处理 &quot;才能播放，如果写入过程因故中断，文件可能无法恢复。因此不建议直接录制成 MP4/MOV。编辑软件提供出色的支持。 片段式/分片 MP4/MOV：片段化是一种将 MP4/MOV 文件写成独立块的方法，这样文件就不需要最终处理就能使用，使其具有比 MKV 更高的兼容性，同时具有类似的抗错能力。当使用无损或未压缩音频时，可能需要重新复用才能在某些编辑套件中正常工作。编辑软件有很好的支持。 FLV：FLV 是 RTMP 中使用的容器。它对编解码器的支持非常有限（H.264/AAC），而且只支持单音轨。它的弹性与 MKV 相似，但很少得到编辑软件的支持。编辑软件支持不佳。 MPEG-TS/HLS (M3U8)：MPEG-TS 用于各种流媒体协议，其恢复能力与 MKV 相似，但对编解码器的支持较少。在使用 HLS 时，视频是以单独的 .ts 文件加上播放列表的形式分段编写的，播放列表会指示播放器如何读取文件。这主要用于互联网流媒体。MPEG-TS 在编辑软件中得到了很好的支持，HLS 在编辑软件方面的支持很差甚至没有。 视频编解码器 视频编码器可以简单理解成专门用来压缩视频的，解码器正好相反。通常，一个视频若不经过编码器处理的话，视频的体积往往比较大，由于互联网的带宽限制，视频体积当然要越小越好，越利于网络传输。所以封装为指定的视频格式时都会采用一些技术进行压缩。同一种 视频格式可以使用 不同 的编解码器进行编解码。 常见的视频编解码器有如下几种： AVC/H.264 AVC（Advanced Video Coding）一种用于视频会议的低比特率可视通信标准。H.264 由 MPEG 和 ITU-T VCEG 共同开发。H.264 一种基于 MPEG-4 的国际电信联盟视频压缩标准。H.264 非常流行，尤其适用于蓝光等高清视频。利用当今芯片的优势，H.264 可以压缩更大的帧尺寸。此外，还支持分辨率较低的 MPEG-2 质量，但数据传输率大大降低。 H.264 是 OBS 的默认编解码器。它的历史相当悠久（2004 年标准化），但在网络视频中无处不在，几乎可以在所有设备或软件上播放。对于大多数流媒体服务来说，它是目前唯一受支持的编解码器。同时大多数编辑软件都能提供出色的支持。 HEVC/H.265 HEVC（High Efficiency Video Coding） 国际电信联盟（ITU）和国际标准化组织（ISO）联合开发的超高清视频压缩标准。HEVC 也称为 H.265，支持 8K 分辨率。根据视频内容的不同，HEVC 能以 H.264/AVC 编码一半的比特率提供相同的视频质量，从而能以更少的带宽传输高质量视频，或以相同的带宽传输更高质量的视频。 H.264（2013 年标准化）的继承者，在相同比特率/文件大小的情况下提供更好的质量。不过，由于其许可协议限制较多，网络流媒体并未广泛支持或使用它。它仅通过 OBS Studio 中的硬件编码器（英伟达 NVENC、AMD AMF、英特尔 QSV、苹果 VT）支持。编辑软件有较好的支持。 AV1 AOMedia Video 1 开放媒体联盟（AOMedia）的一种视频编解码器。该联盟成立于 2015 年，AV1 于 2018 年首次发布。AV1 旨在取代 VP9 编解码器，成为 IETF 互联网视频编解码器（NETVC）标准。思科的 Thor 编解码器和 Xiph.Org 基金会的 Daala 编解码器的元素也包含在内。AV1 的主要竞争对手是 HEVC/H.265，与之相比，AV1 完全免收版权费，而且 AV1 的功能都经过仔细的专利侵权审查。 OBS Studio 支持的最新编解码器（2019 年标准化），与 HEVC 相比，质量/文件大小均有改善。软件编码可使用 SVT-AV1/libaom-av1，但需要高端 CPU 进行实时压缩。也可通过 AMD（RX 7000 系列）、NVIDIA（RTX 40 系列）和英特尔（Arc）最新 GPU 上的硬件编码器进行编码。编辑软件尚不支持。 SVT-AV1 是开源的 AV1 编解码器实现。英特尔和 Netflix 自2018年8月以来一直在就 SVT-AV1 编解码器框架进行合作。团队一直密切合作进行 SVT-AV1 的开发、交流架构决策；实施新工具并改善压缩效率。 ProRes Apple 的编解码器，适用于不需要考虑文件大小的专业用途，可根据质量需求提供各种配置文件。通过 Mac 上的硬件和软件编码器提供支持。编辑软件有较好的支持。 Rate Control（速率控制）：CBR、VBR、CQP 如果互联网是完美的，那么所有流媒体都可以使用 CQP（或者更好的：任何恒定质量模式，如 CRF 或 ICQ）。这些编码方法对每一帧都能产生相同的质量，与运动无关。在这种情况下，如果运动量大，则需要较高的比特率；如果运动量小，则需要较低的比特率。遗憾的是，比特率可变的数据流无法在互联网上完美传输。如果高动态场景的比特率升高，而接收方（用户）又有很多，发送方的连接可能会超载，每个接收方都会出现延迟或缓冲视频。每当一个接收器的带宽超过短时间的比特率峰值时，也会发生这种情况。 对于录制而言，基于质量的编码方式（VBR）效果更好，因为高运动场景的编码质量比 CBR 模式更好。当然，也可以将 CBR 的比特率提高到最高级别，这样就不会再看到差异，但这样做会浪费磁盘空间，因为低运动场景可以用更少的带宽（或空间）保存，而不会影响质量。 速率控制详解 CBR：恒定码率控制算法，用以恒定比特率流式传输或录制。质量由比特率决定。比特率越高，质量越好。 VBR：可变码率控制算法，用以实时、录制和可变比特率流式传输。根据 SDK 的描述，该算法符合 HRD 标准，可能可以很好地用于流式传输，尽管它不是严格的恒定比特率算法。质量由 2 比特率参数决定。比特率越高，质量越好。 CQP：常量化参数算法，用以可变比特率录制。无论运动如何，视频都以恒定的质量编码。比特率由视频材料的复杂性决定。质量由 QPI，QPP 和 QPB 参数决定。QPI 确定帧内质量（称为关键帧），QPP 确定预测 （P-） 帧质量，QPB 确定 h.264 B 帧（P 帧的较弱版本）。您希望对所有 3 个参数使用相同的值。非常适合原始素材的本地录制，因为如果您将比特率设置得足够高，质量不限于比特率，同时不会在低复杂场景中浪费磁盘空间。质量由 3 个 QP 参数 （1…51） 决定。值越低，质量越好，最终视频占用空间较大。最佳点可能在 20-25 左右。我的选择是 22，最大比特率为 50000，这导致平均比特率约为 29000，同时保持最高质量的高复杂场景。低于 22 的值会大大增加比特率要求。并非在每个高清显卡中都可用。 AVBR：平均可变比特率控制算法，用以可变比特率录制。质量由比特率决定。比特率越高，质量越好。允许高复杂度短场景的比特率消耗峰值，以保持质量。高复杂度场景的质量由精度和收敛参数决定。这对于像 VBR 算法（不符合 HRD 标准）这样的流媒体来说不够稳定。该算法并非在每个高清显卡中都可用。 LA（VBR）：具有前瞻性的 VBR 算法（VBR 升级版），用以可变比特率录制。VBR 算法的更好版本。质量改进了 VBR。由于在实际编码之前对几十帧进行了大量分析，因此延迟巨大，内存消耗增加。质量由比特率和预视深度 （1…100） 决定。比特率越高，质量越好。LA 值为 0 时，SDK 为默认值。该算法并非在每个高清显卡中都可用。 ICQ：智能恒定质量算法，用以可变比特率录制。CQP 模式的更好版本。以恒定的质量录制，类似于x.264的CRF模式，比CQP模式更好地使用带宽。质量由 ICQQuality 参数 （1…51） 确定，其中 1 对应于最佳质量。ICQQuality 的理智值可能在 20…25 左右，就像在 CQP 模式下一样。该算法并非在每个高清显卡中都可用。 VCM：视频会议模式，用以视频会议。可能是低延迟、低比特率要求、低质量。我没有找到有关此模式的任何详细信息，但它可能不适合高质量的流媒体或录制，但专注于低带宽使用和数据流的稳健性。并非在每个高清显卡中都可用。 LA ICQ：具有前瞻性的智能恒定质量算法，用以可变比特率录制。与 LA （VBR） 相同的质量改进和注意事项，但适用于 ICQ 算法。可能是最好的质量，同时消耗所有可用算法中最少的带宽 - 如果您的 CPU 支持它。质量由 ICQQuality 参数 （1…51） 和前瞻深度 （1…100） 确定，其中 1 对应于最佳质量。“前瞻”越大，质量越好，其中 0 表示 SDK 默认值。ICQQuality 的理智值可能在 20…25 左右，就像在 CQP 模式下一样。该算法并非在每个高清显卡中都可用。 OBS 论坛有大佬给出的推荐顺序是： LA ICQ -&gt; ICQ -&gt; CQP -&gt; LA （VBR） -&gt; AVBR -&gt; VBR -&gt; CBR 浪子推荐： 如果主要使用流式传输，则保持 OBS 的默认值（CBR 2500kbs）即可，也可以使用 VBR，但不推荐其它的算法。如果电脑的配置较好，可以适当提高码率，核显的话还是推荐保持默认值即可。如果直播是游戏的话，推荐使用独显。核显可以玩游戏，但不代表可以直播；如果可以直播，但不代表最终质量如何。 本地录制的选择就较多了，可以结合自己的硬件选择，情况不一。 视频最终的质量由编码 + 码率决定。一般互联网视频推荐 .H264 编码封装为 MP4 的格式。 码率越大，视频体积越大。 视频画面比例 常见的竖屏画面比例为 4:3；横屏为 16:9、18:9、21:9，横向数字越大，上下的黑边越宽。还有其它各种稀奇古怪的比例，就不详细讲解了，可以观看视频： 如果什么都不懂，建议导出竖屏时 4:3，横屏时 16:9，这些硬件支持较好。 二、音频 音频编解码器 AAC：与 H.264 一样，AAC 的历史也相当悠久（1997 年），但支持范围非常广泛，在典型比特率下仍能提供不错的质量。几乎所有流媒体服务都使用这种编解码器。编辑软件提供出色的支持。 Opus：比 AAC（2012 年）的编解码器更新、质量更高，并且免费授权。它的质量更高，但兼容性更差。编辑软件提供一般支持。 FLAC：无损编解码器，免费授权，广泛用于音乐，但不太支持视频文件。编辑软件提供一般支持。 ALAC：苹果公司的无损音频编解码器，在 MOV/MP4 和编辑软件中得到很好的支持。编辑软件有较好的支持。 PCM：无压缩音频，包括 32 位浮点录音支持，使编辑更加灵活。编辑软件提供出色的支持。 三、音/视频格式与编解码器的兼容性 视频编解码器与音频编解码器的兼容性 编解码器 H.264 HEVC AV1 ProRes AAC Any MP4, MOV, MKV, TS MP4, MKV MOV, MKV ALAC MP4, MOV, MKV MP4, MOV, MKV MP4, MKV MOV, MKV FLAC MP4, MKV MP4, MKV MP4, MKV MKV Opus MP4, MKV, TS MP4, MKV, TS MP4, MKV MKV PCM MOV, MKV MOV, MKV MKV MOV, MKV 表格横向为视频编解码器，纵向为音频编解码器； TS 包括 m3u8(HLS)； 视频格式与其编解码器的支持 container H.264 HEVC AV1 ProRes FLV ✅ ❌ ❌ ❌ MP4 ✅ ✅ ✅ ❌ MOV ✅ ✅ ❌ ✅ MKV ✅ ✅ ✅ ✅ M3U8 (HLS) ✅ ✅ ❌ ❌ TS ✅ ✅ ❌ ❌ MPEG-TS 中的 AV1 正在标准化，一旦最终确定，它将可用于 TS 和 HLS 输出。 音频格式与编解码器的兼容性支持 container AAC ALAC FLAC Opus PCM FLV ✅ ❌ ❌ ❌ ❌ MP4 ✅ ✅ ✅ ✅ ❌ MOV ✅ ✅ ❌ ❌ ✅ MKV ✅ ✅ ✅ ✅ ✅ M3U8 (HLS) ✅ ❌ ❌ ✅ ❌ TS ✅ ❌ ❌ ✅ ❌ MP4 中的 PCM 是标准化的，但 FFmpeg 和 OBS Studio 尚不支持。","tags":["科普"]},{"title":"【Linux】 初次把玩Debian12","path":"/2023/07/22/Linux/Debian/初次把玩Debian12/","content":"Debian 12 一、前言 最近发现了 Debian 系统，查阅网上资料多数也说该系统比较稳定，并且使用的也是 deb 格式的安装包和 apt 管理器。另外由于使用最新版的 Ubuntu 的时候发现默认下载的 Snap 源的软件，导致更新后一些软件会有问题，不能正常使用。虽然可以关闭，但是 emmmm，一言难尽。 趁此机会，把玩一下，嘿嘿~本文基于 Debian12 版本，如果各位少侠使用的桌面系统，这些命令大概也是同样适用的。浪子本文中使用默认登录的用户是 root 用户，如果各位少侠运行的时候权限不足而失败，请自行添加 sudo 执行权限前缀。 二、基础安装配置 安装的时候虽然可以选择中国国内的镜像，但是默认的 安全更新 使用的源依旧是官方的地址，而且查阅部分（北京外国语、清华源）镜像的帮助说明，也不推荐使用镜像站安全更新软件源，因为镜像站往往有同步延迟。但是啊，使用官方地址更新时非常的慢！浪子更新的时候两个小时，两个小时啊还没更完！太恐怖了，所以浪子使用了镜像地址。修改 /etc/apt/sources.list，浪子使用的 北京外国语镜像站： /etc/apt/sources.list1234567891011121314151617# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.bfsu.edu.cn/debian/ bookworm main contrib non-free non-free-firmware# deb-src https://mirrors.bfsu.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb https://mirrors.bfsu.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware# deb-src https://mirrors.bfsu.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb https://mirrors.bfsu.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware# deb-src https://mirrors.bfsu.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware# 安全更新设置使用镜像站，速度快deb https://mirrors.bfsu.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware# deb-src https://mirrors.bfsu.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware# 默认使用的官方源，注释该行内容，禁止使用官方源# deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware# # deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware 更新并安装一些常用工具 1234# 更新apt update &amp;&amp; apt upgrade# 安装常用构建工具apt install build-essential git iproute2 curl wget vim -y 语言 123456789# 查看当前语言locale# 图形化选择语言sudo dpkg-reconfigure locales# 再次查看语言是否安装locale -a# 如果没有改变执行下面的语句export LANG=zh_CN.utf8 时区/时间 系统安装的时候如果选择的是中国地区，那么就已经配置好了。如果安装时候全是默认的配置，可以使用以下方式修改： 12345678910# 查看当前的时区timedatectl# 查看支持的时区列表timedatectl list-timezones# 是否含有中国时区timedatectl list-timezones | grep Asia/Shanghai# 设置中国时区timedatectl set-timezone Asia/Shanghai# 再次查看timedatectl 允许 root 用户远程登录 默认情况下，Debian12 也是不允许 root 用户使用密码进行远程登录的~~（好吧，其实是 SSH）~~。所以需要配置一下。编辑 sudo vim /etc/ssh/sshd_config 文件，修改/添加下面的内容，保存退出。 /etc/ssh/sshd_config12#PermitRootLogin prohibit-passwordPermitRootLogin yes 然后重启 sshd 服务就可以开心的使用 root 用户密码登录啦！ 1systemctl restart sshd 简单介绍一下使用 SSH 登录服务器，这种方式并不需要修改上面的文件，这也是推荐的安全做法。 首先，生成一对 SSH 密钥对； 1ssh-keygen -t ed25519 -f ~/.ssh/server_key 然后上传公钥到服务器； 1ssh-copy-id -i ~/.ssh/pubkey user@host 测试 1ssh -i ~/.ssh/pubkey user@host 现在应该可以直接连接服务器了，并且不需要使用 root 用户的密码进行访问。 ssh-copy-id 使用 SSH 协议连接到目标主机并上传 SSH 用户密钥。该命令编辑服务器上 authorized_keys 的文件。如果目录不存在，它将创建 .ssh 该目录。如果授权密钥文件不存在，它将创建该文件。如果添加 -f 选项，可能会导致 authorized_keys 文件中存在多个密钥副本。 bash 命令别名 除了部分发行版 Linux 中可以直接使用 ll 命令，其它系统默认是不支持的，所以使用自己喜欢的别名命令还是需要配置的。为了不污染 /etc/profile 中的原有内容，此处举例使用外部文件编写内容，然后引入系统配置中。 在 /etc 目录下创建自己的别名命令文件：sudo touch /etc/alias_bashrc，Debian12 中默认是没有这个文件名的，可以直接使用，当然，各位少侠可以按照自己喜好自己取文件名，这里只是举例。 /etc/alias_bashrc1alias ll=&#x27;ls -al&#x27; 编写完毕仍然是不能直接在 bash 中使用命令的，在全局文件 /etc/profile 中引入，让系统加载自定义别名文件内容供系统识别(添加下面使用 # 包括的内容即可)： /etc/profile12345678910...if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrcfi############# 引入自己的别名文件 #############if [ -f /etc/alias_bashrc ]; then . /etc/alias_bashrcfi... 然后刷新文件：source /etc/profile，之后就可以在 bash 中使用 ll 啦，快去试试吧！ /etc/profile 是一个用于配置系统范围Shell环境的重要文件，它对所有用户登录时都生效。用户也可以在自己的个人配置文件（如~/.bashrc）中设置特定于用户的环境变量和Shell配置选项。 如果单用户使用的话，直接在 ~/.bashrc 文件中直接添加别名即可，该文件只对当前用户生效，内容也比较少。 以后要是有其它的自定义别名，可以直接在 /etc/alias_bashrc 中添加即可。 vim 配置 vim 配置，默认的感觉不太好用。这段配置并不使用任何插件。 /etc/vim/vimrc12345678910111213141516171819202122232425262728293031323334353637383940414243&quot; 文件编码set encoding=utf-8set fileencoding=utf-8&quot; 语法高亮set syntax=on&quot; Tab键的宽度，tabstop 可简写为 tsset tabstop=4&quot; 使用空格代替制表符set expandtab&quot; 自动缩进时,缩进长度为4set shiftwidth=4&quot; 可以用 Backspace 键一次删除4个空格set softtabstop=-1&quot; 突出显示当前行set cursorline&quot; 去掉输入错误的提示声音set noeb&quot; 高亮显示匹配的括号set showmatch&quot; 总是显示行号，number 简写 nuset number&quot; 侦测文件类型filetype on&quot; 高亮搜索的文本set hlsearch&quot;代码补全set completeopt=preview,menu&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\\ [FORMAT=%&#123;&amp;ff&#125;]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %&#123;strftime(\\&quot;%Y-%m-%d\\ -\\ %H:%M\\&quot;)&#125;&quot; 1=启动显示状态行, 2=总是显示状态行set laststatus=2 三、其他软件 docker 参考下面两篇文章： https://docs.docker.com/engine/install/debian/ https://u.sb/debian-install-docker/ 如果出现报错： 1Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: dial tcp: lookup registry-1.docker.io on 192.168.47.2:53: server misbehaving 编辑 vim /etc/resolv.conf 文件在末尾添加以下内容： /etc/resolv.conf12nameserver 8.8.4.4nameserver 8.8.8.8 附 关于 PPA 最近了解了 PPA（Personal Package Archives，个人软件包存档），和 Arch/Manjaro 的 AUR 类似，使用过 Linux 的应该都知道，Linux 上的软件包更新是需要经过审核的，而使用 apt 作为下载源的官方包里可能很长时间才更新。这个时候就可以考虑使用 PPA。使用 PPA 的时候需要用户确认信任该源，这要求用户对自己添加的源要负责。 可以使用以下命令添加 PPA： 12sudo add-apt-repository ppa:mmk2410/intellij-ideasudo apt update 部分的 PPA 下载速度也是感人，可以替换源： 1将所有的 http://ppa.launchpad.net 替换为 http://launchpad.proxy.ustclug.org 搜索 PPA 可以在这个网站搜索。 目前来看，PPA 中的包还较少，很多工具不是版本较旧就是没有，并且 PPA 只推荐喜欢命令行或者了解 Linux 的人使用，小白就不要用了。 Debian12 系统版本库 Debian12 的官方软件包只支持 openjdk-17，嗯，对的。算了，列个表吧。 emmm，太懒了，其实是比较忙。在 官方文档 中找到了 Debian 各个版本中对应的软件版本号。文档 还是很不错的，有需要自行查看。 防火墙 每次换服务器最大的问题并不是软件的安装部署，而是防火墙工具，因为服务运行是需要占用端口的，运行之后让外部访问是需要开放端口的，所以防火墙的使用是比较的重要的。 Debian12 使用的是 nftables，没错，我之前一直没有听说过，只到现在才知道。吾生也有涯，而学也无涯。 常用操作，红帽的这篇文章还是非常不错的：https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/securing_networks/getting-started-with-nftables_securing-networks","tags":["linux","debian"],"categories":["Linux"]},{"title":"Hexo 博客使用 Stellar","path":"/2023/07/10/Hexo使用Stellar主题配置/","content":"使用了很久的 Volantis 换成了 Stellar。这两个主题都很棒！喜欢的话各位少侠可以试试！感谢开发这两个主题的各位佬！真的太厉害啦！膜拜~ 一、Hexo 创建博客 本文基于 Github Pages 进行搭建。由于 Github 在国内的的现状并不大好，如果少侠想要自己博客访问速度更快，可以考虑使用 Gitee Pages，Gitee 需要实名认证以及手动更新部署，这点儿需要注意。 本文开始之前，默认少侠的系统已安装如下环境，并掌握这些工具基本使用： NodeJs 16+ Git 本文难免有疏漏之处，如果少侠是第一次使用/听说，建议先通读一遍 Hexo 官方文档，不论是对于搭建博客还是更换主题配置亦或是后期解决问题等都有很大的帮助。 1. 创建新的博客 12345678# 创建博客文件夹mkdir myblog &amp;&amp; cd myblog# 全局安装 hexonpm i -g hexo-cli# 初始化博客目录hexo init# 安装一个插件，后面本地部署时需要使用（hexo d）npm install hexo-deployer-git TIP: hexo init 进行初始化的博客目录必须是一个空文件夹。 之后你会看到下面的目录结构： 123456789|--.github|--node_modules|--scaffolds|--source|--themes|--config.landscape.yml|--_config.yml|--package-lock.json|--package.json 目录下具体是什么、里面的文件有什么用，请参看 Hexo Docs。 2. 创建 Github 仓库 Github Pages 中有相关说明：每个 GitHub 帐户和组织都有一个站点和无限的项目站点。概括一下，GitHub 支持用户创建静态的宣传网站，该站点使用固定的格式创建仓库：username.github.io。 username 是 GitHub 的用户名。比如浪子的用户名就是 jhlzlove，那么仓库的名称就是 jhlzlove.github.io。少侠可以按照 Github Pages 的方式创建，也可以按照下面的方式创建，效果都是一样的，当然前者更加简单。 无限的项目站点 本文没有讲解，熟悉了这个之后可以自行了解，也是非常简单的。 在 Github 上创建完 yourusername.github.io 仓库后再进行以下操作： 12345678910111213cd mybloggit init# 关联你的远程仓库git add origin git@github.com:yourname.github.io.git# 浪子喜欢放到 main 分支上git checkout -b maingit add -Agit commit -m &quot;first commit my blog&quot;# 推送到远程分支，并且建立分支间的追踪关系.git push -u origin main 3. 更改配置文件并部署 修改 myblog/_config.yml 文件： myblog/_config.yml1234567891011121314151617181920# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: http://yourname.github.iopermalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks...deploy: # 类型 type: git # 部署分支名称，按照自己喜欢的起名就可以。这里写完还需要在 GitHub 上进行分支创建并配置 branch: pages # 仓库，这里使用的 SSH 方式 repo: git@github.com:yourname/yourname.github.io.git # 如果你看了 hexo 的文档，这里就很清楚啦，部署的时候会使用这个消息作为提交的信息 message: Automatic deploy by Github Action：&#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125; 上面的配置更改完成以后，还需要在 Github 中配置一下，否则部署之后访问 https://yourname.github.io 是访问不到的。 最后就可以推送部署啦。等待部署成功，就可以访问 https://yourname.github.io 查看博客的效果啦！ 1234567# 先推送备份，可以跳过这步直接进行 部署git add .git commit -m &quot;push config&quot;git push# 部署hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 二、Stellar 主题配置 上面部署使用的是 Hexo 的默认主题 landscape。Hexo 提供了上百种主题供用户选择，可以查看 Hexo 主题商店 进行选择，本文使用的是 Stellar 主题，再次感谢作者提供这么好看、好用的主题! 1. 安装 Stellar 主题 推荐使用 submodule 的方式安装，如果动手能力较强的少侠或者想要自定义的大佬可以进行 fork 后换成自己的 GitHub 地址，方便自己修改和更新。 123cd mybloggit submodule add https://github.com/xaoxuu/hexo-theme-stellar.git themes/stellar 编辑 myblog/_config.yml 文件： myblog/_config.yml123# 默认为 landscape# 这里的名字是博客主题目录 myblog/themes/ 下的主题文件夹名称theme: stellar 默认的主题配置文件为 _config.landscape.yml，修改该文件的名称为 _config.stellar.yml 并删除里面的所有内容。 主题配置文件形如 _config.xxxxx.yml，其中 xxxxx 对应主题文件夹的名称，里面的内容修改可以参考主题文档。 2. Stellar 主题配置 Stellar 主题可以参考 Stellar 文档 进行配置，原作者大大写的很详细。但是第一次使用可能有些细节不懂，浪子也一样，过段时间回来再看就会恍然大悟！如果不会可以留言哦，相互学习一下！ 本文的 stellar wiki 为基于新版本（1.24）的配置方式。 2.1 Stellar 的 wiki 文档配置 Stellar 中最令浪子惊喜的地方就是这个了，可以让我把某一类的文章全部扔在这里。这里的配置可能对于新手有些难度，所以本文主要讲了 wiki 文档配置。浪子当时也反复弄了好久，在这里记录一下。哦，对了，要注意的是 Stellar 1.20 之前和之后的版本 wiki 文档的配置方式发生了较大的变化。 wiki 同样支持 tags 分类，如果你需要分类的话可以参考浪子的分类方式：把 tags 的名称作为 source/wiki/ 下的目录名称，然后在每个 tags 里写具体的项目，这样统一分类，便于管理。Stellar 主题会根据项目 id 自动归类所有的文章，无论该路径下嵌套了多少层目录： 1234---layout: wikiwiki: 自定义 wiki 项目 id--- 浪子这里以 CloudService 为例作为 wiki 项目 id，该项目的所有文档（md 源文件）都在 source/wiki/技术加油站/云原生与微服务/ 目录下，所有文档的 front-matter 的内容是如下形式： source/wiki/技术加油站/云原生与微服务/xxx.md12345---layout: wiki # 使用wiki布局模板wiki: CloudService # 自定义项目名称，source/_data/wiki/ 中的 yml 文件名称必须与此相同title: xxx--- 然后新建 source/_data/wiki/CloudService.yml 文件，下面是针对该项目的配置内容： source/_data/wiki/CloudService.yml123456789101112131415161718192021222324252627282930313233343536# name title 为自定义文章名称# name 和 title 的区别在于 name 是内容页面显示的名称，title 是在 wiki 列表中显示的名称name: CloudServicetitle: 云原生与微服务description: 描述，wiki 列表中显示在 title 下方的简单文字描述# 分类标签tags: 技术加油站# 不显示封面，默认显示：truecoverpage: falsecover: https://oss.muzing.top/image/Nginx_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png# wiki 列表标题旁的 小图片icon: https://oss.muzing.top/image/Nginx_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png# 搜索配置，在该 wiki 页中只能搜索指定路径的文章内容search: filter: /wiki/技术加油站/CloudService/ placeholder: 在 CloudService 中搜索...# 覆盖侧边栏sidebar: - toc - timeline_stellar_releases - related# wiki 页分类目录# 使用自定义的 path，该 path 中为该项目的文章，stellar 主题会自动查找并显示该目录的所有文章base_dir: /wiki/技术加油站/CloudService/# 如果文章需要分组，则按照此格式toc: &#x27;容器&#x27;: - index # 实际文章路径：/wiki/技术加油站/CloudService/index.md - Docker # 实际文章路径：/wiki/技术加油站/CloudService/Docker.md# 若无需分组按照以下格式# toc:# - doc1# - doc2# - doc3 最后新建 source/_data/wiki.yml 文件中添加该项目。如果这里不添加，则不会在 wiki 列表中展示。 source/_data/wiki.yml1- CloudService 完成之后重新部署即可，效果可以看浪子的 wiki 效果。想必有以上的示例就明白如何配置了，如果还不明白，建议再读一遍原作者的 文档系统使用说明。 最后，推荐添加返回 wiki 项目主页路径，这样从 wiki 页中点击 项目 返回时，会回到 wiki 项目列表页而不是博客主页： myblog/_config.yml1wiki_dir: wiki 三、其它 1. 错误处理 如果遇到报错并且不知道错误原因的话，可以使用 hexo g --debug 命令查看 debug 输出信息。 2. 使用永久链接插件解决中文转义 如果我们写的文章标题是中文的话，那么在进行链接的分享时是会进行转义的，至于为什么要转义，请自行百度。我们可以安装一个插件，给链接 “化个美美的妆”，化妆后就是形如 https://xxx.xxx.com/posts/8ddf18fb.html 的漂亮女孩儿啦！ 安装插件： 在 myblog/_config.yml 中找到对应 permalink 标签，进行修改即可： myblog/_config.yml12345# permalink: :year/:month/:day/:title/permalink: p/:abbrlink/abbrlink: alg: crc32 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex 不同算法、进制生成的链接格式如下： 算法 进制 生成链接示例 crc16 hex https://yourname.github.io/p/66c8.html crc16 dec https://yourname.github.io/p/65535.html crc32 hex https://yourname.github.io/p/8ddf18fb.html crc32 dec https://yourname.github.io/p/1690090958.html 3. 引入Mermaid流程图 Hexo 默认的 markdown 解析器不支持 Mermaid 流程图，需要安装插件来支持： Stellar 主题的作者大大已经做了集成，使用此主题只需要安装后在主题配置文件中找到 mermaid 的 enable 项设置为 true，在需要渲染的文章的 front-matter 里加入 mermaid: true 即可。 如果使用的其它主题，可能需要自己做一些配置，具体的配置可以参考该插件的 官网说明。如果嫌弃配置麻烦或者实在不想配置，可以使用下面的方法。 另一种解决方案：hexo-filter-kroki，安装完成后，默认情况下，不需要进行任何配置，插件会将您的文本发送到 Kroki.io 进行渲染，并将 base64 编码的图像内联在 html 中。在插件作者的仓库中也有高级配置说明，可以自行查看配置。 12# 懒人推荐npm install --save hexo-filter-kroki 四、使用 Github Action 自动部署 使用自动部署只是省了三个命令 hexo cl &amp;&amp; hexo g &amp;&amp; hexo d，但是可以作为 CI 的入门案例，自己写着玩玩，你也可以借助 package.json 脚本命令和 npm 等包管理器，一个命令解决。有很多方式都可以实现，看各位少侠的喜好喽~ 1. 配置不同仓库的 SSH 密钥 本文示例的 Github Action 为不同仓库之间的配置，部署的时候就像我们自己推送到 Github 平台类似，需要认证（permission）。为什么我要使用不同的仓库呢？因为 Github Pages 服务必须使用公开库（Public），但是我的源文件不想让其他人可见，因此我的 Hexo 博客是私有库，只有最终的 html 文件在 username.github.io 网站。 如果少侠的博客源文件和 Pages 网站都在一个仓库，属于不同分支，按照此种方法也可以，但是较为麻烦。后面浪子会介绍另一种方式，不需要配置 SSH 密钥，简单便捷。 1.1 创建新的 SSH 密钥： ssh-keygen -t ed25519 -C 'xxx@xx.com' -f ~/.ssh/github_action_key，创建完成后会在 ~/.ssh/ 路径下生成两个文件：github_action_key 和 github_action_key.pub。 1.2 设置密钥 公钥配置在 Pages 服务仓库 在 yourname.github.io 仓库，依次点击 settings -&gt; Deploy keys -&gt; Add deploy key。该 key 的作用主要是验证用户是否有权限进行仓库的操作。 title 随便填写； key 的值填写上面生成的 github_action_key.pub 的全部内容； Allow write access 选项打勾。 私钥配置在源文件仓库（私有仓库） 在另一个仓库中，依次点击 settings -&gt; Secrets and Variables -&gt; Action，新建一个 secret： Name 随便填写，后面编写 Action 脚本时需要用到； Value 填写 github_action_key 私钥的全部内容。 2. Action 脚本编写 Github Action 的脚本文件是在 .github/workflows/ 路径下，支持 yml 格式。脚本中我们还可以引用别人已经写好的脚本。 需要明确的是，如果你使用的 Hexo 主题中有 自定义标签，并且在 markdown 文件中有所使用的话，Action 自动部署的时候会发生解析错误，找不到自定义标签的解析内容进而无法正常使用 Action。所以，还记得本文开始的时候推荐使用 git submodule 的方式？ 在 Hexo 博客仓库中使用 git submodule add origin https://github.com/username/xxxx.git themes/xxx 的方式去添加主题，然后在 yml 文件中 检出分支 时使用 submodules: true 选项开启子模块检出： .github/workflows/deploy.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051name: Hexo Blog CI# master branch on push, auto runon: push: branches: - main jobs: build: runs-on: ubuntu-latest steps: # check it to your workflow can access it # https://github.com/marketplace/actions/checkout - name: Checkout Repository main branch uses: actions/checkout@v4 with: submodules: true # Checkout private submodules(themes or something else) fetch-depth: 0 # from: https://github.com/actions/setup-node - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: &#x27;20&#x27; - name: Setup Hexo Dependencies run: | npm install &amp;&amp; npm install hexo-deployer-git npm install -g hexo-cli - name: Setup Deploy Private Key env: HEXO_DEPLOY_PRIVATE_KEY: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; # 仓库的私钥的 Name，需要改为自己的 run: | mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts - name: Setup Git Infomation run: | git config --global user.name &quot;github-action&quot; git config --global user.email &quot;github-action@no-reply.com&quot; - name: Deploy Hexo run: | hexo clean hexo generate hexo deploy 博客源文件和 Pages 网站文件在相同仓库的不同分支的简单方式 如果少侠的 Hexo 博客源文件和 Pages 网站文件是在相同的仓库中，可以按照类似上面一样的方式配置，无非就是公钥、私钥都设置在同一个仓库中，同样是没有问题的，但是较为麻烦。 接下来介绍一种简单的方式，此方式 只适用于 md 源文件和 Pages 网站文件都在 同一个仓库，只是属于不同分支。如果你使用过 vuepress、vitepress 等，那么此方式和它们一样。 Github Action 提供了 $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; 变量，该变量会在 workflows 结束后立即过期。该变量具有不同权限，可以在 yml 中修改整个工作流或单个作业的 GITHUB_TOKEN 权限。具体内容请看 官网说明 该方式无需配置 SSH 密钥，直接使用上面的变量即可，下面给一个脚本，少侠使用的时候修改部署的分支名称即可。如果需要指定其它变量，可以查看使用的脚本官网。 .github/workflows/deploy.yml12345678910111213141516171819202122232425262728293031323334353637383940414243name: Deploy Hexo Blog# master branch on push, auto runon: push: branches: - main jobs: build: runs-on: ubuntu-latest steps: # check it to your workflow can access it - name: Checkout Repository main branch uses: actions/checkout@v4 with: submodules: true # Checkout private submodules(themes or something else) fetch-depth: 0 # from: https://github.com/actions/setup-node - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: &#x27;20&#x27; # 生成文档 - name: Generator docs run: | npm i npm install -g hexo-cli hexo cl &amp;&amp; hexo g # 使用已有的 action 进行部署 # https://github.com/JamesIves/github-pages-deploy-action - name: Deploy pages uses: JamesIves/github-pages-deploy-action@v4 with: # 使用 public 内的文件部署到 pages 分支 folder: public # 部署分支 branch: pages # 默认使用 secrets.GITHUB_TOKEN # token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; 使用脚本之后，少侠只需写完文章后，把 md 源文件所在的仓库的内容推送到 Github 即可，等待一会儿再次访问 yourname.github.io，如果看到内容更新即代表成功。 使用 Action 之后你会发现一个新的问题：部署之后访问博客，所有文章的 发布时间、更新时间 都是最近提交的时间，这就有问题了。分析原因也简单：Github Action 部署需要 clone 我们的库，clone 之后所有文件的日期都更新了，如果在 md 文件的 front-matter 中指定了 date 属性则正常，但是浪子之前所有的博客都没加！不过这个影响也不大。 之后在浪子所在的一个群里某位大佬推荐了一个插件：hexo-filter-date-from-git，试了试，果然好使！不过注意，使用该插件需要脚本必须设置 fetch-depth: 0 项检出所有的 git 日志，若此项不设置，该插件只能根据最新的 git log 获取提交时间进行覆写，那么这样你就会发现，和原来没有使用插件一样了。 123cd myblognpm install hexo-filter-date-from-git --save 五、Stellar 主题美化 引入一言小组件 source/_data/widgets.yml123456789101112131415161718192021222324hitokoto: layout: markdown title: 一言 content: | # support markdown &lt;span class=&quot;hitokoto&quot;&gt;一言加载中...&lt;/span&gt; &lt;script&gt; document.addEventListener(&#x27;DOMContentLoaded&#x27;, async () =&gt; &#123; try &#123; const response = await fetch(&#x27;https://v1.hitokoto.cn&#x27;); const data = await response.json(); // 获取页面上用于显示一言的元素 const dom = document.querySelector(&#x27;.hitokoto&#x27;); // 设置一言内容 if (dom &amp;&amp; typeof data.hitokoto === &#x27;string&#x27;) &#123; let res = data.from ?? false ? &quot;—— 《&quot; + data.from + &quot;》&quot;:&quot;&quot; dom.innerText = data.hitokoto +&quot; &quot;+ res; &#125; else &#123; console.error(&#x27;未能获取或解析一言数据，或者找不到目标 DOM 元素&#x27;); &#125; &#125; catch (error) &#123; console.error(&#x27;请求过程中发生错误：&#x27;, error); &#125; &#125;); &lt;/script&gt; 配置示例（在你需要显示的地方引入组件即可）： _config.stellar.yml12345site_tree: # -- 列表类页面 -- # # 主页配置 引入 hitokoto 一言组件 home: leftbar: hitokoto, recent 设置分类标签颜色 _config.stellar.yml12345678article: ... # 添加分类的标签并设置对应的颜色 category_color: &#x27;探索号&#x27;: &#x27;#f44336&#x27; &#x27;编程后花园&#x27;: &#x27;#A505F0&#x27; &#x27;技术加油站&#x27;: &#x27;#c0ea66&#x27; &#x27;人生图书馆&#x27;: &#x27;#EDADFF&#x27;","tags":["hexo"],"categories":["瞎折腾"]},{"title":"【Linux】Linux 入门","path":"/2023/06/24/Linux/Linux入门/","content":"简单了解 Linux 系统，另外推荐一个 Linux 的学习网站：https://www.linuxshelltips.com/。 一、目录 目录名称 介绍 /home 用户主目录，子目录名称默认以该用户名命名。 /root root用户主目录。 /bin 常用的命令文件。 /sbin 包含系统管理员和root用户所使用的命令文件。 /boot Linux系统的内核文件和引导装载程序文件。 /opt 第三方应用程序的安装文件。 /etc Linux上的大部分配置文件，建议修改重要的配置文件之前先备份。 /usr 包含可以供所有用户使用的程序和数据。 /media 系统自动为某些设置(比如u盘等)挂载提供挂载目录。 /mnt 手动为某些设备(比如硬盘)挂载提供挂载目录。 /dev 大部分设备文件。 一般编译安装的可执行文件默认路径为 /usr/local/。 二、权限 在 Linux 中可以明显感受到用户间的不同权限，如果你之前是使用 Windows 系统的话，可能经验比较少，突然使用 Linux 会不习惯，尤其是使用普通用户操作一些超级命令的时候。 在 Linux 中，打开终端 bash，普通用户是 $ 标识，root 用户是 # 标识。为了方便的管理用户，还有用户组的概念。 对于系统上的一个文件来说，对于它的操作用户有 3 种：创建它的用户，超级用户，其它用户。 用户操作 12345678910111213141516171819202122232425262728293031323334# 创建用户（如果创建用户的时候没有指定组名，默认会自动创建一个和用户名相同的组名）： useradd -d 设置用户主目录 -g 设置用户组群 username# 修改用户主目录并移动之前的主目录文件到新的目录中：# 如果添加了 -m 选项，用户旧目录会移动到新的目录中；如果不存在，就新建usermod -l new_username -d /home/develop –g developer -m old_username# 删除用户# 带 -rf 选项时记得做好备份，会将用户主目录和用户一并删除；若不带选项主目录将保留。userdel -rf# 添加组群：groupadd group_name# 修改组群名：groupmod -n newName oldName# 删除组群：groupdel group_name# 给指定的用户设置密码（如果新创建的用户没有密码，那么该用户是无法使用的，类似未激活）passwd username# 添加用户到组群gpasswd -a username group_name# 删除组群的指定用户gpasswd -d username group_name# 查看用户属于那些群组groups username# 让属于该群组的当前用户以指定的组群身份登录newgrp groupName username useradd、usermod 命令支持的常用选项如下： 选项 说明 -c 该用户的描述 -d 指定用户主目录，默认 /home/用户名；如果此目录不存在，可以同时使用-m选项，强制创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 授权操作 Linux 每个文件都是有对应操作权限的，可以使用 ls -l 查看当前所在路径的文件的所属用户、所属组和对应的权限。 可选项 意义 u 用户所有者 g 用户组群 o 其他用户 a 所有用户，系统默认值 + 添加某个权限 -(减号) 取消某个权限 =(等号) 赋予给定权限并取消原有权限(如果有的话) r 读取权限 w 写入权限 x 可执行权限 数字权限表示法：r=4,w=2,x=1 linux文件权限信息图 给指定的文件添加某个权限： 1234# 数字法chmod 777 file.sh# 字母法chmod u+x,g+wx file.sh 更改文件和目录所有者(二选一)： 12chown -R 用户.组群 文件/目录chown -R 用户:组群 文件/目录 -R 选项是递归操作，把目录下的所有文件全部修改为当前的权限。 只修改所属用户(即用户所有者) 1chown newGroup file 只修改所属用户组(二选一) 12chown .newGroup filechown :newGroup file 三、命令 Linux 中的命令有分常的多，这里只介绍基础使用的命令，这些命令工具在几乎所有的 Linux 发行版中默认安装。另外常用的简单命令，例如 ls、cd、cat、clear、history 等这里也略过。 系统信息 123456# Linux 发行版信息，也可以使用 cat /etc/os-release 查看lsb_release -a# 显示 Linux 内核版本（架构）、gcc 版本、以及操作系统内部版本cat /proc/version# 查看系统内核版本、系统内部版本和使用架构uname -a 系统硬件信息 123456789101112# 查看 cpu 信息lscpu# 如果没有该命令，请使用下面的命令cat /proc/cpuinfo# 查看内存 -g 以G为单位，-m 以MB为单位free -h# 查看磁盘信息df -h &lt;path&gt; # 或者fdisk -l cpu 信息部分参数说明： 参数名 说明 processor 核心编号 model name cpu 信息 cpu MHz 频率 cache size 缓存大小 flags 支持的指令集 Linux 的磁盘分区方式为 a、b、c、d 这种格式。 其中 /dev/sda 代表一块磁盘（物理），/dev/sda1、/dev/sda2 代表该盘上的第一个、第二个分区；而 /dev/sdb 是另一块磁盘。 Linux 中磁盘的编号从 1 到 4 的分区是主分区，大于 5 的分区是逻辑分区。 /dev/sda，/dev/vda，/dev/hda：s 代表 SCSI，而 h 代表旧的IDE hard磁盘（已经淘汰了），vda 是使用虚拟化感知磁盘驱动程序的磁盘，性能应该要好得多，因为虚拟机管理程序不必模拟某些硬件接口。 参考：https://unix.stackexchange.com/questions/145332/difference-between-sdx-and-vdx tree 选项 说明 -a 显示所有文件和目录。 -A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。 -C 对输出的文件和目录清单加上色彩，便于区分各种类型。 -d 显示目录名称而非内容。 -D 列出文件或目录的更改时间。 -f 在每个文件或目录之前，显示完整的相对路径名称。 -F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上&quot;*“,”/“,”=“,”@“,”|&quot;号。 -g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。 -i 不以阶梯状列出文件或目录名称。 -I 过滤不展示哪些文件 -L level 限制目录显示层级。 -l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。 -n 不在文件和目录清单加上色彩。 -N 直接列出文件和目录名称，包括控制字符。 -p 列出权限标示。 -P &lt;范本样式&gt; 只显示符合范本样式的文件或目录名称。 -q 用&quot;?&quot;号取代控制字符，列出文件和目录名称。 -s 列出文件或目录大小。 -t 用文件和目录的更改时间排序。 -u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。 -x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。 举个例子，显示除了 node_modules 以外的目录，其中目录层级为 2，更深层级的目录不显示： 1tree -I node_modules -dL 2 node_modules 后面不能添加 /. 其它命令 12345678910111213141516171819202122232425262728293031323334353637383940# 查看系统用户名称hostname# 按照时间降序并获取前 5 个文件ls -lt [path] | head -5# 实时监听文件输出tail -f [filename]# 获取文件最后 num 行记录tail -n num [filename]# 查看活动用户w# 查看用户登录日志last# 查看系统所有用户cut -d: -f1 /etc/passwd# 查看系统所有组cut -d: -f1 /etc/group# 创建链接文件# -s 创建软链接，相当于 win 下的快捷方式，不加 -s 选项为硬链接。ln -s 源文件 新的链接文件名# 查看进程ps -efps -aux# 挂载、卸载设备mount 设备 挂载目录umount 设备 挂载目录########################### 安装工具使用 ########################## # 查看所有监听端口 netstat -lntp# 查看所有已经建立的连接netstat -antp# 查看网络统计信息进程netstat -s 四、Linux 常用软件 VIM 命令 说明 yy 复制光标所在行； nyy 复制光标所在行开始的 n 行,n 代表数字； p 粘贴复制的内容 dd 删除光标所在行； ndd 删除光标所在行开始的 n 行，n代表数字； i 在当前光标所在处后进行编辑 o 在当前光标所在行的下一行新开一行进行编辑 O 在光标当前所在行的上一行新开一行插入 gg 让光标移动到文件首(第一行的第一个非空白字符处) G 使光标移动到文件尾(最后一行的第一个非空白字符) u undo，取消上一步操作 Ctrl + r redo，回到 undo 之前 set nu/nonu 显示/不显示行号 ggdG 清空所有内容 :wq 保存并退出，:x、Shift+zz具有同样效果 :q! 强制退出 VI 和 Vim 的键盘输入有所不同，推荐使用 Vim，服务器等一些最小安装的版本一般需要手动安装 Vim。 cURL 选项 说明 -X 指定请求方式：GET、POST 等。 -H、–header 指定请求头 -d、–data 指定请求体 -O 下载文件 -C - -O 断点续传 另外还有一个工具：wget，如果你想了解一下 wget VS curl 的区别：可以阅读这篇文章：https://www.geeksforgeeks.org/difference-between-wget-vs-curl/。 1234# 查看本机基础信息curl ipinfo.io# 本机公网curl cip.cc SSH 现在大部分的 Linux 发行版都含有 SSH 服务和客户端，这里只是提一下。 sshd：Unix/Linux 上的 SSH 服务器 sshd_config：Unix/Linux 上的服务器配置文件 ssh_config：Unix/Linux 上的客户端配置文件 iproute2 第二代网络工具，相比于 net-tools，命令更加完整一致。 1234567# 本机 IPip addrip addr show ens33ip link | ip link show [name] | ip route | ip route show [name]# 路由规则ip rule show 五、tar包常用命令 12345678910111213141516171819202122# 打包tar -cvf /usr/local/ xxx.tar.xx# 查看包内容tar -tvf xxx.tar# 解包内容tar -xvf xxx.tar# 以下格式的包只需要在选项中加入以下字母即可# 例如 tar -zxvf xxx.tar.gz# gzip(.tar.gz结尾的包)-z# bzip2(.tar.bz2结尾的包)-j# xz(以.tar.xz结尾的包)-J# -C 可以在解压的时候指定解压路径tar -C 指定路径 -zvxf 目标包文件 参数： -v 显示详细处理信息 -f 指定归档包文件，后面必须跟 tar 包相关文件 xxx.tar.gz 六、任务计划(Crontab)命令 12# 查看当前用户的计划任务服务crontab -l 定时任务说明 在以上各个字段中，还可以使用以下特殊字符： 符号 含义 * 代表所有的取值范围内的数字，如月份字段为*，则表示1到12个月； / 代表每一定时间间隔的意思，如分钟字段为 */10，表示每10分钟执行1次。 - 代表从某个区间范围，是闭区间。如“2-5”表示“2,3,4,5”，小时字段中0-23/2表示在0~23点范围内每2个小时执行一次。 , 分散的数字（不一定连续），如1,2,3,4,7,9。 crontab注意点: 由于各个地方每周第一天不一样，因此Sunday=0（第一天）或Sunday=7（最后1天）。 crontab 有2种编辑方式：直接编辑 /etc/crontab 文件与 crontab –e，其中 /etc/crontab 里的计划任务是系统中的计划任务，而用户的计划任务需要通过 crontab –e 来编辑；每次编辑完某个用户的cron设置后，cron自动在 /var/spool/cron 下生成一个与此用户同名的文件，此用户的cron信息都记录在这个文件中，这个文件是不可以直接编辑的，只可以用 crontab -e 来编辑。 crontab 中的 command 尽量使用绝对路径，否则会经常因为路径错误导致任务无法执行。 新创建的cron job 不会马上执行，至少要等2分钟才能执行，可重启cron来立即执行。 % 在 crontab 文件中表示“换行”，因此假如脚本或命令含有%,需要使用 \\\\% 来进行转义。 Crontab配置实例: 1234567891011121314151617181920#每一分钟执行一次command（因cron默认每1分钟扫描一次，因此全为*即可）* * * * * command#每小时的第3和第15分钟执行command3,15 * * * * command# 每天上午8-11点的第3和15分钟执行command：3,15 8-11 * * * command# 每隔2天的上午8-11点的第3和15分钟执行command：3,15 8-11 */2 * * command# 每个星期一的上午8点到11点的第3和第15分钟执行command3,15 8-11 * * 1 command# 每晚的21:30重启smb30 21 * * * /etc/init.d/smb restart# 每月1、10、22日的4 : 45重启smb45 4 1,10,22 * * /etc/init.d/smb restart 七、Shell https://www.geeksforgeeks.org/how-to-create-a-shell-script-in-linux/ https://www.geeksforgeeks.org/conditional-statements-shell-script Linux中有许多可用的Shell，例如The bourne shell（sh），The Korn Shell（ksh）和 GNU Bourne-Again Shell（bash）。为 sh shell 编写的脚本称为 shell 脚本，它们可以由 ksh 和 bash shell 解释。ksh 和 Bash 是原始 sh shell 的改进版本，它们比 sh 具有更多的功能。Bash 通常是大多数 Linux 发行版中的默认 shell，专门为 bash shell 编写的脚本称为 bash 脚本。 您可以指定脚本将使用哪个 shell，即使脚本是从另一个 shell 终端执行的。为此，请在脚本文件顶部添加“#!”，后跟所选 shell 的绝对路径。要将 bash 指定为解释器，请在 shell 脚本顶部添加以下行。 1#!/bin/bash 1. 整数比较 操作符 描述 -eq 等于 -ne 不等于 -gt 大于 -ge 大于等于 -lt 小于 -le 小于等于 2. 字符串比较 操作符 描述 == 等于 != 不等于 &lt; 小于，按 ASCII 字母顺序排列 &gt; 大于，按 ASCII 字母顺序排列 在 &lt; 和 &gt; 之前添加一个 \\，因为它们在 [ ] 结构中键入时需要转义。 3. 几个内置的 shell 变量 参数 说明 $? 每当命令结束并将控件返回到父进程时，它都会返回介于 0 和 255 之间的退出代码。退出代码 0 表示命令成功，任何其他退出代码表示命令不成功。 $# 传递到脚本的参数个数。 $* 以一个单字符串显示所有向脚本传递的参数。如&quot;$*“用「”」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。 $$ 脚本运行的当前进程ID号。 $- 显示Shell使用的当前选项，与set命令功能相同。 在 shell 中，有 [] 和 [[]] 两种条件测试表达式，它们有一些区别： [] 是 shell 自带的 test 命令的一种表现形式，而 [[ ]] 可以看作是内建的测试功能，是相对于传统的 test 命令的扩展强化版本。 [] 只是指针对常规的字符串匹配和文件匹配的，[[ ]] 支持字符串、文件、模式匹配、类型匹配等。 在 [] 中的变量在没有使用双引号包括时会被扩展和分割，而在 [[ ]] 中不会发生这种情况。 在 [] 中，|| 和 &amp;&amp; 代表或和和逻辑运算，而 [[ ]] 中，还有两个额外的操作符：&lt; 和 &gt; 可用于字符串比较和整数比较。 [] 支持一些正则表达式的特殊字符，[[ ]] 支持更多的扩展的正则表达式特性。 因为 [[ ]] 支持的东西更多更强大，建议优先使用 [[ ]] 语法。但需要注意，[[ ]] 只在 bash 及其衍生版本支持，像 sh，dash 等不支持。 比如寻找文件名是否以某个后缀结尾，可以使用以下语法： 12345if [[ $filename =~ \\.zip$ ]];then echo &quot;文件以 zip 结尾&quot;else echo &quot;文件不以 zip 结尾&quot;fi 4. 循环语法 1. for 循环语句 运算时使用 let 1234567891011for 条件do 语句块done其中：for ad in 1 2 3 4for ab in `seq 1 4`for ((ab = 1; ab &lt; 4; ab++))这三种写法的意思都是相同的，需要特别注意的是，第二行那个符号不是单引号，而是 Tab 上面，Esc 下面的那个键。因为使用的时候不容易看懂，不推荐使用。推荐第三种写法，注意有两个括号。 2. while 循环语句 1234while 条件do 语句块done 3. until 循环语句 和while循环同样，不同的是判断循环的条件，while条件为真时循环，until 条件为假时循环。 1234until 条件do 语句块done 4. 判断语法 shell 脚本的判断语句使用中括号，两端需要加入空格。比如下面这段代码(文件名为：test.sh)： test.sh1234567#!/bin/bashif [ 1 -ge 2 ];then echo &quot;yes&quot;else echo &quot;no&quot;fi 在 [ 和 ] 之前键入一个空格，同时指定要检查的条件，否则会出现错误。 1./test.sh: line 3: [1: command not found 5. 脚本示例 如果你的脚本是在 Window 下写完上传到 Linux 中的，那么文件的换行符可能有问题，可以使用以下命令进行转换: 123# 两个命令二选一tr -d &#x27;\\r&#x27; &lt; 文件名 &gt; 新文件名sed -i &#x27;s/\\r//g&#x27; 文件名 Linux 换行符是 (LF)，Windows 是 \\r (CRLF). 12345678910111213141516171819202122232425262728#!/bin/bash# 使用超级管理员的命令需要输入密码，这里先输入一下，yourpassword 替换为超级管理员的密码sudo -S -v &lt;&lt; EOFyourpasswordEOFecho -n &quot;请输入创建的文件夹：&quot;read nameif [ ! -d &quot;$name&quot; ];then echo &quot;$name 文件夹不存在,正在创建&quot; sudo mkdir /$nameelse echo &quot;/$name 文件夹已存在&quot;sudo mkdir /$name/testif [ $? eq 0 ];then echo &quot;文件夹创建成功&quot;else echo &quot;创建失败&quot;sudo touch /$name/test/111.txt # 对文件写入内容echo &quot;自古星耀晦明时，不持太阿误剑诗&quot; | tee /$name/test/111.txt# -a 追加内容echo &quot;无边落木萧萧下，不尽长江滚滚滚来&quot; | tee -a /$name/test/111.txt Shell 脚本对 bash 中的 &gt; 或者 &gt;&gt; 有不同的处理，如果 shell 中使用这种方式将会报错； 因此这里使用了 tee 命令来进行文本输入追加。","tags":["linux"],"categories":["Linux"]},{"title":"Windows 开发环境配置","path":"/2023/06/24/Window/Window开发环境配置/","content":"Windows 开发环境配置 + 软件配置。 一、环境配置 Windows 的环境变量配置比较简单，它是以键值对（key-value）的方式配置的。 在 Windows 系统中，有两种变量：用户变量和系统变量。 用户变量：只有当前登录用户能可以使用的变量，类似于 Linux 系统中用户目录下的 .bashrc 文件； 系统变量：对所有用户生效、所有用户可以使用的变量，类似于 Linux 系统中的 /etc/profile 文件； 本文都以配置 系统变量 为例，但是配置方式不限，配置的 value 路径要替换自己本机的安装路径。Windows 配置变量一般有两种方式： 直接在 Path 里编辑添加软件的执行文件所在的目录（一般是软件的 bin 目录）。 新建一个变量，设置变量名称（一般随便起，部分有约定，比如 JAVA_HOME，很多需要 java 环境的软件默认查询 JAVA_HOME 变量名）和路径（安装软件的根目录）的 key-value，然后在 Path 中引用 %key%。 本文使用命令行测试时，工具可以是 PowerShell(PS)、cmd、Git Bash(推荐)、cmder 等。为了防止出错，最好使用管理员身份运行这些工具。 1. JDK 第一个配置附带了截图，后面的就不带了 😉，只是帮助理解一下上面的第二种配置说明。第一种是比较简单的，直接把软件执行程序路径添加在 Path 中。 key value JAVA_HOME D:\\software\\java CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar Path 配置 %JAVA_HOME%\\bin 命令行测试：java -version Tip： jdk1.5 以后 CLASSPATH 可以不用再进行设置; 2. Maven Maven 官网下载特别慢，甚至打不开，可以在 https://archive.apache.org/dist/maven/maven-3/ 下载。 key value M2_HOME D:\\develop\\software\\maven-3.9.6 Path: %M2_HOME%\\bin 命令行测试：mvn -version 配置腾讯 maven 镜像源： .../maven-3.9.6/conf/setting.xml123456&lt;mirror&gt; &lt;id&gt;nexus-tencentyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus tencentyun&lt;/name&gt; &lt;url&gt;https://mirrors.tencent.com/nexus/repository/maven-public/&lt;/url&gt;&lt;/mirror&gt; 3. Gradle Gradle 推荐使用最新版的 IDEA(2023.3.x+)，能够使得本地的 Gradle 的作用发挥出来，否则还是推荐配置 GRADLE_USER_HOME 环境变量。这样 IDEA 下载新版本或者依赖的时候优先下载到这个文件夹中而不会使用默认 C 盘的目录。 本地 下载 解压。配置环境变量： key value GRADLE_HOME D:\\develop\\software\\gradle-8.5 PATH: %GRADLE_HOME%\\bin 命令行测试：gradle -V 配置下载源： .../gradle-8.5/init.d/init.gradle1234567891011121314151617181920212223242526272829fun RepositoryHandler.enableMirror() &#123; all &#123; if (this is MavenArtifactRepository) &#123; val originUrl = this.url.toString().removeSuffix(&quot;/&quot;) urlMappings[originUrl]?.let &#123; logger.lifecycle(&quot;Repository[$url] is mirrored to $it&quot;) this.setUrl(it) &#125; &#125; &#125;&#125;val urlMappings = mapOf( &quot;https://repo.maven.apache.org/maven2&quot; to &quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;, &quot;https://dl.google.com/dl/android/maven2&quot; to &quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;, &quot;https://plugins.gradle.org/m2&quot; to &quot;https://mirrors.tencent.com/nexus/repository/gradle-plugins/&quot;)gradle.allprojects &#123; buildscript &#123; repositories.enableMirror() &#125; repositories.enableMirror()&#125;gradle.beforeSettings &#123; pluginManagement.repositories.enableMirror() dependencyResolutionManagement.repositories.enableMirror()&#125; gradle 下载源查找顺序 123456789101112# 排列顺序即加载顺序 * 代表可以为任意名称~/.gradle/init.gradle~/.gradle/init.d/*.gradleGRADLE_HOME/init.d/*.gradleGRADLE_USER_HOME/init.gradleGRADLE_USER_HOME/init.d/*.gradle# Gradle 查找依赖的顺序# M2_HOME 是 Maven 的配置~/.m2/settings.xmlM2_HOME/conf/settings.xml~/.m2/repository GRADLE_HOME 是本地安装的 Gradle 软件目录。 4. MySQL 使用安装文件（exe 或者 msi）安装一般没有什么问题，安装过程中会提示将安装路径加入环境变量。 这里只介绍使用 压缩包 的方式。 key value MYSQL_HOME D:\\software\\MySQL8.0 Path: %MYSQL_HOME%\\bin 命令行运行以下命令完成初始化： 123456789101112131415161718# service-name 自己命名，如果不写默认为 mysql，只安装一个版本使用的话可以不指定# 在安装多个不同版本 MySQL 的时候很有用mysqld --install [service-name]# 移除 MySQL 服务mysqld --remove [service-name]# 下面的命令二选一：分别是 无密码版 和 带密码版# 使用不安全的初始化（即不生成初始密码）mysqld --initialize-insecure --console# 如果需要生成初始化密码，则使用以下命令。--console 选项把生成的密码打印到控制台（需要查看密码保存）mysqld --initialize --console# 启动 MySQL 服务net start [service-name]# 进入 MySQL bashmysql -u root -p# 修改密码alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;yourpassword&#x27;; 开启远程访问： 12345678mysql -u root -p# MySQL 5.xgrant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;yourpassword&#x27;;flush privileges;# MySQL 8.xgrant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;yourpassword&#x27; with grant option;flush privileges; TIP：安装多个不同 MySQL 版本的时候，需要先 新建/编辑 my.ini 文件先修改端口号再初始化（即生成 data 目录），避免端口冲突。 5. MariaDB key value MARIA_HOME D:\\software\\mariadb-11.0.2 Path: %MARIA_HOME%\\bin 命令行运行以下命令完成初始化： D:\\software\\mariadb-11.0.2\\bin123456# 名称自己起mysqld.exe --install [service-name]# 初始化数据库，生成 data 文件夹以及配置信息mysql_install_db# 启动net start [service-name](上面安装时起的名称) 配置文件（如果本机安装之前还有 MySQL 数据库，推荐解压后先修改配置文件，更改默认端口）： .../mariadb-11.0.2/data/my.ini12345678910111213141516171819202122232425262728[mysqld]; 文件目录datadir=D:/software/mariadb-11.0.2/dataport = 3333; 字符集设置character-set-server = utf8mb4collation-server = utf8mb4_general_ciskip-character-set-client-handshake[client]plugin-dir=D:/software/mariadb-11.0.2/lib/plugin; 客户端连接端口port=3333[mariadb]feedback=off; 指定端口port = 3333; 默认创建数据库的类型default-storage-engine = InnoDB; 最大连接数max_connections = 100; 慢查询slow_query_log_file = slow.logslow_query_log = 0log_queries_not_using_indexes = 1long_query_time = 0.5min_examined_row_limit = 100 如果本机已经安装了 MySQL 数据库，那么使用这种方式安装需要在初始化数据库后，先修改 my.ini 文件，修改端口号避免端口占用导致启动失败，然后启动服务。 FEEDBACK 启动成功但是连接失败官方说明：https://mariadb.com/kb/en/feedback-plugin/ 官方配置文档：https://mariadb.com/kb/en/configuring-mariadb-with-option-files/ Unicode 排序规则：https://www.monolune.com/articles/mysql-utf8-charsets-and-collations-explained/ 6. PostgreSQL Path：D:\\software\\pgsql\\bin 命令行运行以下命令完成初始化： D:\\software\\pgsql\\bin1234567891011# 初始化 initdb --help 查看帮助信息# -D data 指定初始化的数据库目录(此处为当前目录的data文件夹)# -E utf8 数据库编码格式# -U postgres 超级管理员名称# -A 使用密码授权initdb.exe -D &quot;D:\\software\\develop\\pgsql\\data&quot; -E UTF8 -U postgres -W# 注册服务 -N 指定服务名称pg_ctl register -N &quot;postgresql&quot; -D &quot;D:\\software\\develop\\pgsql\\data&quot;# 启动pg_ctl -D &quot;D:\\software\\pgsql\\data&quot; -l logfile start Navicat 15.x 连接时报错 ”datlastsysoid“ 字段不存在，估计需要 Navicat 16 吧，后续经验证，16 完美支持无报错； 如果使用最新版本的 PG 可以使用官方提供的客户端 pgAdmin4，可在设置中调整为中文界面(目前缺点就是启动响应较慢)，推荐使用开源的 Dbeaver 或者其它 GUI 管理工具； pgsql 的配置文件在 data 文件夹中 postgres.conf。 pgAdmin4界面示例 7. Tomcat Tomcat 有安装版和压缩包两种，如果是安装版，需要先配置好jdk。 key value CATALINA_HOME D:\\software\\tomcat8.5 Path：%CATALINA_HOME%\\bin。 Tomcat启动的日志输出的默认字符集编码是 utf-8，但是 window 的 shell 是 gbk 编码，所以如果想要在 window 下正常输出，就要修改 Tomcat 的日志打印编码。 编辑tomcat安装路径下的 conf/logging.properties 文件,找到以下内容并修改； java.util.logging.ConsoleHandler.encoding = GBK，保存重启即可。 8. NodeJs Windows 中安装的 nodejs.msi 中自带了 npm，而 Linux 需要单独安装（使用包管理器的时候）。另外，Windows 中安装后需要修改安装目录的权限，不然只有管理员才能操作该目录，对于当前用户是非常不方便的。 在安装目录即 nodejs 文件夹，单击右键，选择属性，点击 “安全” 标签，选择 “User” 用户，点击编辑，把权限都勾上，保存退出。 命令行做一些配置： 12345678# 配置阿里镜像源npm config set registry https://mirrors.cloud.tencent.com/npm/# 设置全局安装目录（需要先手动创建）npm config set prefix &quot;D:\\software\\develop odejs ode_global&quot;# 设置全局缓存目录（需要先手动创建）npm config set cache &quot;D:\\software\\develop odejs ode_cache&quot;# 查看修改是否成功npm config list Path：D:\\software\\develop odejs ode_global 配置 Path 是为了使用 全局安装 的工具（例如 yarn、pnpm 等）。 阿里镜像源：https://registry.npmmirror.com 9. Jetty 官方文档https://www.eclipse.org/jetty/documentation/jetty-11/operations-guide/index.html 下载后解压，之后进入 jetty 的安装目录。运行以下命令($JETTY_HOME 是安装目录)： 12345678910# 为当前基目录添加标准文件及文件夹java -jar $JETTY_HOME/start.jar --add-to-startd=http,deploy# 创建demo演示，不然启动后是404页面java -jar $JETTY_HOME/start.jar --add-module=demo# 启动jetty服务java -jar $JETTY_HOME/start.jar# 如果不想用8080，可以使用以下命令在启动时动态修改# 也可以修改配置文件，使其永久生效java -jar $JETTY_HOME/start.jar jetty.http.port=9999 之后就可以在浏览器使用 localhost:9999 进行访问了。 10. Rust 创建 ~/.cargo/config 文件，编辑填写以下内容，保存。 ~/.cargo/config12345[source.crates-io]replace-with = &#x27;mirror&#x27;[source.mirror]registry = &quot;sparse+https://mirrors.bfsu.edu.cn/crates.io-index/&quot; 11. Python 123# 设置镜像源python -m pip install -i https://mirrors.bfsu.edu.cn/pypi/web/simple --upgrade pippip config set global.index-url https://mirrors.bfsu.edu.cn/pypi/web/simple 二、软件 1. VsCode 自 VsCode 1.7x 版本之后 exe 安装文件也可以选择安装路径了，并且国内下载速度也很快，但是插件默认依然在 C 盘中，当然你可以打一个软连接映射，或者使用便携版本来自定义插件的安装位置。 2. Vivaldi Vivaldi 官网在国内是访问不到的，可以在 hosts 文件中添加以下内容再次访问： C:\\Windows\\System32\\drivers\\etc\\hosts1172.67.21.227 vivaldi.com www.vivialdi.com update.vivaldi.com downloads.vivaldi.com help.vivaldi.com bifrost.vivaldi.com mimir.vivaldi.com 三、插件 插件在精不在多。 1. 油猴插件 网盘链接检查：(自动识别并标记百度云、蓝奏云、腾讯微云和天翼云盘的链接状态) 网盘直链下载助手（需要关注公众号，目前好用的不多了） 链接助手 Github 增强 - 高速下载 CSDN/知乎/哔哩哔哩/简书免登录去除弹窗广告 增强版 CSDN/知乎/哔哩哔哩/简书免登录去除弹窗广告（推荐） 2. Edge 可可翻译 JSON Beautifier &amp; Editor AdGuard 图片下载 Tampermonkey BETA 3. 火狐 可可翻译 Circle 阅读助手基础版 火狐新版本默认在当前标签页中选择收藏夹的标签单击打开时会覆盖当前页，而以前会新打开一个标签页： 地址栏输入 about:config 回车，搜索 browser.search.openintab、browser.urlbar.openintab、browser.tabs.loadBookmarksInTabs 三个选项的值都设置为 true 即可。 4. IDEA Generate All Getter And Setter Log Support 2 Translation 推荐使用 2021.2.2 及以下版本。 jetbrains active server Fofa 1header=&quot;https://account.jetbrains.com/fls-auth&quot; Shodan 1Location: https://account.jetbrains.com/fls-auth Censys 1Location: https://account.jetbrains.com/fls-auth 四、其它 1. 命令操作 目标 操作 控制面板 win + r 输入 appwiz.cpl 回车 系统变量 win + r 输入 sysdm.cpl 回车 磁盘管理 win + r 输入 diskmgmt.msc 回车 服务 win + r 输入 services.msc 回车 电脑信息 win + r 输入 winver 回车 2、删除开机多余启动项 Win + R，输入 `msconfig`，点击确定，选择 “引导” 标签，选择 **非当前OS** 记录，点击删除并应用，按照提示重启即可。 管理员身份命令行运行： 1234# 查看启动项efibootmgr# 删除对应的项efibootmgr -b 0001(序号) -B 3. PowerShell 运行脚本报错 管理员身份命令行运行 12# 输入以下命令，选择 Yset-executionpolicy RemoteSigned PS 有四种策略： 策略 说明 Restricted 禁止运行任何脚本配置文件（默认） AllSigned 可以运行发布签名的脚本和配置文件，包括本地计算机上编写的脚本 RemoteSigned 要求从网络上下载的脚本和配置文件由可信者发布签名，不要求本地计算机上编写的脚本进行签名 Unrestricted 可以运行未签名的脚本 4. Vmware 虚拟机配置双网卡 虽然 Win 下的 WSL 广受好评，但是浪子懒得折腾，不折腾使用还是不太方便。还是比较喜欢使用 Vmware 创建 Linux 环境，虽然它很吃内存。。。但也没办法 😌 使用 VMWare 时，推荐创建的虚拟机配置双网卡，默认的使用 NAT 模式，新添加一个使用 仅主机 模式，然后进行修改配置。这样就算以后连接无数个无线网，电脑依然能上网，但是使用 SSH 远程连接时依然不用修改 Linux 的网络配置文件。实现了一次配置，永久使用的效果。配置也很简单： 在 VMWare 里创建一个虚拟机后，打开改虚拟机的设置，硬件下方的”添加“，然后在弹出的列表里选择”网络适配器“，之后点击新添加的网络适配器，选择”仅主机“。 然后打开网络适配器修改 VMWare Network Adapter VMnet1 的 IP 为简单的地址，Linux 里的网络配置文件的 IP 地址不要和这个一样，因为 VM1 是本机和 Linux 虚拟机通信的 IP 地址，不能一样，推荐 VM1 10.0.0.1，Linux 配置为 10.0.0.2，简单好记。 注意： 如果是新建的虚拟机，在安装之前按照以上方法配置，安装后查看网络配置文件时或许会有两个不同的文件，比如：ens33，ens34。如果是之前已经安装过的单网卡想要配置双网卡，可以把已经存在网络配置文件复制一份，修改文件里面的内容即可。如果新建的虚拟机也是只有一个配置文件，也可以直接复制原有的文件进行修改。 另外，第一次安装后网络服务是正常的，之后换了一个无线网连接就出现了问题，可能是因为 NetworkManager 的问题，可以关闭此服务。然后重启网络。内网相通，但使用 xshell 等终端工具连不上虚拟机也连不上外网也可以尝试使用这个方法。 12345678# 关闭服务systemctl stop NetworkManager# 禁止开机启动systemctl disable NetworkManager# chkconfig NetworkManager off# 重启网络systemctl restart network 参考文章地址https://blog.csdn.net/weistin/article/details/80676955 CentOS 用的好好的虚拟机，之前内网都通，后面使用的时候使用 SSH 工具连不上虚拟机了，并且虚拟机也连不上外网 12345# 1.停止并关闭 networkmanager 服务systemctl stop NetworkManagersystemctl disable NetworkManager# 2.重启网络systemctl restart network 参考原博客地址 其它问题 使用 VMWare 虚拟机时，如果本机开启着 VPN 时，使用其它远程工具是无法连接到本地虚拟机的，必须退出 VPN 的登录后才可以再次连接新的会话。","tags":["配置"],"categories":["Windows"]},{"title":"Vsocde、Fleet配置备份","path":"/2023/06/24/配置备份/一些编辑器配置备份/","content":"一些编辑器配置备份文件：VSCode、Fleet VsCode（1.86+） 整体配置 编辑器配置都是内置，不需要安装任何插件。 settings.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181&#123; // ***************************************************************** // ***************************************************************** // ************************ Vscode start *************************** // ***************************************************************** // ***************************************************************** // vscode 默认主题之一 &quot;workbench.colorTheme&quot;: &quot;Quiet Light&quot;, // 焦点移动时自动保存文件内容 &quot;files.autoSave&quot;: &quot;onFocusChange&quot;, // 1s 后自动保存，必须设置 &quot;files.autoSave&quot;: &quot;afterDelay&quot;，否则该项无效 // &quot;files.autoSaveDelay&quot;: 1000, // 保存时自动格式化内容，&quot;files.autoSave&quot; 不能设置为 &quot;afterDelay&quot;，否则无效 &quot;editor.formatOnSave&quot;: true, &quot;editor.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;, &#x27;霞鹜文楷&#x27;, &#x27;苹方&#x27;, &#x27;文泉驿微米黑&#x27;&quot;, // 编辑器字体大小和设置 &quot;editor.fontSize&quot;: 16, // 启用连字 &quot;editor.fontLigatures&quot;: true, // 行高 &quot;editor.lineHeight&quot;: 23, // 字间距 &quot;editor.letterSpacing&quot;: 0.5, // 自动显示空白字符(例如空格和 Tab)，如果你有密集恐惧症，请恢复为默认配置 selection &quot;editor.renderWhitespace&quot;: &quot;all&quot;, // 保存时自动优化导入包 &quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll&quot;: &quot;explicit&quot;, &quot;source.organizeImports&quot;: &quot;explicit&quot; &#125;, // ########################### JavaScript/TypeScript ########################### // 启用或禁用在 VS Code 中重命名或移动文件时自动更新导入路径的功能。always：一直自动更新 &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;, // js、ts 函数完成时自动加括号 &quot;javascript.suggest.completeFunctionCalls&quot;: true, &quot;typescript.suggest.completeFunctionCalls&quot;: true, // ########################### markdown ########################### // 在 markdown 中开启代码片段 &quot;[markdown]&quot;: &#123; &quot;editor.quickSuggestions&quot;: &#123; &quot;comments&quot;: &quot;off&quot;, &quot;strings&quot;: &quot;off&quot;, &quot;other&quot;: &quot;on&quot; &#125; &#125;, // ########################### 终端配置 ########################### // 终端光标样式 &quot;terminal.integrated.cursorStyle&quot;: &quot;line&quot;, &quot;terminal.integrated.cursorWidth&quot;: 2, // 终端光标是否闪烁 &quot;terminal.integrated.cursorBlinking&quot;: true, // 终端可使用 bash 列表，可以查看终端下拉列表，如果不想显示，置为 null 即可，比如 &quot;PowerShell&quot;: null &quot;terminal.integrated.profiles.windows&quot;: &#123; &quot;PowerShell&quot;: &#123; &quot;source&quot;: &quot;PowerShell&quot;, &quot;icon&quot;: &quot;terminal-powershell&quot; &#125;, &quot;Command Prompt&quot;: &#123; &quot;path&quot;: [ &quot;$&#123;env:windir&#125;\\\\Sysnative\\\\cmd.exe&quot;, &quot;$&#123;env:windir&#125;\\\\System32\\\\cmd.exe&quot; ], &quot;args&quot;: [], &quot;icon&quot;: &quot;terminal-cmd&quot; &#125;, &quot;Git Bash&quot;: &#123; &quot;source&quot;: &quot;Git Bash&quot;, &quot;icon&quot;: &quot;git-branch&quot; &#125; &#125;, // 默认的控制台使用 git bash &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git Bash&quot;, // 终端选中内容自动复制到剪切板 &quot;terminal.integrated.copyOnSelection&quot;: true, // 按住 Ctrl 的同时通过鼠标滚轮放大、缩小终端 // &quot;terminal.integrated.mouseWheelZoom&quot;: true, // ***************************************************************** // ***************************************************************** // ************************ Vscode end *************************** // ***************************************************************** // ***************************************************************** // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ // ++++++++++++++++++++++++ Plugin start +++++++++++++++++++++++++++ // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ // ########################### Markdown Preview Enhanced插件 ########################### // https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced &quot;markdown-preview-enhanced.codeBlockTheme&quot;: &quot;default.css&quot;, &quot;markdown-preview-enhanced.previewTheme&quot;: &quot;vue.css&quot;, &quot;markdown-preview-enhanced.printBackground&quot;: true, // ############################# Python 插件 ############################# // 自动导入 &quot;python.analysis.autoImportCompletions&quot;: true, // 函数完成时自动加入括号 &quot;python.analysis.completeFunctionParens&quot;: true, // ############################# Rust crates 插件 ############################# // https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates // Cargo.toml 依赖查询使用北外语镜像地址 &quot;crates.indexServerURL&quot;: &quot;https://mirrors.bfsu.edu.cn/crates.io-index&quot;, // ############################# Java ############################# // 扩展名称： https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack &quot;java.configuration.runtimes&quot;: [ &#123; // 名称，随便起，多个的话必须唯一 &quot;name&quot;: &quot;JavaSE-21&quot;, // jdk 路径，配置环境变量的路径 &quot;path&quot;: &quot;D:\\\\software\\\\develop\\\\Java\\\\graalvm-jdk-21.0.2+13.1&quot;, // 源码路径 &quot;sources&quot;: &quot;D:\\\\software\\\\develop\\\\Java\\\\graalvm-jdk-21.0.2+13.1\\\\lib\\\\src.zip&quot;, // VsCode 默认使用这个版本的 jdk &quot;default&quot;: true, &#125;, &#123; // 名称，随便起，多个的话必须唯一 &quot;name&quot;: &quot;JavaSE-17&quot;, // jdk 路径，配置环境变量的路径 &quot;path&quot;: &quot;/usr/lib/jvm/java-17-openjdk&quot;, // 源码路径 &quot;sources&quot;: &quot;/usr/lib/jvm/java-17-openjdk/lib/src.zip&quot;, &#125;, ], // java 文件自动组织导入的包 &quot;java.saveActions.organizeImports&quot;: true, // vscode 包结构展示效果 flat：平面；hierarchical：分层 &quot;java.dependency.packagePresentation&quot;: &quot;hierarchical&quot;, // 不使用 gradle-wrapper.properties 的属性 &quot;java.import.gradle.wrapper.enabled&quot;: false, // 设置默认的 gradle 版本 &quot;java.import.gradle.version&quot;: &quot;8.5&quot;, // 本地 gradle 路径 &quot;java.import.gradle.home&quot;: &quot;/home/xxx/software/gradle-8.5&quot;, &quot;java.import.gradle.java.home&quot;: &quot;/usr/lib/jvm/java-17-openjdk&quot;, // GRADLE_USER_HOME 路径 &quot;java.import.gradle.user.home&quot;: &quot;/home/xxx/software/gradle-repo/&quot;, // Maven 配置 settings.xml 路径 &quot;java.configuration.maven.globalSettings&quot;: &quot;/home/xxx/software/maven-3.9.6/conf/settings.xml&quot;, // maven 执行文件路径 &quot;maven.executable.path&quot;: &quot;/home/xxx/software/maven-3.9.6/bin/&quot;, // ########################### Draw.io Integration插件 ########################### // https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio // Draw.io Integration 配置：添加自定义字体选项、设置默认主题 &quot;hediet.vscode-drawio.customFonts&quot;: [ &quot;JetBrains Mono&quot;, &quot;Fira Code&quot;, &quot;苹方&quot;, &quot;文泉驿微米黑&quot; ], &quot;hediet.vscode-drawio.theme&quot;: &quot;Kennedy&quot;, // ########################### picgo 插件 ########################### // https://marketplace.visualstudio.com/items?itemName=Spades.vs-picgo // 安装 PicGo 软件，使用 PicGo 插件只需要配置一个 configPath // 本机安装了 PicGo 客户端第一次启动后会自动生成 json 文件 // &quot;picgo.configPath&quot;: &quot;C:\\\\Users\\\\你的用户名\\\\AppData\\\\Roaming\\\\picgo\\\\data.json&quot;, // 上面的选项如果配置了，下面的无须配置（前提是安装了客户端软件）。 // 只使用 VsCode PicGo 插件，需要配置以下信息 // 当前使用图床 可选：weibo, qiniu, tcyun, upyun, github, aliyun, imgur and SM.MS &quot;picgo.picBed.current&quot;: &quot;github&quot;, &quot;picgo.picBed.uploader&quot;: &quot;github&quot;, // 设定分支 &quot;picgo.picBed.github.branch&quot;: &quot;branch&quot;, // 设定仓库 &quot;picgo.picBed.github.repo&quot;: &quot;username/repo&quot;, // token &quot;picgo.picBed.github.token&quot;: &quot;token&quot;, // 自定义返回的链接 &quot;picgo.picBed.github.customUrl&quot;: &quot;url&quot;, // 上传路径 &quot;picgo.picBed.github.path&quot;: &quot;repo-path&quot;, // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ // +++++++++++++++++++++++++ Plugin end ++++++++++++++++++++++++++++ // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&#125; 代码片段配置 code-snippets12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// ####################### js ###########################\t&quot;Print to annotation&quot;: &#123; &quot;prefix&quot;: &quot;annotation&quot;, &quot;body&quot;: [ &quot;/**&quot;, &quot; * @author jhlz&quot;, &quot; * @description: $&#123;1&#125;&quot;, &quot; * @date: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;&quot;, &quot; */&quot; ], &quot;description&quot;: &quot;&quot;\t&#125;,\t// ################################## json ###############################\t&quot;package.json config&quot;: &#123; &quot;scope&quot;: &quot;json&quot;, &quot;prefix&quot;: &quot;config&quot;, &quot;body&quot;: [ &quot;\\&quot;config\\&quot;: &#123;&quot;, &quot; \\&quot;commitizen\\&quot;: &#123;&quot;, &quot; \\&quot;czConfig\\&quot;: \\&quot;$0\\&quot;&quot;, &quot; &#125;&quot;, &quot;&#125;&quot;, ], &quot;description&quot;: &quot;czg 使用自定义的配置文件&quot;\t&#125;,\t// ################################### md ###################################\t&quot;table generate&quot;: &#123; &quot;scope&quot;: &quot;markdown&quot;, &quot;prefix&quot;: &quot;tb-md&quot;, &quot;body&quot;: [ &quot;|$1|$2|&quot;, &quot;|--|--|&quot;, ], &quot;description&quot;: &quot;table generate&quot;\t&#125;,// ########################################################// ######################### Java #########################// ########################################################&#123; &quot;log info&quot;: &#123; &quot;scope&quot;: &quot;java&quot;, &quot;prefix&quot;: &quot;logi&quot;, &quot;body&quot;: [ &quot;log.info(\\&quot;$1\\&quot;, $2)&quot; ], &quot;description&quot;: &quot;generator java log.info()&quot;\t&#125;,\t&quot;log error&quot;: &#123; &quot;scope&quot;: &quot;java&quot;, &quot;prefix&quot;: &quot;loge&quot;, &quot;body&quot;: [ &quot;log.error(\\&quot;$1\\&quot;, $2)&quot; ], &quot;description&quot;: &quot;generator java log.error()&quot;\t&#125;,\t&quot;log debug&quot;: &#123; &quot;scope&quot;: &quot;java&quot;, &quot;prefix&quot;: &quot;logd&quot;, &quot;body&quot;: [ &quot;log.debug(\\&quot;$1\\&quot;, $2)&quot; ], &quot;description&quot;: &quot;generator java log.debug()&quot;\t&#125;,\t&quot;java doc&quot;: &#123; &quot;scope&quot;: &quot;java&quot;, &quot;prefix&quot;: &quot;jdoc&quot;, &quot;body&quot;: [ &quot;/**&quot;, &quot; *&quot;, &quot; * @author $&#123;1:user&#125;&quot;, &quot; * @since 1.0.0&quot;, &quot; */&quot; ],\t&quot;description&quot;: &quot;generator java class basic info&quot;\t&#125;,&#125; 生成时间方式：@date $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125; Fleet 配置参见官网：https://www.jetbrains.com/help/fleet/settings.html#user-settings settings.json12345678910111213141516171819202122232425262728293031323334353637&#123; // 主题 &quot;theme&quot;: &quot;dark_purple&quot;, // 字体大小 &quot;editor.fontSize&quot;: 16.0, // 保存时格式化文本 &quot;editor.formatOnSave&quot;: true, // 使用组合键键时显示所用组合键 &quot;showShortcuts&quot;: true, // 快捷键映射，这里采用了 vscode 的 &quot;keymap&quot;: &quot;pc-vscode&quot;, // ############# 终端配置 ############# &quot;terminal.profiles&quot;: [ &#123; &quot;program&quot;: &quot;D:\\\\software\\\\Git\\\\bin\\\\bash.exe&quot;, &quot;args&quot;: [], // optional &quot;name&quot;: &quot;git-bash&quot; // optional &#125; ], // 终端：复制选中文本 &quot;terminal.copyOnSelection&quot;: true, // 终端字体大小 &quot;terminal.fontSize&quot;: 15.0, // ############# Java ############## &quot;maven.user.settings&quot;: [ &#123; &quot;path&quot;: &quot;D:\\\\xxx\\\\Java\\\\maven-3.9.6\\\\conf\\\\settings.xml&quot; &#125; ], &quot;java.runtimes&quot;: [ &#123; &quot;path&quot;: &quot;D:\\\\xxx\\\\Java\\\\jdk1.8.0_361&quot; &#125; ],&#125; VIM /etc/vim/vimrc1234567891011121314151617181920212223242526272829&quot; 文件编码set encoding=utf-8set fileencoding=utf-8&quot; 自动缩进set autoindent&quot; 新行智能自动缩进set smartindent&quot; 状态栏标尺set ruler&quot; 语法高亮 vim5 之后默认开启set syntax=on&quot; Tab键的宽度set tabstop=4&quot; 搜索忽略大小写set ignorecase&quot; 高亮显示匹配的括号set showmatch&quot; 总是显示行号set nu&quot; 侦测文件类型filetype on&quot; 状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\\ [FORMAT=%&#123;&amp;ff&#125;]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %&#123;strftime(\\&quot;%d/%m/%y\\ -\\ %H:%M\\&quot;)&#125;&quot; 总是显示状态行set laststatus=2&quot; 高亮搜索的文本set hlsearch","tags":["配置备份"],"categories":["配置备份"]},{"title":"【Linux】 CentOS 服务器配置","path":"/2023/06/24/Linux/CentOS/CentOS服务器配置/","content":"此篇文章以后随缘更新，这个系统的相关问题网上一般都有答案，浪子个人已不再使用 CentOS 系统。 一、CentOS7最小安装 1、配置网卡 2、关闭防火墙以及 Linux 的一些安全策略 3、配置本地 yum 源 4、安装常用工具 5、安装依赖关系 6、修改yum源 7. rpm命令 8. lrzsz：文件上传下载 二、部署服务 1. Redis 2. RabbitMQ 3. Python 4. Nginx 5. Btop++ 6. FFmpeg 7. MySQL（解压版） 问题一：密码正确但是进不去 bash 环境 问题二：预读处理 问题三：Can‘t connect to local MySQL server through socket ‘/tmp/mysql.sock‘ (2) 三、附 1. 关于源码编译安装失败 2. 防火墙 CentOS 7 firewall 基础使用 CentOS 6 iptables 基础使用 一、CentOS7最小安装 1、配置网卡 先进行网络的连接，编辑网络配置文件（vi /etc/sysconfig/network-scripts/ifcfg-ens32），不同的机器最后的文件名称可能不同，一般都是 ifcfg- 开头。 1234567# 空着的部分自定义即可BOOTPROTO=staticONBOOT=yesIPADDR=NETMASK=GATEWAY=DNS1= 设置完成后，保存退出，使用命令 systemctl restart network 重启网卡。 2、关闭防火墙以及 Linux 的一些安全策略 123456systemctl stop firewalldsystemctl disable firewalldsed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/configsetenforce 0 3、配置本地 yum 源 12345678# 进入目录cd /etc/yum.repos.d/# 创建 备份 文件夹mkdir bak# 移动该目录下的所有文件到备份文件夹mv * bak# 拷贝一份文件进行编辑cp bak/CentOS-Media.repo /etc/yum.repos.d/CentOS-Media.repo 编辑刚才我们拷贝的文件：vi CentOS-Media.repo，这就是安装软件时读取的安装源配置，加入以下内容，先使用本地镜像安装。 12345[linux]name=linuxbaseurl=file:///media/gpgcheck=0enabled=1 清除yum缓存：yum -y clean all 重建yum缓存：yum makecache 4、安装常用工具 yum -y install curl telnet vim wget lrzsz net-tools 修改vim配置（可以不修改，按照默认的即可，这里仅仅是偏好） 12345678910vim ~/.vimrcset encoding=utf-8 &quot; 文件编码set number &quot; 显示行号set tabstop=4 &quot; tab宽度为4set softtabstop=4 &quot; 设置一次可以删除4个空格set expandtab &quot; tab转换为空格set nowrap &quot; 不自动换行set showmatch &quot; 显示括号配对情syntax on &quot; 开启语法高亮 5、安装依赖关系 yum -y install gcc gcc-c++ make autoconf wget lrzsz libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5-devel libidn libidn-devel openssl openssl-devel libxslt-devel libevent-devel libtool libtool-ltdl bison gd gd-devel vim-enhanced pcre-devel zip unzip ntpdate sysstat patch bc expect rsync 6、修改yum源 12345678910# 复制文件cp /etc/yum.repos.d/bak/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo# 进入目录cd /etc/yum.repos.d/# 添加 网易 的下载源wget http://mirrors.163.com/.help/CentOS6-Base-163.repo# 重建缓存yum makecache# 更新源yum -y update 如果不想使用 wget http://mirrors.163.com/.help/CentOS6-Base-163.repo 的话，可以自己编辑：/etc/yum.repos.d/CentOS-Base.repo 这个文件(以下是用的清华源)。编辑完成之后更新库，这时需要网络。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.##[base]name=CentOS-$releasever - Base#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infrabaseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#released updates [updates]name=CentOS-$releasever - Updates#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates&amp;infra=$infra#baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extras#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra#baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus&amp;infra=$infra#baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 7. rpm命令 12345678# 安装rpm -ivh xxx.rpm# 卸载rpm -evh xxx.rpm# 更新rpm -Uvh xxx.rpm# 显示所有已安装软件rpm -qa 8. lrzsz：文件上传下载 123456# 安装yum install -y lrzsz# 下载sz# 上传rz 二、部署服务 1. Redis 官网源码下载https://redis.io/download/ 123456# 安装编译 redis 需要的工具sudo yum -y install gcc automake autoconf libtool make# 进入解压目录，进行编译，直到编译完成make MALLOC=libc# 安装到指定路径make install PREFIX=/usr/local/redis Redis 的默认的配置文件在源码解压后的目录中 2. RabbitMQ RabbitMQ 是使用 Erlang 语言编写的中间件，联想一下 Java，我们可以猜到它需要先搭建 Erlang 环境。主要是这个环境需要编译源码，RabbitMQ 本身官网提供了二进制压缩包。 Erlang源码下载https://www.erlang.org/downloads 一、Erlang环境搭建 12345678910111213141516171819# 安装编译 Erlang 的相关依赖yum install gcc glibc-devel make ncurses-devel openssl-devel xmlto# 解压源码包tar -zxvf otp_src_24.1.7.tar.gzcd otp_src_24.1.7/# 指定安装目录./configure --prefix=/usr/local/erlang# 编译安装make &amp;&amp; make install# 测试安装是否成功：cd /usr/local/erlang/bin/./erl# 安装成功后配置环境变量 vim /etc/profileexport PATH=$PATH:/usr/local/erlang/bin# 添加完成保存退出，刷新使其生效source /etc/profile 二、安装Rabbitmq 通过第一步，我们就搭建好了 Erlang 环境，接下来就是安装 RabbitMQ 了，这个还是比较简单的，因为它已经编译好了，我们可以下载直接配置，无需编译。 二进制文件包下载https://www.rabbitmq.com/install-generic-unix.html 123456789# 解压tar -Jxvf rabbitmq-server-generic-unix-3.9.11.tar.xz# 移动mv rabbitmq_server-3.9.11 /usr/local/rabbitmq# 添加环境变量：vim /etc/profileexport PATH=$PATH:/usr/local/rabbitmq/sbin# 刷新变量source /etc/profile 3. Python Linux 下基本不需要配置 Python 的环境，有个别的 ISO 镜像版本比较老，比如 CentOS7 的 mini ISO 镜像是2.x的，我们可以通过各大系统的包管理工具进行安装，也可以自己通过源码编译安装。 源码下载https://www.python.org/downloads/ 12345678910111213141516171819202122# 安装相关工具和依赖yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make libffi-devel# 解压压缩包tar -zxvf Python-3.10.2.tgz # 进入文件夹cd Python-3.10.2# 配置安装位置./configure prefix=/usr/local/python3# 编译并安装make &amp;&amp; make install# 使用 python3 验证是否安装成功python3 -V#添加python3的软链接 ln -s /usr/local/python3/bin/python3.8 /usr/bin/python3 #添加 pip3 的软链接 ln -s /usr/local/python3/bin/pip3.8 /usr/bin/pip3 4. Nginx 官网源码下载https://nginx.org/en/ 12345678910111213# 解压tar -zvxf nginx-1.20.2.tar.gz# 配置安装路径./configure --prefix=/usr/local/nginx# 编译安装make &amp;&amp; make install# 进入安装目录查看是否安装成功cd /usr/local/nginx# 启动 停止 重启./nginx start./nginx -s stop./nginx -s reload 5. Btop++ Btop++ 是一个 Linux 资源监视器，显示处理器、内存、磁盘、网络和进程的使用情况和统计资料，界面美观，使用简单。这里使用了源码编译安装，但是浪子推荐下载 Github 仓库的二进制包解压运行 install.sh 脚本安装。 Github地址https://github.com/aristocratos/btop Gitee同步仓库https://gitee.com/mirrors/btop 1234567891011# 安装、升级相关依赖工具yum install coreutils sed build-essential -yyum install centos-release-scl -yyum install devtoolset-10 -yscl enable devtoolset-10 bash echo &quot;source /opt/rh/devtoolset-10/enable&quot; &gt;&gt; /etc/profile# 克隆源码编译安装git clone https://gitee.com/mirrors/btop.gitcd btopmake &amp;&amp; make install 6. FFmpeg FFmpeg使用http://www.ffmpeg.org/ 12345678910111213# 克隆源码 也可以下载 https://github.com/FFmpeg/FFmpeg/releases 相应的包上传git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg# 安装相关依赖yum install yasm.x86_64 -ycd ffmpeg./configure --enable-ffplay --enable-ffserver --prefix=/usr/local/ffmpeg# 编译安装make &amp;&amp; make install# 查看是否安装成功cd /usr/local/ffmpeg 7. MySQL（解压版） yum 方式安装：https://zhuanlan.zhihu.com/p/87069388 使用通用的 MySQL8.x 版本的二进制压缩包进行安装。至于卸载，就把有关 MySQL 创建的几个文件夹删掉就行了，/etc/my.cnf 是默认自带的，卸载的时候删不删都没有问题，如果默认没有这个文件也不必担心，可以手动添加。 1234567891011121314151617181920212223242526272829303132333435363738394041# 检查mysql用户组和用户是否存在，如果没有，则创建cat /etc/group | grep mysqlcat /etc/passwd | grep mysql# 创建 mysql 组groupadd mysql# 新建 mysql 用户并加入 mysql 群组useradd -r -g mysql mysql# 安装所需依赖(需要安装 libaio-devel.x86_64 numactl 这两个依赖)yum -y install libaio-devel.x86_64 numactl# 解压二进制文件包到 /usr/local/mysql 目录tar xxx -C /usr/local/mysqlcd /usr/local/mysql/bin# 初始化数据，成功初始化后需要记录最后 root@localhost: 后的字符串（初始化失败则不显示），它是后面进入 bash 环境的初始密码./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql# vim /etc/my.cnf(没有该文件手动创建) 修改内容basedir=/usr/local/mysqldatadir=/usr/local/mysql/dataport = 3306# 启动MySQL服务 启动成功会有 Starting MySQL.. SUCCESS! 提示；否则就是启动失败，根据提示查看日志记录定位问题cd /usr/local/mysql/support-files/mysql.server start# 添加软链接并重启服务ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql ln -s /usr/local/mysql/bin/mysql /usr/bin/mysqlservice mysql restart# systemctl restart mysql# 添加开机自启# 1、将服务文件拷贝到 init.d 下，并重命名为 mysqlcp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld# 2、赋予可执行权限chmod +x /etc/init.d/mysqld# 3、添加服务chkconfig --add mysqld# 4、显示服务列表chkconfig --list 至此，安装任务基本完成，下面需要添加用户并分配权限，进入 MySQL 的 bash 环境需要之前进行初始化时生成的密码。 123456789101112131415161718192021# 登录 MySQL，密码使用初始化成功时 root@localhost: 后的字符串mysql -u root -p# 修改密码 毕竟那么不好记# 而且如果不修改 它会报 ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 的错误alter user root@&#x27;localhost&#x27; identified by &#x27;newpassword&#x27;;flush privileges;# 开放远程连接use mysql;# ① MySQL 8.0 之前的版本，password 为自己设置的密码grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;password&#x27;;# ② 适用于 MySQL 8.0 之后的版本，推荐先创建一个用户 dev，再进行授权# 直接授权给 root# grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;password&#x27; with grant option;create user dev@&#x27;%&#x27; identified by &#x27;123456&#x27;;grant select,update,delete,insert on *.* to dev@&#x27;%&#x27; with grant option;# 刷新权限，这一句很重要，使修改生效，如果没有写，则还是不能进行远程连接。这句表示从mysql数据库的grant表中重新加载权限数据，因为MySQL把权限都放在了cache中，所以，做完修改后需要重新加载。flush privileges; 初始化成功截图： 记录日志最末尾位置 root@localhost: 后的字符串，此字符串为mysql管理员临时登录密码。 问题一：密码正确但是进不去 bash 环境 1ERROR 1045 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES/NO) 解决方法： 使用 kill 命令停止 mysqld 相关服务 cd /usr/local/mysql/bin/，运行命令： mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp; 使用密码登录数据库 mysql -u root -p 并切换到 mysql 数据库 执行命令：update user set host='%' where user='root'; 问题二：预读处理 123mysql&gt; use dbname;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -A 这个问题是之前使用的 apt-get 管理工具安装的 MySQL 出现的，原因是因爲數據庫採用了預讀處理。解决办法就是在我们进入MySQL的bash环境时，需要加入 -A 参数，不让其预读数据库信息，mysql -u root -p -A。如果覺得每次进入 bash 环境都要添加参数比较麻烦，也可以在 my.cnf 文件里加上如下內容： 12[mysql]no-auto-rehash 问题三：Can‘t connect to local MySQL server through socket ‘/tmp/mysql.sock‘ (2) 这是 my.cnf 的配置问题，下面的三块内容必须都要设置，不然就会使用默认的 socket，位于 /tmp/mysql.sock 目录，因此我们最好配置一下： /etc/my.cnf12345678910111213[mysqld]basedir=/usr/local/mysqldatadir=/usr/local/mysql/datasocket=/usr/local/mysql/mysql.sockport=3306 [client]default-character-set=utf8socket=/usr/local/mysql/mysql.sock [mysql]default-character-set=utf8socket=/usr/local/mysql/mysql.sock 或者我们打一个软链接： 1ln -s /usr/local/mysql/mysql.sock /tmp/mysql.sock 三、附 1. 关于源码编译安装失败 如果源码编译失败，先确认所需依赖是否全部成功安装，然后清除上一次编译的缓存，之后再次编译，不然会一直失败。参考网址 1234# 清除上一次编译失败的缓存make distclean# 再次编译make 2. 防火墙 CentOS 版本不同采用的防火墙管理也不同（当然，我们部署后可以安装）。CentOS 6 使用的 iptables，CentOS 7 使用的 firewall。 CentOS 7 firewall 基础使用 12345678910# 查询开放端口firewall-cmd --list-port# 开放端口firewall-cmd --zone=public --add-port=8080/tcp --permanent# 禁用端口firewall-cmd --zone=public --remove-port=8083/tcp --permanent# 重新加载firewall-cmd --reload# 再次查询开放端口firewall-cmd --list-port CentOS 6 iptables 基础使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 启动service iptables start# 关闭service iptables stop# 查看状态service iptables status# 开机禁用chkconfig iptables off# 开机启用chkconfig iptables on# 允许本地回环接口（即运行本机访问本机） -A和-I参数分别为添加到规则末尾和规则最前面。iptables -A INPUT -i lo -j ACCEPT# 允许已建立的或相关联的通行iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT# 允许所有本机向外的访问iptables -P INPUT ACCEPTiptables -A OUTPUT -j ACCEPT# 允许访问22端口 -s后可以跟 IP 段或指定 IP 地址，如果有其他端口的话，规则也类似。iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A INPUT -p tcp -s 10.159.1.0/24 --dport 22 -j ACCEPT # 允许pingiptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT# 禁止其他未允许的规则访问iptables -A INPUT -j REJECT iptables -A FORWARD -j REJECT# 屏蔽单个IPiptables -I INPUT -s 123.45.6.7 -j DROP# 封整个段即从123.0.0.1到123.255.255.254iptables -I INPUT -s 123.0.0.0/8 -j DROP# 封IP段即从123.45.0.1到123.45.255.254iptables -I INPUT -s 124.45.0.0/16 -j DROP# 封IP段即从123.45.6.1到123.45.6.254iptables -I INPUT -s 123.45.6.0/24 -j DROP# 查看已有规则 -n：只显示IP地址和端口号，不将 IP 解析为域名iptables -L -n# 将所有 iptables 以序号标记显示iptables -L -n --line-numbers# 添加规则# 添加的规则是添加在最后面。如针对 INPUT 链增加一条规则，接收从 eth0 口进入且源地址为192.168.0.0/16网段发往本机的数据iptables -A INPUT -i eth0 -s 192.168.0.0/16 -j ACCEPT# 删除规则iptables -D# 删除所有规则iptables -F# 备份规则iptables-save &gt; /etc/sysconfig/iptables.save# 使用规则iptables-restore &lt; /etc/sysconfig/iptables.save# 重启生效service iptables saveservice iptables restart 开放端口 方法一：通过命令行 123iptables -A INPUT -p tcp --dport 80 -j ACCEPTservice iptables saveservice iptables restart 方法二：编辑配置文件 编辑配置文件：vi /etc/sysconfig/iptables，添加： 12iptables -A INPUT -p tcp --dport 80 -j ACCEPTservice iptables restart","tags":["linux","centos"],"categories":["Linux"]},{"title":"【Linux】 ArchLinux/Manjaro安装一些常用软件","path":"/2023/06/24/Linux/Manjaro/Arch或Manjaro安装常用软件/","content":"整理一些 ArchLinux/Manjaro 中常用的软件。浪子更加推荐去 Arch Wiki 寻找安装方法进行安装，包括在使用中的一些问题也可以在此找到解决办法。 1. 安装助手yay、paru 如果使用过 Arch/Manjaro 系统的少侠会对这两个包管理器很熟悉，没用过的也不要紧，很简单，下面的两个博客写的都很 Nice，可以查看。 详细了解yayhttps://zhuanlan.zhihu.com/p/363666022 详细了解paruhttps://blog.askk.cc/2022/04/27/paru/index.html 2023.8.1 更新为 paru 管理器。截至目前使用 yay 的还是比较多的，如果新手或者小白推荐使用这个，出问题比较容易解决~ 2023.10.6 更新，只有 AUR 中的软件包使用 paur，移除 yay 命令说明。 什么是 AUR Arch 用户软件仓库（Arch User Repository，AUR）是为用户而建、由用户主导的 Arch 软件仓库。AUR 中的软件包以软件包生成脚本（PKGBUILD）的形式提供，用户自己通过 makepkg 生成包，再由 pacman 安装。创建 AUR 的初衷是方便用户维护和分享新软件包，并由官方定期从中挑选软件包进入 community 仓库。本文介绍用户访问和使用 AUR 的方法。 许多官方仓库软件包都来自 AUR。通过 AUR，大家相互分享新的软件包生成脚本（PKGBUILD 和其他相关文件）。用户还可以为软件包投票。如果一个软件包投票足够多、没有许可证问题、打包质量好，那么它就很有希望被收录进官方 community 仓库（以后就可以直接通过 pacman 或 abs 安装了）。 以上内容摘自：Arch Wiki（中文版）：https://wiki.archlinuxcn.org/wiki/Arch_用户软件仓库_(AUR) 英文版：https://wiki.archlinux.org/title/Arch_User_Repository 安装使用 paru 不能使用 pacman 直接安装，可以先安装 yay 后再使用 yay 安装 paru，不过这种方式的本质也是从源码安装。源码位于 Github，下载速度比较慢。 如果可以访问 Github，推荐访问作者的 paru 仓库下载作者打好的二进制包文件 paru-version-architecture.tar.zst 安装。 如果是源码安装，推荐先安装 Rust，配置一下依赖的镜像地址，避免 paru 编译时下载依赖无响应。安装 Rust： 1curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh 修改国内源镜像地址并使用稀疏索引（只支持 Rust 1.68 以上版本），创建 ~/.cargo/config 文件并加入以下内容： ~/.cargo/config12345[source.crates-io]replace-with = &#x27;mirror&#x27;[source.mirror]registry = &quot;sparse+https://mirrors.bfsu.edu.cn/crates.io-index/&quot; 安装 paru： 1234sudo pacman -S --needed base-develgit clone https://aur.archlinux.org/paru.gitcd parumakepkg -si paru 常用命令： 选项 说明 直接输入 paru，等同于 paru -Syu，更新系统 [package] 搜索 package -Si 查看软件包信息 -Sua 更新 AUR 软件 -Qua 输出可更新的 AUR 软件 -Scc 清除缓存 -Rsc 卸载该软件和没有被使用的依赖 -Rscn 卸载软件、没有被使用的依赖以及配置 -U 安装指定的软件包 12345678# 更新所有软件包，是 paru -Syu 的别名paru# 搜索 packageparu [package]# 安装paru -S [package]# 安装 zstparu -U xxx.zst 2. 中文输入法 2.1 kde、xfce 桌面推荐 fcitx5+rime 1paru -S fcitx5-im fcitx5-rime fcitx5-chinese-addons 编辑 /etc/environment 文件，没有这个文件的话可以手动创建，然后添加以下内容，之后重启电脑： /etc/environment12345GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitxSDL_IM_MODULE=fcitxGLFW_IM_MODULE=ibus fictx5 是一个输入法框架，Rime 是一个输入法，在 KDE 桌面环境下比较好用。 2.2 Gnome 桌面推荐 ibus 1paru -S ibus ibus-libpinyin GNOME 默认使用 IBus， 所以你只需要安装你需要的输入法引擎（但是 ibus 必须安装），并打开设置界面，通过“键盘”中的“输入源”添加。在你添加至少两个输入源后，GNOME 会在托盘中显示输入选择图标。如果如此操作之后你没有成功，很可能你没有完成 locale-gen。默认切换输入法的快捷键是 Super+Space; 请忽视 ibus-setup 中的添加方法，这不会真的添加新的输入法，且 ibus-setup 中的配置不会对输入法生效。 /home/user/.xprofile1234export GTK_IM_MODULE=ibusexport XMODIFIERS=@im=ibusexport QT_IM_MODULE=ibusibus-daemon -x -d 其它问题请参考Arch Wiki：https://wiki.archlinux.org/title/IBus_(简体中文)#GNOME 3. 字体 安装好了输入法，当然也要有一些字体来辅助。下面有四款开源的字体，其中，文泉驿、思源黑体、霞鹜文楷支持中文，其他两款只支持英文。 1234567891011121314# 文泉驿字体sudo pacman -S wqy-bitmapfont wqy-microhei wqy-zenhei wqy-microhei-lite # 思源字体，有 Google 的 noto 和 Adobe 的 source-han-sans 两种，本质都是一样的，只是命名不同sudo pacman -S adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts# Fira Codesudo pacman -S ttf-fira-code woff2-fira-code woff-fira-code# JetBrains Monosudo pacman -S ttf-jetbrains-mono# 霞鹜文楷paru -S ttf-lxgw-wenkai 4. Windows 的一些软件 windows 的多数软件在 Linux 中偶尔出些 bug，如果官方适配了 Linux 版，那就是最优选。 12345678# qq 已经重构，使用体验挺好的paru -S linuxqq# 腾讯会议paru -S wemeet-bin# WPS、WPS缺失字体、WPS中文语言包paru -S wps-office ttf-wps-fonts wps-office-mui-zh-cn 5. 一些小工具 12sudo pacman -S flameshot peekparu -S simplescreenrecorder motrix-bin 安装包 说明 flameshot 火焰截图 peek 动图录制工具 simplescreenrecorder 录屏软件 motrix-bin 下载管理器 6. 开发工具 在官方仓库中，安装某个包不带主要版本号基本都是最新版，如果需要安装指定的版本，可以去 wiki 查阅。 6.1 开发环境 JDK 的源码在 arch/manjaro 中是和 jdk 二进制包分离的，需要单独安装。jdk-openjdk 默认为最新的 LTS 版本。 123sudo pacman -S jdk-openjdk openjdk-src jdk8-openjdk openjdk8-src# 如果有多个版本，设置某个 JDK 版本为默认版本sudo archlinux-java set java-8-openjdk java 的源码一般位于 /usr/jvm/jdk-version/lib/src.zip. 直接安装 nodejs 包也最新的 LTS 版，所以我们需要指定后缀安装指定版本，使用 18.x： 12345# 18.x 版本sudo pacman -S nodejs-lts-hydrogen npm# 设置淘宝源npm config set registry https://registry.npmmirror.com 使用 npm 安装全局依赖时需要使用 sudo npm install -g xxx。 6.2 浏览器 除了 Firefox、Vivaldi 外，其它的浏览器都是 AUR 的包。注意，AUR 的包下载速度可能较慢。 1234sudo pacman -S vivaldiparu -S google-chromeparu -S microsoft-edge-stable-binparu -S brave-bin 6.3 podman 个人喜欢使用 podman 代替 docker，毕竟安装后只需要配置一下镜像源就可以直接使用。而 docker 需要加入 root 组，不过使用 docker 网上有很多资料可以查询，非常简单。 1234# podmansudo pacman -S podman podman-compose# 如果你喜欢 dockersudo pacman -S docker docker-compose docker 安装完成后普通用户不能使用相关命令，需要进行一些修改： 12345678# 创建 docker 用户组sudo groupadd docker# 将普通用户加入 docker 组中sudo gpasswd -a $USER docker# 更新 docker 组newgrp docker# 测试命令docker ps 6.4 IDE 12345678# JetBrains Toolparu -S jetbrains-toolbox# vscode、termius、apipostparu -S visual-studio-code-binparu -S termiusparu -S apipost-bin# Vmwareparu -S vmware-workstation 7. 终端使用zsh或者git-shell 新版本的 xfce 现在也是默认使用 zsh 了，所以此项一般可以忽略。 12345678910111213# 检查是否安装zsh# 如果没有安装那就安装sudo pacman -S zsh zsh-completions# 使用 git 终端# 查看可设置终端列表chsh -l# 设置终端路径chsh -s &lt;full-path-to-shell&gt;# 如果您使用的是 systemd-homed，请运行homectl update --shell=&lt;full-path-to-shell&gt; user 其中，full-path-to-shell 是 chsh -l 给出的完整路径。 提示：chsh 用作参考。如果列表中不存在最近安装的 shell，则可以手动将其添加到此文件中:/etc/shells 如果您要卸载 zsh，那么请您先更改默认的 shell 之后再进行卸载程序安装包。 Arch Wiki：https://wiki.archlinux.org/title/Command-line_shell#Changing_your_default_shell 8. 数据库 1. PostgreSQL 12345678sudo pacman -S postgresqlsudo su - postgres -c &quot;initdb --locale en_US.UTF-8 -E UTF8 -D &#x27;/var/lib/postgres/data&#x27;&quot;# 设置开机启动systemctl enable postgresql.service# 启动 pgsystemctl start postgresql.service 参见：https://wiki.archlinuxcn.org/wiki/PostgreSQL 附：一些问题 1. 中文环境改变的问题 ArchWikihttps://wiki.archlinux.org/title/Locale_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 如果是 KDE Plasma 桌面环境，默认你使用了 UTF-8 的编码，通过以下几步后重启就可以看到更改过来了： 12345678# 删除文件rm -rf ~/.config/plasma-localerc# 编辑 /etc/profile 文件，加入以下内容export LC_ALL=&#x27;zh_CN-UTF8&#x27;# 添加完成保存退出，并更新设置使其生效source /etc/profile# 显示正在使用的 Locale 和相关的环境变量locale 这里只说了 KDE 桌面环境的解决办法，其它的环境在上面的链接里也是有的。如果各位少侠发现自己系统路径下没有 /etc/locale.conf 和 /etc/locale.gen 文件也不用慌，使用 locale-gen 命令后会自动生成，我们只需要编辑这些文件去修改为需要的语言环境就OK。 2. 查看系统版本 1lsb_release -a 3. Apifox 使用 yay 更新 Apifox 更新频繁，在 Arch/Manjaro 使用 yay 工具安装更新时，容易出现 sha256 不匹配导致无法安装更新的情况。这个时候我们可以去对应的文件夹 ~/.cache/yay/apifox。里面一般有下载好的更新包 Apifox-linux-latest.zip。然后右键 -&gt; 属性 -&gt; 校验和 -&gt; 生成 sha256 的校验值，把该值复制到粘贴板。 1、打开 ~/.cache/yay/apifox/PKGBUILD 文件 12345sha256sums=( &#x27;ca700369a1b2b017aa68bf25269b76d17aad6514d570d43128bf19083203a1fb&#x27; &#x27;538bd986b582053799128254b4fcd6edfd51d096b127cf6398555664497d76b0&#x27; ... ) 将其中的第一行，改成 Apifox-linux-latest.zip 文件的 sha256 值，也就是刚刚生成复制的值。 2、执行命令 makepkg 编译并打包代码。（如果已经构建过，想要重新构建，需要加 -f 参数）。 3、执行 yay -U xxx.zst 将软件包安装到系统上。 如果少侠使用 paru 安装将不会有这个问题 ~.","tags":["linux","arch"],"categories":["Linux"]},{"title":"【Linux】 Ubuntu安装Hadoop+Hive","path":"/2023/06/24/Linux/Ubuntu/Ubuntu安装Hadoop+Hive/","content":"Ubuntu 搭建 Hadoop + Hive 环境实例。 一、官网集群配置文档 关于安装版本官方文档https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions 二、版本说明 推荐使用新版本（3.x），浪子因为所在公司使用的 2.x 版本，所以采用的 2.x 的最高版本。 java-8 hadoop-2.10.x hive-2.3.9 三、安装 安装 jdk 12345678910111213141516$ sudo apt install openjdk-8-jdk# 查看路径（虽然使用 apt 安装不需要配置环境变量，但是 hadoop 无法识别，依然需要手动导入）# /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java 就是安装的路径# 如果你的 jdk 是自己上传压缩包配置的可以跳过此步骤$ which java /usr/bin/java$ file /usr/bin/java /usr/bin/java: symbolic link to /etc/alternatives/java$ file /etc/alternatives/java /etc/alternatives/java: symbolic link to /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java$ file /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0d167f96ccfa5695cabf1b40056a77dc9bb8ab1a, for GNU/Linux 3.2.0, stripped# 下载 oracle 驱动cd hivepath/libwget https://download.oracle.com/otn-pub/otn_software/jdbc/217/ojdbc8.jar 配置环境变量： /etc/profile1234export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export HADOOP_HOME=hadooppathexport HIVE_HOME=hivepathexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HIVE_HOME/bin 检验 Hadoop 是否安装成功： 12source /etc/profilehadoop version 修改 Hive 配置文件 cd …/hivepath/conf cp hive-env.sh.template hive-env.sh hive-env.sh12# 配置一下 Hadoop 的安装路径HADOOP_HOME=hadooppath 添加 hive-site.xml 文件 新建 hive-site.xml 文件，添加以下内容。 hive-site.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:oracle:thin:@*********:1521:fangweidbt&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;oracle.jdbc.OracleDriver&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;******&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;******&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 初始化 1schematool -dbType oracle -initSchema 然后就可以使用了。 12hiveshow databases; 三、Hadoop集群搭建 一般在生产环境中使用 Hadoop 都是集群部署（毕竟是大数据，数据集比较大），如果采用一台服务器存储，万一需要维护或者宕机就不能对外提供服务了。官网集群配置文档 1. 前置准备 jdk(注意配置环境变量)： 安装版本官方文档https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions ssh 2. 开始 创建服务器地址映射 /etc/hosts1234...# ip hostname 域名192.168.10.1 node1 test.com SSH 配置 123# 密钥生成省略，使用 ssh-key# 复制公钥到目标主机ssh-copy-id hostname 集群时间同步 12sudo apt install ntpdatentpdate cn.pool.ntp.org ntp 常用服务器：https://dns.icoa.cn/ntp/ 安装 Hadoop 123# 官网下载安装包并解压# 复制到多台机器scp -r /sourcepath/ root@hostname:/targetpath/ 修改配置文件 配置文件都在 Hadoop 安装目录的 etc/hadoop/ 下。 hadoop-3.3.4/etc/hadoop/hadoop-env.sh123456export JAVA_HOME=/pathexport HDFS_NAMENODE_USER=export HDFS_DATANODE_USER=export HDFS_SECONDARYNAMENODE_USER=export HDFS_RESOURCEMANAGER_USER=export HDFS_NODEMANAGER_USER= core-site.xml123456789101112131415161718192021222324252627282930313233&lt;!-- 默认使用的文件系统，支持 file、HDFS、GFS、Amazon等 --&gt;&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://ip/name:port&lt;/value&gt;&lt;/property&gt;&lt;!-- Hadoop 本地保存数据路径 --&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/path&lt;/value&gt;&lt;/property&gt;&lt;!-- 设置 HDFS Web UI 用户身份 --&gt;&lt;property&gt; &lt;name&gt;hadoop.http.staticuser.user&lt;/name&gt; &lt;value&gt;user&lt;/value&gt;&lt;/property&gt;&lt;!-- hive 用户代理 --&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;!-- 文件系统垃圾桶保存时间 --&gt;&lt;property&gt; &lt;name&gt;fs.trash.interval&lt;/name&gt; &lt;value&gt;1440&lt;/value&gt;&lt;/property&gt; hdfs-site.xml12345&lt;!-- SNN 进程运行机器位置信息 --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;ip/hostname:port&lt;/value&gt; &lt;/property&gt; mapred-site.xml1234567891011121314151617181920212223242526272829303132&lt;!-- MR 程序默认运行模式，yarn：集群模式 local：本地模式 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;!-- MR 程序历史服务器地址 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;ip/hostname:port&lt;/value&gt;&lt;/property&gt;&lt;!-- MR 程序历史服务器 web 地址 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;ip/hostname:port&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapreduce.map.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapreduce.reduce.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt;&lt;/property&gt; yarn-site.xml12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- yarn 集群主角色运行机器位置 --&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;ip/hostname&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;!-- 是否对容器实施物理内存限制 --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/property&gt;&lt;!-- 是否对容器实施虚拟内存限制 --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/property&gt;&lt;!-- 开启日志 --&gt;&lt;property&gt; &lt;name&gt;yarn.log.aggregation-enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;!-- yarn 历史服务器地址 --&gt;&lt;property&gt; &lt;name&gt;yarn.log.server.url&lt;/name&gt; &lt;value&gt;http://ip|name/jobhistory/logs&lt;/value&gt;&lt;/property&gt;&lt;!-- 历史日志保存时间 7 天 --&gt;&lt;property&gt; &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt; &lt;value&gt;604800&lt;/value&gt;&lt;/property&gt; workers1域名 集群启动 首次运行初始化：hdfs namenode -format","tags":["linux","ubuntu"],"categories":["Linux"]},{"title":"【Linux】 Ubuntu 服务器配置","path":"/2023/06/24/Linux/Ubuntu/Ubuntu服务器配置/","content":"Ubuntu Server 22.04 服务器配置。 一、Ubuntu 基本配置 首先，掌握 apt 命令的基本使用：https://itsfoss.com/apt-command-guide/ 1. 开启 root 用户远程登录 对于 服务器版本 来说，默认的 root 用户是禁止使用密码登录的（prohibit-password），这里修改允许使用密码进行远程登录。 12# 设置 root 用户的密码sudo passwd root 编辑文件 sudo vim /etc/ssh/sshd_config，找到 #PermitRootLogin prohibit-password 所在的行，去掉注释并修改 prohibit-password 为 yes，保存退出并重启 sshd 服务。 1systemctl restart sshd 2. apt-get 123456789101112# 查看所有的安装软件dpkg --list# 安装已经下载好的 deb 安装包dpkg -i 安装包# 更新所有可更新的软件包sudo apt update &amp;&amp; sudo apt upgrade# 卸载指定软件并删除配置文件sudo apt --purge remove 包名# 清理不再使用的依赖和库文件sudo apt autoremove 3. 禁止使用 snap snap 可以获取软件的最新版，Ubuntu 逐渐迁移很多软件包到 snap，这样会导致软件不稳定。当然优点也是显而易见的，不过只对开发人员友好。对于个人日常使用、生产环境等场景还是不需要的。 卸载 snap 请参考：https://ubuntuhandbook.org/index.php/2022/04/remove-snap-block-ubuntu-2204/amp/ 123456# 查看列表snap list# 卸载所有列表中的软件，有些软件依赖其它组件的，注意先后顺序sudo snap remove --purge [soft]# 最后卸载 snapdsudo apt remove --autoremove snapd 然后编辑文件 sudo vim /etc/apt/preferences.d/nosnap.pref 添加下面的内容禁止 apt 使用 sanp 包。 /etc/apt/preferences.d/nosnap.pref123456# To prevent repository packages from triggering the installation of snap,# this file forbids snapd from being installed by APT.Package: snapdPin: release a=*Pin-Priority: -10 之后执行 sudo apt update，就不会使用 snap 下载了。 4. 安装基础的开发、编译工具 由于最小化的服务器版安装有一些编译库默认是没有安装的，需要用户手动安装，所以这里记一下常用的基础库： 12345# gcc/g++/gdb/make 编译工具apt-get install build-essential# ssl-libapt-get install openssl libssl-devapt-get install zlib1g-dev 5. 时区设置 Ubuntu 可以使用内置的 timedatectl 设置系统的时区。 1234567891011# 查看当前的时区timedatectl# 查看支持的时区列表timedatectl list-timezones# 是否含有中国时区timedatectl list-timezones | grep Asia/Shanghai# 设置中国时区timedatectl set-timezone Asia/Shanghai# 无需重启，再次查看timedatectl 6. 语言设置 ① Ubuntu 22.04 以上 123456# 查看当前系统的语言配置locale# 如果使用的 Ubuntu 22.04 以上使用这个命令将更加简单容易，选择完成之后注销重启sudo dpkg-reconfigure locales# 再次查看配置locale ② Ubuntu 22.04 以下 12345678910111213141516# 下面的适用旧版本 Ubuntu 22.04 以下# 列出所有启用的区域设置locale -a# 编辑 locale.gen 文件# 取消 zh_CN.UTF-8 UTF-8 en_US.UTF-8 UTF-8 两行的注释vim /etc/locale.gen# 编辑保存后，执行以下命令locale-gen# 显示正在使用的 Locale 和相关的环境变量locale# 设置整个系统使用的区域设置localectl set-locale LANG=zh_CN.UTF-8# 立即生效unset LANG 如果使用上面的立即生效命令仍然有问题，没有生效，请重启计算机。 7. Vim 配置 Linux 中有很多编辑工具，像 Vim、Nano 等，都是非常不错的，可以使用自己喜欢的。Vim 的全局配置文件在 /etc/vim/vimrc 或者 /etc/vimrc，对所有用户生效；用户的配置文件一般在 ~/.vimrc 中。 这里修改全局的配置，编辑 /etc/vim/vimrc 文件，没有的话可以手动创建一个。下面给了一些简单实用的配置。 /etc/vim/vimrc1234567891011121314151617181920212223242526272829&quot; 文件编码set encoding=utf-8set fileencoding=utf-8&quot; 自动缩进set autoindent&quot; 新行智能自动缩进set smartindent&quot; 状态栏标尺set ruler&quot; 语法高亮 vim5 之后默认开启set syntax=on&quot; Tab键的宽度set tabstop=4&quot; 搜索忽略大小写set ignorecase&quot; 高亮显示匹配的括号set showmatch&quot; 总是显示行号set nu&quot; 侦测文件类型filetype on&quot; 状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\\ [FORMAT=%&#123;&amp;ff&#125;]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %&#123;strftime(\\&quot;%d/%m/%y\\ -\\ %H:%M\\&quot;)&#125;&quot; 总是显示状态行set laststatus=2&quot; 高亮搜索的文本set hlsearch 二、常用软件 1. Redis 12345wget https://download.redis.io/redis-stable.tar.gztar -xzvf redis-stable.tar.gzcd redis-stablemake &amp;&amp; make installredis-server &amp; 2. MySQL apt-get安装：https://blog.lanluo.cn/8662 3. Docker 12345678910111213141516171819202122232425262728293031# 卸载旧版本sudo apt-get remove docker docker-engine docker.io containerd runcsudo apt-get updatesudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release# Add Docker’s official GPG key:sudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg# 设置稳定版仓库echo \\&quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\$(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 更新包索引sudo apt-get update####################### 下面二选一 ############################## 1. 安装最新版本的 Docker Engine-Community 和 containerd ，或者转到下一步安装特定版本：sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin# 2.# 查看版本apt-cache madison docker-ce# 选择指定的版本安装sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin 4. btop++ 1234567# 下载解压安装wget https://github.com/aristocratos/btop/releases/download/v1.2.8/btop-x86_64-linux-musl.tbzmkdir btop &amp;&amp; tar xvf btop-x86_64-linux-musl.tbz -C btopcd btop./install.sh# 运行btop 5. Nodejs 123# Using Ubuntucurl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash -sudo apt-get install -y nodejs 6. open-jdk 1sudo apt-get install openjdk-8-jdk 三、其它 1. 查找apt安装的软件的路径 这里以jdk为例 123which java# 多次执行，直到最后打印出一些系统信息file 上一条命令打印的路径 2. 开放指定端口 随着 Ubuntu 的更新，它的各种软件也在更新，以前用 firewall，新版本（22.04）已经默认使用 ufw，相比较而言，UFW command more easily，不过具体使用这里就不详细写了，可以参考官网的说明，很简单。 1234567891011121314151617181920212223# 启动防火墙systemctl start firewalld# --zone 作用域 --add-port 格式 端口/通讯协议 --permanent 永久生效firewall-cmd --zone=public --add-port=1935/tcp --permanent# 重启firewall-cmd --reload# 查看当前所有tcp端口netstat -ntlp# 查看所有1935端口使用情况 netstat -ntulp | grep 1935# 启用 ufwufw enable# 禁用 ufwufw disable# 查看状态ufw status verbose# 放行端口ufw allow port/协议（TCP|UDP）# 关闭端口ufw deny port/协议# 允许特定 IP 访问ufw allow from IP 3. ftp服务搭建 下载 完成后上传至服务器，执行以下命令安装 1dpkg -i xxx.deb 安装完成后编辑 /etc/vsftpd.conf 文件： 123456789101112131415161718192021listen=NOlisten_ipv6=YESanonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESuse_localtime=YESxferlog_enable=YESconnect_from_port_20=YESchroot_local_user=YESsecure_chroot_dir=/var/run/vsftpd/emptypam_service_name=vsftpdrsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pemrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyssl_enable=NO# 新增pasv_enable=Yespasv_min_port=10000pasv_max_port=10100allow_writeable_chroot=YES 更新防火墙：sudo ufw allow from any to any port 20,21,10000:10100 proto tcp 重启服务：sudo systemctl restart vsftpd 创建新用户并设置密码： 1234567891011121314sudo useradd -m ftptestsudo passwd ftptestNew password: Retype new password: passwd: password updated successfully# 出于安全考虑，限定用户ftpuser不能登录，只能ftpusermod -s /sbin/nologin ftpuser# 出于安全考虑，我们将禁用此用户的 ssh 权限。输入sudo vim /etc/ssh/sshd_config# 在此文件中添加以下行，然后重启 SSH sudo systemctl restart sshdDenyUsers ftpuser 添加文件(连接 ftp 时展示的目录为登录的用户的主目录，所以为了安全我们使用新建的用户)： sudo echo &quot;this is a simple file&quot; &gt; /home/ftptest/test.txt 然后就可以连接测试了：ftp://ip 四、一些问题 1. Docker Ubuntu version 22.04 Docker version 23.0.1 Docker Compose version v2.16.0 安装 Docker 工具：snap 错误原因： 1Cannot Connect to the Docker Daemon at ‘unix:///var/run/docker.sock’ 解决参考：https://appuals.com/cannot-connect-to-the-docker-daemon-at-unix-var-run-docker-sock/ 如果不能解决，尝试下面的方法： 1234567891011# 停止 dockersystemctl stop docker.socketsystemctl stop docker# 查看 snap 管理的 docker 状态snap services# 停止服务snap stop docker# 然后重启systemctl start docker","tags":["linux","ubuntu"],"categories":["Linux"]},{"title":"Hello World","path":"/2022/05/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment"},{"title":"【Linux】 ArchLinux安装教程","path":"/2022/05/22/Linux/Manjaro/ArchLinux安装教程/","content":"ArchLinux，很不错的一款 Linux 发行版，不过的它的安装可能让很多人望而却步，不过还有背靠 Arch 的另一个子系统，Manjaro，它的安装就和 Window 一样，简单容易。本篇文章仅作参考。 官方文档https://wiki.archlinux.org/title/Installation_guide#Boot_the_live_environment 一、国内镜像列表 二、前言 三、准备工作 四、开始安装 1. 分区 2. 格式化分区 3. 挂载分区 4. 设置下载镜像源，提升我们后续的下载速度 5. 安装 linux 基本组件 6. 执行以下命令 7. 切换到挂载点 8. 设置时间 9. 设置root用户密码 10. 设置语言和本机名 11. 退出 12. 前期准备 13. 安装驱动(请确保是网络连接正常) 14. 安装桌面(这里安装的Gnome) 15. 尾声 可能遇到的问题 如果是懒人或者小白，可以直接使用 Manjaro 系统，它是 Arch 的子项目，安装简单，Arch有的功能它基本都有，背靠 Arch，可以使用 AUR 仓库，配置简单。安装就和 Window 或者其它的 Linux 一样，只需要一个 ISO 镜像就可以。如果你喜欢漂亮美观，并且个性化，浪子推荐 Manjaro-kde 版本。如果你需要漂亮的同时保持简单整洁，浪子推荐 Manjaro-gnome 版本。如果你的硬件配置较低低，又想充分利用资源的话，推荐使用 Manjaro-xfce 版本。 一、国内镜像列表 12345678910111213141516171819202122232425262728#### Arch Linux repository mirrorlist## Generated on 2021-07-27#### China#Server = http://mirrors.163.com/archlinux/$repo/os/$arch#Server = http://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.cqu.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.cqu.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.dgut.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.dgut.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.hit.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.hit.edu.cn/archlinux/$repo/os/$arch#Server = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.nju.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.nju.edu.cn/archlinux/$repo/os/$arch#Server = http://mirror.redrock.team/archlinux/$repo/os/$arch#Server = https://mirror.redrock.team/archlinux/$repo/os/$arch#Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.xjtu.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.zju.edu.cn/archlinux/$repo/os/$arch 二、前言 下面的内容其实到第 13 步各位少侠就可以去找别的适合自己的教程了，这部分是需要结合自己电脑的配置情况去输入命令的。第 14 步安装桌面少侠们也可以去找自己喜欢的桌面风格样式。这里做个说明节省大家的时间。 三、准备工作 镜像 确保网络良好 (最简单的就是使用手机数据线连接电脑，开启USB共享；条件允许使用网线最佳) 四、开始安装 注意，以下命令都是紧接着的（可以不看文字，跟着命令走，确保联网正常，命令输入正确），分步是为了给自己做个说明，也便于理解。我也加入了注释，分区部分的注释建议大家一定要看，浪子尽力做到能让第一次安装的少侠看明白。单个字母就是执行了 fdisk /dev/sda 命令后，我们手动输入的命令。 1. 分区 1234567891011121314151617181920fdisk /dev/sda # 进入分区命令行，一直到最后的 w 命令，否则一直处于分区命令模式中g # 该命令创建一个新的 gpt 分区表n # 该命令新建分区，默认是1，直接回车即可 # 这一步是选择柱面，直接回车即可+500M # 给这个新建的gpt分区 500M 的空间，如果硬盘空间足够可以多给，后面我们会把分区格式化n # 新建第二个分区，像上面一样，两次回车，大小给 +8G+8G # 给该分区分配 8G 内存，这个分区稍后我们将格式为交换分区n # 建立第三个分区，然后三次回车键；分配剩余所有的空间，如果有需求可以再添加分区p # 上面分区完了后，输入该命令可以看到刚才的分区信息w # 确认无误后，w 保存退出；分区完成 注： 上面三个分区中 500M 的引导分区是必须的，8G 的交换分区如果内存足够也可以不分，建议都分上，它会在内存不足的时候使用硬盘的部分空间当作虚拟内存使用。基本每种系统都有。剩下的分区就是我们操作的分区了。 2. 格式化分区 123456mkfs.fat -F32 /dev/sda1 # 上面分配的 500M 的分区格式，用来存放系统信息mkswap /dev/sda2 # 上面分配的 8G 的分区格式为交换分区mkfs.ext4 /dev/sda3 # ext4 文件格式的分区，这个分区就是我们直接操作的空间了 注： 上面的 sdax 需要根据自己的实际分区情况来定，我这里仅仅是示例，可以看后面的注释部分，中途有确认项选择 y 即可。 3. 挂载分区 1234567mount /dev/sda3 /mnt # 把sda3挂载到mnt上mkdir -p /mnt/boot/efi # 创建多级目录mount /dev/sda1 /mnt/boot/efi # 把sda1挂载到/mnt/boot/efi下swapon /dev/sda2 # 这个好像是激活swap分区，我忘了；执行命令后，大家可以去查一下 4. 设置下载镜像源，提升我们后续的下载速度 1234# 把系统文件先做个备份cp /etc/pacman.d/mirrorlist/etc/pacman.d/mirrorlist.bak# 向文件添加内容，不理解没关系，执行命令就好echo &quot;https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch&quot; &gt; /etc/pacman.d/mirrorlist 5. 安装 linux 基本组件 1pacstrap /mnt base base-devel linux linux-firmware dhcpcd iwd neworkmanager grub efibootmgr vim 6. 执行以下命令 123456genfstab -U /mnt &gt;&gt; /mnt/etc/fstab# 查看一下是不是和自己开始的分区个数一致，一样代表写入成功；可以执行后续操作；# 如果失败，请重新再来。一般来说，按照顺序执行正确命令到这里理论不会失败# 在这里这么说是因为这一步比较重要，如果失败可以重新尝试一下cat /mnt/etc/fstab 7. 切换到挂载点 1arch-chroot /mnt 8. 设置时间 123ln -sf /usr/share/zoneinfo/Asia/Shanghai/etc/localtimehwclock --systohc 9. 设置root用户密码 1passwd # 之后输入想设置的密码 10. 设置语言和本机名 12345678910111213141516171819202122232425262728echo &quot;en_US.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.genlocale-genecho &quot;LANG=en_US.UTF-8&quot; &gt;&gt; /etc/locale.conf# 以上三行是设置语言，设置为英文是确保没有乱码，# 因为刚装完的系统是没有中文环境的，如果这里设置中文，安装了以后没有中文字体，将会出现乱码。# 安装完了后可以安装中文环境，然后进行设置# 下面开始写入本机信息echo &quot;本机名，想要啥自己输入&quot; &gt;&gt; /etc/hostnamegrub-install --target=x86_64-efi --efi-directory=/boot/efigrub-mkconfig -o /boot/grub/grub.cfg# 创建一个新用户，以username为例(-m 自动生成用户主目录，-G 加入一个不存在的组 wheel)useradd -m -G wheel username# 设置密码passwd username# 然后编辑一个文件vim /etc/sudoers# 找到 %wheel ALL=(ALL)ALL (vim 编辑时输入 `/#%` 会跳到这儿)去掉前面的注释 `#` ，完成后保存退出。 11. 退出 12345678910# 退出 arch-chroot 状态exit# 取消挂载umount /mnt/boot/efiumount /mnt# 重启系统reboot(记得拔掉 U 盘) 12. 前期准备 123456789101112131415161718192021222324252627282930313233343536# 重启之后登录进系统，这时我们需要进行安装桌面系统的前期准备sudo cp /etc/pacman.d/mirrorlist/etc/pacman.d/mirrorlist.baksudo vim /etc/pacman.d/mirrorlist# 编辑文件加入下面的一行内容。加入的内容依然是我们之前提升下载速度所加入的# 如果还是之前的设置内容，就不用添加了，保存退出即可。Server = &quot;https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch&quot;# 然后编辑 pacman.conf 文件sudo vim /etc/pacman.conf# 直接到最后，把带有下面的标签部分的的两行的注释取消掉，然后再加入以下内容[multilib]Include = /etc/pacman.d/mirrorlist[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch# 按顺序执行以下命令吧sudo systemctl start iwdsudo systemctl start dhcpcdsudo systemctl enable NetworkManagersudo systemctl enable dhcpcdsudo systemctl enable iwd# 编辑文件sudo vim /etc/NetworkManager/NetworkManager.conf# 加入以下内容，保存退出[device]wifi.backend=iwd# 输入 ip a 查看现在连上网没有其实，如果按照我刚开始的联网方式，这里配置完也是连着网的。 13. 安装驱动(请确保是网络连接正常) 这一步大家可以根据自己的电脑 硬件型号 去选择，k可以百度也可以上 ArchWiki 查询；下面的桌面系统部分也可以选择自己喜欢的。 12345678910111213141516171819202122# haveged 是做 GPG 签名的sudo pacman -Syu havegedsudo systemctl start havegedsudo systemctl enable havegedsudo rm -rf /etc/pacman.d/gnupgsudo pacman-key --initsudo pacman-key --populate archlinuxsudo pacman -S archlinuxcn-keyring# 我的CPU、显卡是intel 5 代核显，执行以下命令。# 如果是其他的CPU 显卡请 自行 去官网查看或者百度，这个我也不懂，哈哈哈# 显卡驱动sudo pacman -S vulkan-intel lilb32-vulkan-intel mesa lib32-mesa# 声卡驱动sudo pacman -S alsa alsa-utils pulseaudio pulseaudio-alsa 14. 安装桌面(这里安装的Gnome) 12345678910111213sudo pacman -S cinnamon gnome gnome-extra#之后一路回车，出现选项选择 y#等待安装完成。sudo pacman -S sddmsudo systemctl enable sddmsudo pacman -S way-microhei way-zenhei ttf-dejavusudo pacman -S google-chrome#现在就可以重启了，让我们怀着高兴紧张又期待的心情输入 reboot 回车吧！ 15. 尾声 感谢教我的大佬，还记得大佬对我说，到这里基本的桌面和谷歌浏览器都帮我弄好了，剩下的就要靠我自己了。不知道为什么，当时听到这句话有一点么想哭。 然后我听大佬的用的 cinnamon,大佬还给我发了截图。我看过去的第一眼，哇塞！好漂亮！！！然后大佬对我说，你需要自己去设置，默认的很丑，哈哈哈哈。 犹记大佬最后对我说 你要学会靠自己，要会自己解决问题，我会尽力的。 确实，自己手动安装一遍的收获真的是很大啊，我很佩服教我的大佬，并不仅仅是因为他教我安装 arch。感谢大佬，比心 ^o^ 可能遇到的问题 如果你插入了一个 ntfs 格式的硬盘，Linux 识别不了，不能挂载的话，请安装 ntfs-3g ；命令：yay -S ntfs-3g 未完待续。。。","tags":["linux","arch"],"categories":["Linux"]},{"path":"/about/index.html","content":"探索收藏jhlz行有所止，欲有所制 一些网站 北京外国语大学开源软件镜像站北京外国语大学开源软件镜像站阿里云官方镜像站https://developer.aliyun.com/mirror/Git淘宝镜像仓库https://npm.taobao.org/mirrors/git-for-windows/geeksforgeeks学习网站，速度较慢shields.io生成 md 个性标签，例如 Github 的 README 文件的小标签语音转 Base64https://protobuf-decoder.netlify.app/Project Banner GeneratorText to ASCII Art Generator (TAAG)渐变颜色选择器渐变颜色选择器图片在线编辑在线调整图片工具squooshGoogle 在线图片压缩工具codebeautifycodebeautify!十六进制颜色代码颜色代码swagger 转 doc 文档在线将swagger接口文档转成word文档，支持通过swagger接口文档url转word文档，支持上传swagger接口文档JSON文件转word文档，支持swagger接口文档JSON字符串转word文档，支持swagger3.0(openApi3.0)文档转word文档。极简简历在线生成简历，极简，却并不简单！代码块样式效果预览https://xyproto.github.io/splash/docs/longer/all.html Github 开源 Motrix下载器DownkyiBilibili 下载器MQTTXMQTT 测试客户端DBGate跨平台的、支持多种数据库的客户端antares跨平台的、支持多种数据库的客户端字体-文泉驿系列文泉驿微米黑、正黑、等宽体等字体-霞鹜文楷好看的、适合阅读的中文字体，基于 FONTWORKS 出品字体 Klee One 衍生。字体-思源黑体思源黑体是一套 OpenType/CFF 泛中日韩字体字体-FiraCodeFree monospaced font with programming ligatures字体-JetBrains MonoJetBrains Mono the free and open-source typeface for developers 致我们终将逝去的青春 江湖浪子（jhlz），专科计算机应用技术专业毕业，一个比较喜欢江湖和武侠世界的中二少年 （目前的年纪应该还算是少年吧！心理年龄永远 18 岁！😄）。大学玩了三年，当然，或多或少也学了一点点小知识。不是天纵奇才，也没有丰厚的家境和令人艳羡的背景。自我介绍非常羞愧，因为我并不是 “穷人的孩子早当家”。 小时候家里穷，没有什么眼界，也没怎么接触过电脑。只记得小学的时候自己和同学偷偷去网吧打游戏，了解也不多，当时比较常用的就是 Ctrl + Delete + . 。后来被父母发现，一顿痛打，后面基本没有再去过（大学的时候没有自己的电脑，需要制作一个 U 盘启动，去了一次）。 说来也奇怪，当年高考报志愿的时候计算机在最后一项，前面的几个专业都没有录取上 🤣。那时候填志愿事先也不知道分数（18），对于各大高校信息也不甚了解。当时周围的同学都说把自己认为十拿九稳的学校放在第一个，第一个有加分项或者说是好感，若运气好就可以被录取。 于是自己当时就只报了一个学校，该学校的专业也选了一些，有 3~5 个吧，计算机专业在最后一个，前面的是根据自己的兴趣选的专业。 大学期间在 B 站看了一位老师分享的很多报志愿的经验的视频，确实很有用，尤其是对于农村的学生，可以额外的获取很多信息，非常感谢这位老师提供的信息💖。但是我本人当时完美的错过😅。不过现在想来，即使不错过，我高考的分数也很尴尬，总体而言，对于这种信息，这个时候就是 知道总比不知道要好的多，还是非常推荐各位正在备战高考的少侠了解一下，尤其是没有什么背景的或者家境不是很好的同学，祝愿你们名满凤凰楼，冠盖满京华。 毕业的时候对人生充满了迷茫，不知道自己要做什么。于是就和一位舍友一起报了培训班，主要学习 Java。我还是蛮喜欢这门带我进入互联网行业的语言的，虽然写多了或者有经验后觉得 Java 并不怎么好，写法啰嗦、占用内存较大等缺点。其实语法层面的问题如果使用新版的 Java，你会发现其实它同我们一样，也在成长，新出的语言中有的特性，它也在慢慢支持，虽然步伐慢了一点儿，毕竟它发展了很长时间，有很多的历史包袱注定不能大刀阔斧的改革。 毕业后的一年里，是我真正提升技术的一年，学到了很多 Java 领域的知识，在这里我要非常感谢我的第一家公司，感谢公司的各位小伙伴平时对我的照顾。的确，还是我太年轻了，没有受过社会的毒打。 我在公司项目中主要贡献就是业务代码，个人感觉我的代码写的还是可以的，嘿嘿。业余时间会整理消化公司项目中使用的相关框架的知识，然后有其它时间的话也会再学一些其它的知识，然后去优化公司的代码。这些知识有些时候还能帮我解决一些开发的难题。 当然，还是会遇到困难的，经验不足的确是硬伤，解决问题非常耗时，偶尔还会手足无措，不知道怎么办，最好去向其它同事请教(再次感谢之前公司的小伙伴)，遇到难题我们都希望有 “高人指路”。 所以如果各位少侠有可以进入大公司的机会，一定一定要去感受一下，这是人生或者是职业生涯宝贵的经历，即使自己什么都不会，进去看看也是好的。 接下来谈谈编程语言的学习经验吧，最核心的就是自己动手实践，还记得那句台词吗？“我就喜欢动手能力强的人！”，开个玩笑，实践是检验真理的唯一标准！ 数据结构和算法放在开始说，这个属于内功/内家拳。内功是需要长期去练习、去积攒的，“拳不离手，曲不离口”，最终达到内力浑厚无比、充斥周天、绵绵不断的效果。所以刚开始学习的时候，算法可以不刷；但是数据结构是必须要了解的，这是非常常用的，尤其是数据结构的特性。很多的高级语言本身都提供了常用的数据结构，比如：集合、链表、散列等，当然你也可以使用第三方提供的数据结构的库，它们的实现更加优秀，比如 Java 的 Guava 集合库。实际运用中可以编写出占用内存较少、性能较好的程序，甚至获得同事的认可，何乐而不为？ 浪子刚毕业的时候自己为自己不刷算法找了一个借口😔：写业务代码必须要会算法？不会一点儿也不耽误我完成业务功能，我要是算法特别好，为什么我不去应聘算法工程师呢？ 后来不是现实打脸，而是自己总结的时候自己打自己脸。算法的的确确反映一个程序员的内功，而且非常的直观。它不仅能直观的反映出程序员是否具有编程思想，还能锻炼逻辑思维。可以这么说，只有算法底子好，去写复杂业务很简单的。不要认为有多难，成熟的程序员写代码之前都是深思熟虑的，当然，仅限于公司的程序。 默认所有少侠都掌握了计算机基础，有了解也是可以的。刚学习编程语言，和把大象装进冰箱里一样简单：学习基础语法，多多上手练习 =&gt; 集成库/框架，上手练习 =&gt; 复盘，总结。日常工作就是集成各种库，使用库去编写各种基础语法，这些片段组成运行的程序。 对于刚开始学编程的少侠，建议选定一门语言，选自己喜欢的或者随大流，全部的时间和精力都用来学这个即可，不要担心未来工作要转语言什么的，贪多嚼不烂。而且要明白一点：编程语言本身的设计和思想都是借用了已有的社会经验、社会工程学的概念，进而使用编程语言来体现。精通一门之后无论是学习新语言还是集成框架都会事半功倍，而且如果官方文档看的多，编程的大多概念甚至是相关英文都会记住，很多概念都是相通的，不要觉得有多难。 编程语言本身基本只有两大重点：语法、概念，如果再加一个，那就是为了解决什么问题（适用领域，不是那么重要，有些语言只适用与特定领域）。其余的就是编程语言的具体实现（API）了。 编程语言自身的源代码多看是很有益处的，阅读的时候你可能会经常感慨：哦 哦 还能这么写 还可以这么玩！当然，刚开始可能看不懂，没关系，编程思维需要一点一点慢慢培养。 至于集成框架出现的错误，记住一句话：官方文档永远是第一手参考资料。另外学习框架的时候尽量在出错的时候去读，带有目的性往往要专注一些。只是为了学习的话，效果不是很好，甚至看不懂，可以等后面有经验了再去看，会有不一样的收获。 之后提升、巩固自己的最好方式就是造轮子。工具如何使用是非常简单的，如果该工具的文档写的足够好，基本没有任何难度（所以写文档也是一门艺术）。只有自己去实现的时候，比如写一个实用的库或者一个小框架，才会发现自己更多的不足，通过造轮子查漏补缺，开源的话甚至可以为 AI 做一点贡献😂 关于各种语言、库、框架的版本的更新情况，这里给一句话吧：“学习新思想，争做新青年”。 以上就是自己到目前为止大概三年的编程经验总结，只是站在宏观的角度归纳，没有细致深入，因为里面的东西真的很多，都是需要自己动手实践的。最后希望国内的开源环境越来越好，也希望所有少侠都可以开心学习、开心工作、开心摸鱼、开心生活~ 自己不能闪耀，就给那些闪耀的人以掌声鼓励，祝福他们不忘初心，越来越好。 想要学好编程，需要培养自己的编程思维，把内功修炼好，当然，这需要一个过程。希望我们都能经受得住时间的考验。"},{"title":"探索 Stellar","path":"/explore/index.html","content":"探索收藏jhlz行有所止，欲有所制 本页是为了 探索 Stellar 主题的各种效果。Stellar 主题版本为 最新版本。 2024.2.4更新 Stellar 版本至 1.26.6 我很喜欢你 像风走过八百里地 不问归期 清风明月何须论价 高山流水定有知音 KR1 专升本考试 中国近现代史纲要马克思主义基本原理概论 正常 20% KR2 重构后台管理系统 延期 10% KR2 okr 的第一行默认为标题 根据平台的文档编写机器人 未完成 10% box 标签测试 box 简单测试我这一辈子，苦没有真正苦过，爱没有用力爱过。每天受着信息大潮的冲击，三观未定又备受曲折。贫穷不再是正义，又妄图不让金钱成为唯一的追求。过早看到了更大的世界，勤奋却又不过三天。热血透不过键盘和屏幕，回忆止于游戏和高考。像一群没有根的孩子，在别人的经历和精神里吵闹。 box + markdown代码块测试box 中如果指定了 child:codeblock，然后使用 md 的代码块标签即可显示如下效果：123class Test&#123; public static final ConcurrentHashMap map = null;&#125; box+tabs 效果第一条内容第二条内容第三条内容111222333 使用自己掌握的编程语言在终端打印彩色字体终端的字符颜色是用转义序列控制的，是文本模式下的系统显示功能，和具体的语言无关。转义序列是以 ESC 开头，即用 \\033 (八进制)来完成（Escape 的 ASCII 码用十进制表示是 27，也就是十六进制 0x1B，用八进制表示就是 033，Unicode 为 001B。）语法： \\u001B[显示方式;前景色;背景色m内容\\u001B[0m。其中显示方式（默认终端即 0）和背景色可省略： \\u001B[前景色m内容\\u001B[0m。 显示方式效果0默认终端1高亮4下划线5闪烁7反白8不可见22非粗体24非下划线25非闪烁27非反显28可见 前景色表示背景色表示颜色效果3040black 黑色3141red 红色3242green 绿色3343yellow 黄色3444blue 蓝色3545magenta 品红色3646cyan 青色3747white 白色 tabs 嵌套标签测试 mavengradle kotlingradle1234567&lt;!-- https://mvnrepository.com/artifact/com.akuleshov7/ktoml-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.akuleshov7&lt;/groupId&gt; &lt;artifactId&gt;ktoml-core&lt;/artifactId&gt; &lt;version&gt;0.5.0&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;1runtimeOnly(&quot;com.akuleshov7:ktoml-core:0.5.0&quot;)1runtimeOnly &#x27;com.akuleshov7:ktoml-core:0.5.0&#x27; folding + folders 折叠标签测试 folding + box 测试123class Test&#123; public static final ConcurrentHashMap map = null;&#125; folders： 你最喜欢的食物辣椒你最喜欢的人女神你最喜欢的事coding grid 分侧标签 普通样式： 任凭世人笑我癫狂叹红尘游世间 空悬北斗点将勺运筹群星指天枢 card 样式 没有决断之心的舍弃过往，不过是故作姿态罢了 神蛊温皇要毁，不但要毁掉过去，还有现在，还有未来。 swiper 轮播标签 width:max： width:min effect:cards/coverflow 一个页面只能设置一次，第一个 swiper 容器的效果全局生效。本文指定了 cards. 单选、复选样式标签 没有勾选的单选框 已勾选的单选框 没有勾选的复选框 已勾选的复选框 加号的绿色的已勾选的复选框 显示为减号的黄色的已勾选的复选框 显示为乘号的红色的已勾选的复选框 视频、音乐专辑标签 两个标签默认都是手动播放"},{"path":"/friends/index.html","content":"互换友链如果想要本站收藏您的友链，需满足以下规则：合法的、非营利性、无商业广告、无木马植入。有实质性原创内容的 HTTPS 站点，发布过至少 5 篇原创文章，内容题材不限。点击 本链接 按规则写入您的信息，等待一分钟后（时间可能稍有延迟）刷新 本页面 再次查看。如果后续您的域名或者其它信息发生了改变，可以找到自己的信息 并修改。本站信息1234567&#123; &quot;title&quot;: &quot;江湖浪子/jhlz&quot;, &quot;url&quot;: &quot;https://jhlzlove.github.io&quot;, &quot;avatar&quot;: &quot;https://cdn.jsdelivr.net/gh/jhlzlove/dist@main/images/doc/avatar.jpeg&quot;, &quot;screenshot&quot;: &quot;&quot;, &quot;description&quot;: &quot;行有所止 欲有所制&quot;&#125; 一群傻子 Azhecksdevelop 人生何处不相逢"},{"title":"你笑起来真好看","path":"/wiki/人生图书馆/月章星句/你笑起来真好看.html","content":"你笑起来真好看，像春天的花一样。 萌萌的小橘子。 太阳是我滚圆的！月亮是我咬弯的！ “我嫁人了你来砸我婚礼吗？” “开玩笑砸我自己婚礼干嘛！” 帆布鞋咱也能走出猫步，格子衫咱也能耍出帅气。 “收破烂！”，“卖垃圾！”。 生活将我们磨圆是为了让我们滚的更远。 有一种贱，叫好了伤疤忘了疼；有一种安静叫做老班来了。 考试不作弊，明年当学弟。 宁愿没人格，不能不及格。 欧皇不识愁滋味 奇遇容易不宝贝 茶饭不思夜难寐 非酋心痛两行泪"},{"title":"如果没有李白","path":"/wiki/人生图书馆/月章星句/如果没有李白.html","content":"如果没有李白 如果没有李白 如果没有李白 似乎没有什么太大的影响 不过千年前少了一个文学家 《全唐诗》会变薄一点点 但程度相当有限 如果没有李白 几乎所有唐代大诗人的地位 都会提升一档 李商隐不用再叫小李 王昌龄会是唐代绝句首席 杜甫会成为最伟大的诗人 没有之一 如果没有李白 我们应该会少背很多唐诗 少用很多成语 说童年 没有青梅竹马 说爱情 没有刻骨铭心 说享受 没有天伦之乐 说豪气 没有一掷千金 浮生若梦 扬眉吐气 仙风道骨 这些词都不存在 蚍蜉撼树 妙笔生花 惊天动地 也都不见了踪迹 如果没有李白 我们的生活应该会失去不少鼓励 犯了难 说不了长风破浪会有时 想辞职 说不了我辈岂是蓬蒿人 处逆境 说不了天生我材必有用 赔了钱 说不了千金散尽还复来 更不要说 大鹏一日同风起 扶摇直上九万里 安能摧眉折腰事权贵 使我不得开心颜 如果没有李白 我们熟知的神州大地 也会模糊起来 我们不再知道 黄河之水哪里来 庐山瀑布有多高 燕山雪花有多大 桃花潭水有多深 蜀道究竟有多难 白帝城 黄鹤楼 洞庭湖的名气 都要略降一格 黄山 天台山 峨眉山的风景 也会失色几许 如果没有李白 历朝历代的文豪词帝 也会少了很多名句 没有举杯邀明月 苏东坡未必会有把酒问青天 没有请君试问东流水 李后主不会让一江春水向东流 没有事了拂衣去 深藏身与名 金庸的武侠江湖 将会天缺一角《侠客行》 千百年来 蜀人以李白为蜀产 陇西人以为陇西产 山东人以为山东产 一个李白 生时无所容入 死后千百年 慕而争者无数 是故 无处不是其生之地 无时不是其生之年 他是天上星 亦是地上英 亦是巴西人 亦是陇西人 亦是山东人 亦是会稽人 亦是浔阳人 亦是夜郎人 死之处亦荣 生之处亦荣 流之处亦荣 囚之处亦荣 不游 不囚 不流 不到之处 读其书 见其人 亦荣亦荣 幸甚至哉 我们的历史有一个李白 幸甚至哉 我们的心中有一个李白 你是谪仙人 你是明月魂"},{"title":"宋词，线装的美酒","path":"/wiki/人生图书馆/月章星句/宋词线装的美酒.html","content":"如果有人说宋词是线装的美酒，我就会说至今香醇满喉；如果有人说宋词点亮了满天的星斗，我就会说它妩媚了整个文字的宇宙；如果有人说宋词是千年的花后，我就会说它始终栖息在玫瑰的枝头，至今余香满手；如果有人说宋词是千年的凝眸，我就会说它始终蕴藏在灯火阑珊后，至今温暖心头。 宋词，它与唐诗争奇，它与元曲斗艳，承前启后。它比元曲含蓄，欲说还休；它比唐诗自由，挥洒风流。它错落有致，雪清玉瘦；它韵律优美，朗朗上口。它是几千年文字长廊里的美人，清丽婉柔，回眸处暗香盈袖；它是文学圣坛的巨钻，才高八斗，始终镶嵌在岁月的路口。 它是洒不完的清愁，斟不完的美酒，弹不完的箜篌，剪不断的离愁。它可以是纤纤手，云鬓柔，泪沾佳人衣袖；它可以是和羞走，金钗溜，却把青梅嗅；它可以是人约黄昏后，月上柳梢头。花间一壶酒，远山挂帘钩。它可以是一种相思，两处闲愁，才下眉头，却上心头；它可以是粉面含羞，花自飘零水自流，也可以是倚门回首，千年的梅香不朽；它可以是琼花吹落一江的清愁，也可以是红粉抚过百花的肩头。 它在莲心里漫游，在红尘中等候，在水之湄梳头，在幽竹林间行走。无论经过多少朝代的更迭，都新眉画就，山明水秀；无论经过多少时间的沙漏，都冰心雪柳，风采依旧。 它可以是李煜的无言独上西楼，月如钩，寂寞梧桐深院锁清秋的离愁；是剪不断，理还乱，别是一番滋味在心头的烦绪苦酒；是问君能有几多愁，恰似一江春水向东流的故国不堪回首；是一棹春风一叶舟，一纶茧缕一轻钩。花满渚，酒满瓯，万顷碧波里向往的自由。覆水难收，阶下囚，事事休，多少苦，多少忧，卡在喉；多少屈辱，多少磨难，泪满异乡的月头。失败的皇帝，词坛的巨斗，多少泪断脸，多少恨，说不出口，可怜小周后，终落赵光义之手，屈辱堵满心头，就是骂遍九州，怨都不能休！可怜李煜还是遭毒手，小周后也随夫天堂收，免得再在尘世遭污垢。 它可以是李清照的蹴罢秋千，起来慵整纤纤手，露浓花瘦，薄汗轻衣透；是昨夜雨疏风骤，浓睡不消残酒，金炉次第添香兽，红锦地衣随步皱，薄雾浓云愁永昼，瑞脑销金兽；是莫道不消魂，帘卷西风，人比黄花瘦。多少清丽在手，多少空灵满眸，多少锦心绣口，多少雪地轻柔。她与赵明诚，情深意厚，志趣相投；赌书泼茶，相思煮豆，大相国寺同游，好梦几回，却难白头。她的一生，非干病酒，不是悲秋，是千古第一才女的亡国之忧。 宋词不光是有着婉约的温柔，更有着豪放的风流，是陆游的胡未灭，鬓先秋，泪空流，身老沧州的志未酬；是红酥手，黄縢酒，满城春色宫墙柳的爱恨悠悠；是苏轼的大江东去，千堆雪，上下几千年的指点春秋；是竹杖芒鞋轻胜马，一蓑烟雨任平生的淡然悟透；是锦帽貂裘，千骑卷平冈的豪情演奏；是辛弃疾的千古兴亡多少事，不尽长江滚滚流，坐断东南战未休的恨不退敌寇；是岳飞的三十功名尘与土，八千里路云和月的故土难收！ 走在宋词的渡口，雪滩沙鸥，乌篷小舟，深黄一点入烟流，露华凄冷蓼花愁。你可以遥遥望见阮小七驾一叶扁舟，鬓角插一朵火红的石榴，你可以看见燕青倜傥风流，白锦上铺满软翠般的花绣。 千年的美酒，醉了多少人的心。万年的邂逅，有了心灵的悸动！如果你说那时的汴京是红肥绿瘦，我就会说那时的水城真是花团锦绣。如果你说那日的龙亭将相王侯，我就会说昔日的虹桥尽显风流；如果你说那时的清明繁华尽收，我就会说没有宋词的双眸，美丽就是海市蜃楼。没有宋词的巧手，隔着悠悠的岁月，荒凉就会爬满额头。"},{"title":"布袋戏诗号","path":"/wiki/人生图书馆/月章星句/布袋戏诗号.html","content":"地灵人杰拂远志，梦定三生效谪仙 诗成断雨流云外，人在光风霁月中。 霹雳布袋戏 有心天下，却输一筆多情，我的山水落在你的眉间，你肯入画吗？——南风不竞 如果梦醒，总是要这般折磨，还不如未曾入梦。\t——南风不竞 驰来北马多骄气，歌到南风尽死声。 ——南风不竞 追浴沂之风徽，法舞雩之咏叹。 ——杜舞雩（yu二声） 别见风，别见尘，别见风尘染故人。 一恨才人无行，二恨红颜薄命。 三恨江浪不息，四恨世态炎凉。 五恨月台易漏，六恨兰叶多焦。 七恨河豚甚毒，八恨架花生刺。 九恨夏夜有蚊，十恨薜萝藏虺。 十一恨未逢敌手，十二恨天下无敌。 ——剑君十二恨 满天银雪梦一生，悲乎？乐乎？ 遍地寒霜醉红尘，仇乎？情乎？ 流金岁月，难忘忆秋年。 过眼云烟，独留风之痕。 过去，是我错了： 我错在轻纵奸邪，任其荼毒苍生 我错在诛魔无力，致使天下受害 我错在失信红颜，难挽香消玉殒 我错在有负师恩，愧让道剑蒙尘 历历四错在，一剑一悔改 醒悟的心，冷测的剑光 象征道者的决然意志 一个人要退到哪里，才不是江湖。 ——皇甫笑禅 何为天命，不可屈服于天之命，谓之天命。 时间从来只留恨，不留人。 ——三余无梦生 江山如画，怎比拟你眉间一点朱砂 岁月如歌，何曾改我心中半世痴情 人生须知负责的苦处，方能了解尽责任的乐处。 简默沉静者，大用有余；轻薄浮躁者，小用不足。 以浮躁为之，则必坏事；以沉静为拙，则必失人。 遇横逆之来而不怒，遭变故之起而不惊，当非常之谤而不辩，可以任大事矣。 有过往的堆累，才有生命的厚度；有生命的厚度，现在才能活的精彩；有精彩的现在，才有希望去展望未来。 人生在世就是要多学、多听、多看，时常充实自己，好学不倦。 ——疏楼龙宿 静思静心，是修智修行的第一步。 ——剑子仙迹 相遇就是巧合，巧合就是顺其自然，顺其自然就是回归原本，回归原本就是不要想太多，不要想太多就是不要多怀疑跟爱操烦。 ——破戒僧 诸法无常，为心自造，心之所向，无处不自往。 ——雅僧 很多人喜欢说无情，但真正的无情，汝可知？无情不是寡情，而是这份感情，无人能懂。 ——吞佛童子 真正有力量的人，是能施与他人爱的人，而不是等待他人的施舍。 要认识一个人，不一定要从他的过去开始参与。 人生不能一直挂念着遗憾，这样旅程怎会快活？ ——冰无漪 人生有些事情，错过一时，就错过一世。 ——冰无漪 当希望只能是希望时，代表逝去的，永远无法回来了。 ——意琦行 善不是一种言语，也不是一种学问，而是一种发自内心的行动。 很多时候，事情不能以对错来论，而是要用更温柔的心，来表达自己坚持与想法。这世上，就是有太多自认为没错的人，将似是而非的道理，当成了伤害他人的利器。站在道理高点的人，不代表他就是有依循道理的人。 不言过去如何难，只言难题如何过。 一个遭逢变故的人，最怕的就是安慰。安慰只会引来悲伤，却无法改变现状。 只要内心净白，何必在意外表的污秽呢？ 有时候，对善的苛求造成的伤害，并不下于为恶。 无我不能之事，无我不解之谜，无我不为之利，无我不胜之争。 识无用之用，通无能之能，了无道之道，化无极之极。 一萧一剑平生意，负尽狂名十五年。 ——乱世狂刀 昨日的关系，会因明日的情势不同而改变。 ——素还真 逆天，尚有例外；逆吾，绝无生机。 ——意琦行 人间，又污秽了！ ——弃天帝 人世的风雪，不是说停就停，如同命运的选择，并非尽由人意。 ——宫无后 迷惘时，不要想太多，只要循心而往，那就是方向了。 ——素还真 当初的景，当初的人，皆已不复当初，就连当初的记忆，也开始模糊。 ——倦收天 可以载清风，不可载人言；可以屈其身，不可屈其心。 ——无衣师尹 我不想夺走你什么，但我不想再让你夺走什么。 ——剑之初 所谓的会议，不过是一群彼此不能被说服的人，在努力呻吟而已。 ——魔王子 既然世俗的天不容你，那从此刻起，吾便是你的天。 ——一剑封禅 我只是低调，不代表没料。 ——唐绝 降者生，不降者，超生！ ——矩业烽昙 枪啊枪，不珍惜生命是现在的潮流吗？ ——生命练习生 陌路相逢，只不过一个错身，但在心上安一个人之后，轻易便是一生。 ——剑非道 風不失期，君不失期。 ——慕容清 我欲抱歉天下，试问谁敢多谢。 ——风之痕 一日三千斩，风神睨九天。剑锋英雄墓，杀佛不留仙。 ——风之痕 弃天帝，一剑，让你含恨！ ——风之痕 抱歉一出尊天下，剑界神话笑群雄。 ——风之痕 别人的多谢，就是吾的抱歉。 ——风之痕 多谢不语，抱歉化身。封喉净世，吾名正义。 ——风之痕 风剑随手出鞘，问谁人、敢言多谢？ ——风之痕 一剑越山河，九天寰宇谁称雄？抱歉封不尽，废物垃圾何其多。 ——风之痕 一声多谢，抱歉索命。 ——风之痕 抱歉纵横三万里，一剑封喉十九州。 ——风之痕 多谢方能抱歉，净手方能封喉，强敌方能证剑。 ——风之痕 问普天之下，敢在风之痕面前多谢者，能有几人。 ——风之痕 抱歉无情，你承受不了。 ——风之痕 平生横剑傲顶峰，无人敢言多谢梗。英雄遇吾恨气短，抱歉斩下绝苍生。 ——风之痕 横一眼秋波即别，仰饮岁月；掠一笔千林妩媚，不世风流。 南风不竞，南风不竞，狂情成画，歌到尽头。清风三巡不解意，拈来落花笑情多啊。 天外情风吹云立，红尘飞雨悟剑声。 山水有尽，一梦一生，何求千古空名。咏怀骋岭，舟平涛惊，长啸剑舞风轻。 ——慕灵风(山隐浮云映霜清) 观人之道以德为主，以才为辅，才德全者，尚已共次；有德无才者，其德可用；有才无德者，其才难用。 问之以是非，而观其志；穷之以辞辩，而观其变；咨之以计谋，而观其识；告之以祸乱，而观其勇；醉之以酒，而观其性；临之以利，而观其廉；期之以事，而观其信。 命里有时终须有 凡事不可强求 时至运就到，苍天不会辜负苦心人。 此后，岁月不堪记，无衣师尹不堪提。 ——无衣师尹 纵横西武林百载，神采绝顶，意气风发，败尽江山万里。独身覆灭西城魔域、缁衣十三楼，孤仞峰之战，无分正邪，群雄惊惧，再无抗手。神天三响一弦天听，万籁俱寂，千百苍生，十方归灭。初达道已感罪孽难堪，自裁三指，匿身失迹，后谓琴中伏羲，弦上魔圣。 这一剑，是忆秋年敬你人外有人，天外有天； 这一剑，是风之痕示你高山叠山，海底藏海。 你有死的觉悟吗？你有生的能为吗？ 人生就像品茗，懂得吃苦，才能回甘。 ——鷇音子 檀鸾托情遣風辞，曳如弱柳挽别思。 ——秋别 原来这个江湖，我连十天都撑不下去。 ——笑十天 错不在你，你该面对的，是人一生皆要正视的三个问题——失去什么会令人恐惧？什么值得人活下去？以及什么值得你牺牲性命？每一个问题的答案都一样，就是爱，爱不会因为你们不再相见就结束。 向佛之心无前恶。 蛰龙已惊眠，一啸动千山。 ——龙王鱽 是谁多事入江湖？人也累苦，心也累苦。 是君无聊又糊涂，不在江湖，偏问江湖。 ——药师、朱痕染迹壁有瑕 非吾小天下，才高而已。非吾纵古今，时赋而已。非吾睨九州，宏观而已。三非焉罪，无梦至胜。 天上星多月难明，地上人多心难平。是非曲直终有论，善恶到头须现形。 有心无心，心在人间。多情薄情，情系江湖。 ——莫召奴 无心亦心，自在观真；薄情非情，醉饮太平。 ——慕容情 运筹决策，坐拥江山；神飘羽动，谈笑倾城。 昂首秋千远，啸傲风间，堪寻敌手共论剑，高处不胜寒。 青灯风雨夜，白首故人心。 一曲一调流水吟，清风绿竹伴古琴。指拨千古叠叠音，震荡天下茫茫心。 身入无间，足踏黄泉。 蹉跎错，消磨过，最是光阴化浮沫。 ——最光阴 风横万里狼烟，尘嚣怒卷，世路茫然。终归古道沉眠，云波浩瀚，洗越苍天。 ——靖沧浪 枫岫主人霹雳布袋戏笑看嫣红染半山（枫），逐风万里白云间（岫）。逍遥此身不为客（主），天地三才任平凡（人）。诗号 著书三年倦写字，如今翻书不识志，若知倦书悔前程，无如渔樵未识时。 ——无衣师尹 不属天，不属地，生于三界之外，不灭六道之中。莲开千叶，传奇万古，神人唯吾，千叶传奇。 ——千叶传奇 风雨亭中避风雨，苍泊市街苍泊人，落拓莫问落拓事，一片飘萍一片心。 ——莫沧桑 何须剑道争锋？千人指，万人封，可问江湖鼎峰。三尺秋水尘不染，天下无双。 ——剑子仙迹 杀生为护生，斩业非斩人。 ——佛剑分说 天涯无岁月，歧路有风尘。百年浑似醉，是非一片云。 ——曲怀殇 天地玄妙无尽藏，星辰引渡一点光。 ——紫宫太一 与生俱来饮凶酒，唯我与天结冤仇，双脚凹弯在跑路，一肩担尽债与愁。 ——秦假仙 冷灯看剑，剑上几番功名？炉香无需计苍生，纵一川烟逝，万丈云埋，孤阳还照古陵。 ——古陵逝烟 一盏油灯消尽多少功名，一口横剑觑遍几番凉寒，一顶乌纱盖下千般污秽，一缕炉烟荡开阴史百年。 征衣红尘化云烟，江湖落拓不知年。 剑痴刀狂世纷纭，今将衣钵卸双肩。 踏尽千山无人识，当初枉受盛名牵。 东风吹醒英雄梦，笑对青山万重天。 爱落红尘心已死，持刀抱剑了一生。 ——叶小钗 半神半圣亦半仙，全儒全道是全贤。脑中真书藏万卷，掌握文武半边天。 单刀残躯饮寒风，今朝有酒醉黄龙。 ——醉饮黄龙 问郎君，寂寞欢娱恨离别，杨柳芳菲，折来谁赠？ 问郎君，春花秋月梦浮生，相思泪下，愁肠谁饮？ ——寒烟翠 正天地所不正，判黑白所不判，犯人鬼所不犯，破日月所不破。儒法、无情，法儒、无私。 ——君奉天 金光布袋戏 吾黑白郎君要以东瀛第一人的失败，来书写吾天下第一的风采！ 活在胜利之中，才是黑白郎君生存的意义。 为他人而死，就是伟大？不追求保护自己的能力，只期盼著他人的救援，这种人，真的值得帮助吗？你口中的勇气，能保护这群人到几时？今日有魔世，明日是苗疆，总有一日，你会保护不了。然后，在你看不见的地方，那些人一个一个死亡，你帮助他们了吗？没有！你只是给他们软弱的藉口，绝望时的错望！ ——黑白郎君 忏悔几时，拎剑挥尘，不省风波染一身。 玩物丧志，无地埋根，人生何处不留恨。 ——欲星移 何为天命？不可屈服于天之命运，谓之天命。 ——苍越孤鸣 其实人都有脆弱的一面，为什么不能给予包容呢？正因我们自己也同样脆弱，同样会犯错，才更需要互相扶持，赤羽先生，你不也扶持了俏如来的脆弱？ ——俏如来 为何你们每一个人，都叫我别放弃自己，最后，却是你们自己放弃自己。 ——月牙岚 无心无我，不思量，不分别，不执著，人无我，法无我，自无我，他无我，一切成空。 不生不灭，无德无功，一念缘起，一步禅空。 ——一步禅空 贱又如何？比得起遭受世俗眼光，而压抑本性的人，奴家活得何等的自在。 ——女暴君 男人的眉角就是死也不能退。 ——邪马台笑 因为历史无法回头，我们无法证明没改变会更好，所以对赞同的群众而言，只要改变就必然是正确。否则，他们就必须接受，自己是让天下动荡的原因。 ——俏如来 观星望斗惯幽居，一片神鳞渡太虚。 伯仲分时同授冕，虹霓过处尽疆域。 ——欲星移 好茶要有茶味，人，也要保持一点人味，过头就会失去身为人的骄傲。智者善于谋划人心，智者却也最难筹划感情，人心千万种，谁能逐一掌握？ ——赤羽信之介 嘘……闻到了吗？又来了，愚蠢的气息又浮现咯 ——雁王 三千白发三千恨，八百红尘八百深。 纸碎形余空伞骨，无情拆作鬼萧吟。 ——白练飞踪锦烟霞 身似秋水任飘渺，名剑求瑕亦多愁。 独向苍天开冷眼，笑问岁月几时休。 ——秋水浮萍任飘渺 风满楼，卷黄沙，舞剑春秋，名震天下。 雨飘渺，倦红尘，还君明珠，秋水浮萍。 ——任飘渺 芳菲阑珊，夙缘鶗鴃，風驷云轩愁誓约。 夜蝶飞阶，霎微雨阙，剑锋无情人葬月。 ——无情葬月 人非神人，怎可能无所不晓，正因不知，所以查探。 ——赤羽信之介 霓霞羽战火连天，墨影神誓护千年。 寄语孤鸿诛邪灭，止戈剑印荡魔渊。 ——孤鸿寄语默苍离 到目前为止，天，还不是我的对手。 ——孤鸿寄语默苍离 你以为天衣无缝的计划，破绽多的简直要吾做笔记才记得住。如果思考是生存的证明，我很难判断，你是不是一具尸体。 ——孤鸿寄语默苍离 修罗夜叉，百年孤寂，就是为了在这一刻，化为人身重逢。薰，我愿为你，再等一百年。 ——柳生鬼哭 没有决断之心的舍弃过往，不过是故作姿态。神蛊温皇要毁，不但要毁掉过去，还有现在、未来。 ——神蛊温皇 世人传颂的桃源仙境，原来从不存在，我一直没讲过，我不喜欢风花雪月。这四个字，风逝、花凋、雪融、月缺，这名字…太悲伤了。 风中散发着背叛的味道，那是血腥的气味。雪，消逝了，消逝在风中，消逝在花香中，太无情了。 雪中刻画出背叛的印记，制造了痛心的回忆，本属于无情的剑，用血来了解这一切哀悲。我又想起了，多情的花，无情的雪，当風停止追逐，月只能无言，太悲痛了。 你们都问过我，为什么我要叫做无情葬月，我一直都没向你们解释，应该说，是我不敢解释，因为，无情最是多情人。 ——无情葬月 冷静，并不是智者的专属，成功固然欢喜，失败固然愤怒，重要的是如何保住性命。自失败中站起，不管在什么情绪之下，都要保持三分冷静，才能扳回劣势。 ——赤羽信之介 既有默契，何须多言。若无默契，无须多言。 ——赤羽信之介 肯努力突破者，便无废物之说，言辞苛刻者，也非必是自慢之徒。 ——赤羽信之介 人，总是会有迷失、犹豫、痛苦、徘徊的时候，不知道自己是对还是不对。在旁人看来，你是虚弱而且优柔寡断，但那只是因为他们自己不是亲身经历的人，用一张嘴说别人那都是很简单。 ——剑无极 得到了三十年所等待结果，却失去了三十年来曾经与共的一切，这是否值得？叛逆，竞日孤鸣，已经伏诛。 数载传承太白行，惊涛骇浪剑锋鸣。凌波仙影扬尘过，潮汐瑰瑕渡死生。 ——东皇战影 夜坠天崩人失向，星沉月落鬼埋霜。 ——鬼途奇行录 23 “你要多少兵力协防？” “我，一个人。” “不需要更多？” “不能更少了” ——军师与小王对话 剑无极：这些死人跟你有什么关系？ 风逍遥：他们是我杀的，全部都是。 （剑无极和雪山银燕一怔） 剑无极：你若不是在开玩笑，那你就真正不简单了。 风逍遥：哈，你们更不简单。 雪山银燕：同为苗疆的人，为什么要这样互相残杀？ 风逍遥：别说得好像不是同族的人，就可以随便杀。在苗疆，各个山头彼此攻伐，不服王权；出了苗疆，中苗就有分别；出了中原，如今人魔对立。就算是一个门派，内部也有派系之分，小至一个家族，也会兄弟阋墙。讲到底，分的是彼此，争的是权利，抢的是利益，夺的是名声。除了自己人，就不是自己人。不是自己人，就是别人。这个分别，到底到哪里可以停止？！ 剑无极：哇，老贼头突然说起哲理来了。你所讲的我能够体会，东瀛的西剑流、东剑道之争，也是如此。 雪山银燕：讲到底，那些都是少数的野心份子的欲望。 风逍遥：如果只是少数野心份子就算了。分别，人永远会有分别。中原杀了苗人，就比苗人杀了苗人更罪恶。魔杀了人，又比人杀了人更可恶。大大小小的分别，种族的分别，属地的分别，姓氏的分别，家族的分别，血缘的分别。人啊，永远可以找出与自己不同的族群作为敌人，所以永远不会停止战争。 （风逍遥仰头而饮，又再次酹酒） 风逍遥：安心上路。 雪山银燕：但是你呢？你又为什么作战？你说这群人都是你所杀的，你为什么要杀他们？ 风逍遥：工作。 雪山银燕：我不能认同你这种工作。如果你不想做，你可以别做。杀了人，才来这用酒吊祭，太伪善！ 剑无极：笨牛啊，脾气别这么大啊。（转向风逍遥）是说我赞成他讲的话，你这种行为太假掰了。 风逍遥：我不杀他们，就是他们杀别人，或者别人杀他们。我的方针，是能少死几个就是几个。 剑无极：等你杀完了就世界和平了，是吗？ 风逍遥：不可能会有那一天。你们不就讲过，你们是中原人，我是苗人，今日萍水相逢，他日敌友难辨。这是人的劣根性。我没伟大到能够阻止。 剑无极：中苗如果和平，还有这种的分别吗？ 风逍遥：就算和平，苗人仍是苗人，中原人仍是中原人。这就是分别。 雪山银燕：这只是思考上的谬误。人可以排除这种分别。 风逍遥：你了解，我了解，你能够让全天下的人都了解吗？ 剑无极：消极。 风逍遥：各人的看法不同罢了。 剑无极：好了，到了这里，我们也应离开了。 风逍遥：在我们成为敌人之前，还能交一个朋友吗？ （从怀中掏出酒，三人同干） 剑无极：敬你，老贼头。 雪山银燕：我结交的朋友，无论立场怎转换，永远是朋友。 风逍遥：希望如此。对了，提醒你们一件事情，无论是谁叫你们来偷酒，我想啊，他都不是安什么好心。 雪山银燕：多谢你，再会。 剑无极：有机会就再见。 恋红梅：梅香坞是饮酒作乐的地方，何必为了一点么事情打坏心情。莺莺，该为诸位大爷添酒了。 岁无偿：你就是恋红梅 恋红梅：两位看起来不像是中原人，来到梅香坞，不饮酒，又是为了什么？ 岁无偿：关外行路险，入关避风雪。 恋红梅：艳阳高照，哪来的风雪。 岁无偿：风吹阳关道，人心比雪冷。 恋红梅：那更该饮一杯，暖心。 岁无偿：世上有两种心，酒暖不了 恋红梅：哪两种？ 岁无偿：看尽世态炎凉之心，丧尽天良冷血之心，老阁娘，这酒，暖的了你的心吗？ 恋红梅：先生出言不凡，是做什么营生？ 岁无偿：哪里多一点，就拿一点，哪里欠一点，就补一点。 恋红梅：原来是做买卖的，那先生这次打算补什么货？ 岁无偿：干戈江湖，兵火连天，若是找到一批坚固保身的盾，应该有利益。 恋红梅：路指刀剑铺，大爷怎会找来让客人寻欢的梅香坞？ 岁无偿：迷路失途，只好投石问路。 恋红梅：唉，我一个生意人，妇道人家，怎知道这种打打杀杀的生意。这边有不少魔世的军爷，你应该问他们才是啊。 风逍遥上场…… 风逍遥：老板娘都亲自帮你们倒酒了你们还不喝吗？还是你们比较想喝我身上这坛？（司空知命默然将手伸进铁拳）他乡遇故知，卖一点面子，来一杯嘛！ 岁无偿：请酒省下，我们倒是有不少的事情想问，望同乡不吝指教！敢问哪处山头、哪处买卖？ 风逍遥：捧一只铁碗，装九斤货，四处讨一点残羹冷饭，求一个遮风避雨、天下太平。 玉笔难图，千篇离骚，入世不踏沧桑路，出尘不落槁朽苏。别离书卷，人海泛渡，闲时舞剑点飞霜。谁人疏狂？自在如吾，一诗一剑定风波。 ——莫离骚(天之道) 山辽水阔碧连清，一步江湖几忘龄。莫使鬼途欺侠道，卓然尘外执天刑。 ——岳灵休 功名爵禄尽迷津，贝叶菩提不受尘。久住青山无白眼，巢禽穴兽四时驯。 ——神蛊温皇 炊烟尽处有人家，一亩耕勤到日斜。薄米犹同星入碗，桑居亦可号琅琊。 ——北竞王 月华缠绵登高楼，清霜秋露只无情。落梅横笛寻旧梦，平生叹愿未识卿。 ——聆秋露 善恶纷纭炼一丸，悬坨秤上两相难。三千乐土无人至，十八泥犁百事宽。 ——鸩罂粟 封侯盛世灯宵，权衡天下，百代风骚。功名不过传谣，回眸一笑，举步烟硝。 ——凰后 听琵琶，随波逐浪风流计；赏绝艺，骇浪惊波入酒茶。 ——北冥殇 人情事理，似砚多磨。登台将相，日久牢枷。扬波蹼影，不过群鹅。无争此世，得愿长歌。 ——砚寒清 星耀自古晦明时，不持太阿误剑诗。 ——李剑诗（旻月） 沉刀埋霜小楼庭，回首江湖风云轻。 君有才能纵捭阖，清溪仰望有遥星。 ——别小楼（遥星） 十方萧索无涯，千古夕阳有主。 ——星月合招 岁月年华，醉态拈花，小风时雨摘云霞，堂前燕来谁人家。行天涯，扇风雅，独倚晚沙，叹剑无瑕。 ——慕容宁 口无分寸，不识王孙；美酒香唇，颠倒晨昏。 散尽金银，当头鸿运；赌定乾坤，笑杀风云。 ——风云太岁孟高飞"},{"title":"本是青灯不归客","path":"/wiki/人生图书馆/月章星句/本是青灯不归客.html","content":"看风光你是他人过客，观内心你才是生命主人。 灾难对于愚蠢的人是无底深渊，对于聪明的人是宝贵的财富。 看取莲花清，方知不染心。 我已经过了餐桌上有只鸡就一定能吃到鸡腿的年纪了。 把告别的话藏匿于盈盈眼波。 妖若有情妖非孽，人若无情怎为人？ ——陶醉 身心尘外远，岁月坐中长。 一个人久了，煮个饺子看见两个粘在一起的也要给它分开! 当你觉得孤独无助时，想一想还有十几亿的细胞只为了你一个人而活 医不自医，人不度己。 云敛晴空，冰轮乍涌；风扫残红，香阶乱拥；离恨千端，闲愁万种。 ——《西厢记》 玉宇无尘，银河泻影；月色横空，花阴满庭；罗袂生寒，芳心自警。 ——《西厢记》 室雅何须大，花香不在多。 贾岛醉来非假倒，刘伶饮尽不留零。 福禄寿三星高照，天地人一体同春。 或为才子佳人，或为君子小人，出场便见。 有时欢天喜地，有时惊天动地，转眼皆空。 ——《少年大钦差》 演尽人间悲欢事，唱出天上思凡情。 ——《少年大钦差》 水天一色，风月无边。 养天地正气，法古今完人。 贵有恒何必三更眠五更起；最无益只怕一日曝十日寒。 学如逆水行舟不进则退；心似平原走马易放难收。 侯门深似海，怎许故人敲。 我曾七次鄙视自己的灵魂: 第一次，当它本可进取时，却故作谦卑；第二次,当它空虚时，用爱欲来填充；第三次，在困难和容易之间，它选择了容易；第四次，它犯了错，却借由别人也会犯错来宽慰自己；第五次，它自由软弱，却把它认为是生命的坚韧；第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副；第七次，它侧身于生活的污泥中虽不甘心，却又畏首畏尾。 笔底烟花传海国，袖中诗句落吴船。 世俗希望你在意的事情，你是否还耿耿于怀？ 无论我修魔修仙，修的都是心，修的都是真，只要心存善念，魔道亦是真道。 天上冷飕飕，地上滚绣球。有馅的是包子，没馅的是窝头。 你去问问你的佛，当年飞花可记得？你去问问你的佛，炼狱九层可去过？ 你去问问你的佛，三生石上刻什么？你去问问你的佛，能度苦厄，怎不渡我？ 你不要问我爱不爱你，如果有变，我会通知你的。 世界上只有一个我称之为家的地方，因为你在那里。 这么说吧，和你在一起就像人生病，离不开药方。 我思考良久，答案是我爱你。 “如果免费的话，我全要。” “真的？我就是免费的！” 这儿没人，我的心里有人。 没有人喜欢我，没有人想主动靠近我，每个人都在隔岸观火，看着我失魂落魄。 我怀疑你的本质是一本書，不然为什么我越看越想睡。 说书人乱改离分，演戏的人入戏太深。 你们知道最强的武器是什么？没错，就是补丁！ 你将忘记呼吸，你将忘记爱情。 你我的约定我一向记得，那一道道璀璨的光束，都是为你所亮。 世界上最痛苦的事情，莫过于爱你，却不能对你说出，我只能倾注于我的琴，让我的旋律诉说我的爱。 半途而废不好，所以我建议你喜欢我到老。 烟火慰风尘。 拨雪寻春，烧灯续昼。 林无静树，川无停流。 风带来故事的种子，时间使其发芽。 ——原神 花颜之所以绝世，不过在于攀折刹那的凄美。 把握现在时，将来怎会虚拟语气。追求最高级，理想常融情态动词。 行来春色三分雨，睡去巫山一片云。 窗外日光弹指过，席间花影坐前移。 流于尘世之中，行于天堂之上。 世间万物，表里如一者，又有几何？ 共君一夜话三生，话正投机君又行。 我们用初中三年去盼望高中三年，高中三年去憧憬大学四年，而用大学四年去怀念中学六年，最终用一生去祭奠我们的青春。大学毕业一年后的样子，是生活变得越来越压抑，而你，变得越来越不像自己。但逼你往前走的，不是前方希望的微弱光芒，而是身后现实的深渊万丈。 借千万人之眼，领会千万种人间。 佳思忽来，書能下酒；侠情一往，云可赠人。 极难处是書生落魄，最可怜是浪子白头。 山市晴岚、远浦帆归、平沙落雁、潇湘夜雨、烟寺晚钟、渔村夕照、江天暮雪、洞庭秋月。 二八笙歌云幕下，三千世界雪花中。 眼眸正似琉璃瓶，心荡秋水横波清。 天地不过是飘摇的逆旅，昼夜不过是光阴的门户。 人生总会有不期而遇的温暖和生生不息的希望。 凡有等待，就有启程。 躲得了对酒当歌的夜，躲不了四下无人的街。 半溪流水绿，千树落花红。 真实诞于虚拟，黑夜预告曙光。 野树晚风轻蝶梦，曲池芳草乱蛙声。 心中若有桃花源，何处不是水云间。 清风明月何须论价，高山流水定有知音。 喜欢是乍见之欢，愛是久处不厌。 一顾倾城，再顾倾国，为你倾覆又如何？ 只需浅浅回首，就能遇见你的美丽与哀愁。 岁月何其然，生活何其烦？ 留一份空白，随时浓墨重彩。 情到深处无由，愛到深处不语。 如今光明死在了漆黑的夜里，后悔莫及。更多的是对于前方的恐惧。 我害怕自己守护不了你，也不知道怎么回报你。每一次面对你的温柔，我会躲避，不是不想拥有，而是怕拥有太多最后却给不了你幸福。 其实我更希望一直付出的那个人是我，而不是你。这样不管我们的结果如何，我拥有安慰自己的能力。 风，吹淡了回忆，回忆不再是回忆，而是一种无法重来的过去。 我已经假装不愛你，你可以放心去逃离。 假如我有优势的话，那就是我没有什么可以失去的。 有多远，走多远，把足迹连成生命线。 只要你愿意，你可以把失意过成诗意。 世事难免艰难，想起你便觉温暖。 既然不能释怀，有何必假装慷慨。 人生处处好风景，自然香在有无中。 你是最烈的酒，而我正好醉过。 唯有你最深得我意，也唯有你最不识抬举。 你是我穷极一生也没做完的一场梦，而我，是你一念之间刮过的一阵风。 有什么熬不过，大不了唱首歌。 人生极乐之事，莫不是苦中作乐。 浮生长恨，风月归途是何处？ 你说不出思念的味道，因为只能用心西西的品尝；你说不出思念的芬芳，因为它只飘荡在游子的心房。 热愛一如既往，梦想来日方长。 时光如你，忽如晴天忽如雨。 人生短短三万天，我们既然来到这个世界上，谁都没有打算活着回去。 看尽千山万水，无愧来日方长。 生的再平凡，也是限量版。 我们何曾不是在乱世中醒着做梦。 我曾幻想，你一席长裙，携清扬之风，与我合奏与山间；我曾盼望，翌日清晨，不是我舞笛弄萧，就是你银铃相笑。我曾确信，你我在某个转角遇见，手持笛、肩背萧的我们，不由的相互回眸。那时起，万物定格，一切都成了虚无，天地间，只余你我。 我要踏遍山峰谷壑，看英雄留下的豪情万种，我要倚立在水天尽头，笑看芸芸众生起起落落。 放下你的浮躁，放下你的懒惰，放下你的三分钟热度，放空你禁不住诱惑的大脑，放开你容易被任何事物吸引的眼睛，放淡你什么都想聊两句的八卦的嘴巴。 静下心来好好做你该做的事情，该好好努力了，有时候真的努力后，你会发现自己比想象中的要优秀很多。 有目标的人在奔跑，没目标的人在流浪，因为不知道要去哪里。有目标的人在感恩，没目标的人在报怨，因为觉得全世界都欠他的。有目标的人睡不着，没目标的人睡不醒，因为不知道起来去干嘛。生命只有走出来的精彩，没有等出来的辉煌。 数理化门门领先，全仗导师细心结晶。 文史地科科出众，皆因先生洪恩泽沛。 莫负师恩 三更眠，五更起，寒夜秉烛迎沛雨。 千里雪，万里风，鹏举青天揽晶宫。 青云直上 十年勤奋风采三秋明月，四季艰辛文章万里长江。大展宏图 昔日我曾如此苍老，如今我才风华正茂。 有时候我们就像鱼缸里的鱼，想说的很多，可一开口，就化成了一段省略号。 也许你度过了糟糕的一天，但这并不代表你会因此度过糟糕的一生。 对一个人来说，知道自己不能做什么与知道自己能做什么同样重要。 低头不一定是软弱，有时候是发力前的预备姿势。 听说这世间除却生死皆闲事。 那一双愛笑的眼睛不适合皱眉。 最好的感觉是，当我朝你看过去时，你已经在凝视着我。 小时候常常尿湿被子，长大后常常哭湿枕头。 有些伤口之所以会痛，那是因为你总是去摸。 有时候会很想你，但是有太多理由不可以。 表白与被表白并不可怕，可怕的是，结局不是谈一次恋愛，而是少一个朋友。 这个世界上什么都有障眼法，看到的未必是真的，真的未必会幸运的看到。 我的离开成就了谁的海阔天空。 竹菊梅兰可养性，琴棋書畵可怡情。 让平安坐上冬天的地铁，让快乐与你不见不散，让健康与吉祥一个都不能少，让温馨和幸福没完没了！ 风柔雨润花好月圆，冬去春来似水如烟，幸福生活天天伴随，良辰美景年年期盼。说一声珍重，道一声平安。 有些事，需要懂一辈子。有些事，需要一辈子来懂。 在生活中，退一步海阔天空。 在愛情中，退一步人去楼空。 拥有不同心境，相信你会看到不同的风景。 剑网三是否在你身后站的太久，你已忘了回头。师父说善谋者不可动情，动情便是输。世间万物皆可入棋，非黑即白。枉我平生自诩聪明，为何总觉困在局中。"},{"title":"简单笔记","path":"/wiki/人生图书馆/月章星句/简单笔记.html","content":"前右 右上 上左 右下 上右 前左 鱼1 右上 上左 右下 上左 右上 上左左 右下 右上上 前右右 右下 后右 右上 前后后 右下 后左 右下"},{"title":"小小的欢喜","path":"/wiki/人生图书馆/瑰丽的谜题/小小的欢喜.html","content":"Your browser does not support the audio tag. 简单的缘起 12.17 日，一个和平常没有什么特殊的日子，却因为和她的相识而变得更加的生动多彩，更加值得我铭记一生。本以为只是单纯的打一会儿游戏，不曾想我就多了一份人生中最别致、最欢喜的时光，是我二十多年来从未有过的体验。 我喜欢她，喜欢和她一起聊天的时光，喜欢听她说一些碎碎念…我只是单纯的喜欢，无关风月，虽然中途自作多情，一厢情愿，但还好自己比较克制。 别样的欢喜 一旦沉浸在自己喜欢的事情中，时间往往在不知不觉中流逝。 我们加了微信，互相打了招呼，和我工作时添加其他人的时候差不多。然而没想到的是，她居然主动联系我。天啊😱，我当时的心情真的是太激动了！怎么说呢，惊喜！对，是的，我很疑惑，从来没有人这样和我聊过。那是我们第一次聊天，但是天南地北，日月星辰，无所不谈。一向不是很健谈的我在她面前居然没有成为话题终结者。额，或者说她很健谈？尽管大部分时间都是她在说，我在听，但这并不妨碍我们共同度过很长的时间，我由衷感到开心。或许人就是这样的感情动物吧！很多不敢在熟人面前说的话，我却能在她面前毫无保留的说出来。 我们一起走过了很长的时间，她教过我很多，比如如何夸女孩子，再比如如何怼人… 慢慢的，我不知道自己哪根筋错了，内心狂热的认为自己愛上了她。当时我想，愛情与我而言就是这样吧，她对我没有异样的目光，不在乎我是否说错话，还经常为我指点迷津。现在想来，自己当时真的是无可救药，不可理喻。也许现在的我还是比较自卑吧，有人温柔对我，我就会喜欢她，这样就不是愛情了。还好，后面自己冷静了下来，也思考了很久。她是我的挚友！此生识君，生死无悔！ 楔子人生的第一次戀愛的感觉，第一次吃醋，第一次和女孩长谈…不曾有过的体验，那时都经历了一遍。仿佛她是上天派来的使者，特意给我留下一段朦胧别致而又终身难忘的经历。来自心底的温暖 不知是不是我的一厢情愿那个冬天，我说，我有点儿冷，等我先进被窝再说。她说，哥哥缺一个我。那一刻，我的心底有一丝暖意，慢慢扩散至全身。朦胧的诗句锦瑟李商隐锦瑟无端五十弦，一弦一柱思华年。庄生晓梦迷蝴蝶，望帝春心托杜鹃。沧海月明珠有泪，蓝田日暖玉生烟。此情可待成追忆，只是当时已惘然。唐她说，她很喜欢这首诗。但是我没有告诉她，我当时只读了两遍就记在了心里。愛意悄无声息的滋长 我愛她……另一个我 她喜欢的人她说，我的声音比较好听，感觉很年轻！但是呢，就是一个毫无感情的读词机器。另一个我 她讨厌的人她说，人不能过于自恋。我立马就想到了当时自己的一厢情愿。关于人生我说，我不想活太长时间，40 岁左右就可以了，然后死亡。她说，我也是哎，活着就很累。我说，这花花世界你不想再多看看吗？还有很多帅哥呢！八块腹肌的哦！她说，想啊，但我是不婚主义者。我只希望早点儿退休。其它我不知羞耻的问她，旅游能不能带上我，端茶递水、收拾行囊我统统在行滴！我喜欢听她感冒时的声音，哈哈哈哈哈哈哈哈哈~ 微小的祝福 驰隙流年，恍如一瞬星霜换。我会一直记得和她之间的小故事，一直一直记在心里，因为当时有她，和我，还有我们那小小的欢喜。 祝福她有美好的未来，有精彩的故事，希望她学业有成，考的全会，蒙的全对，高考时可以顺利进入自己喜欢的学校学习，同时我也希望未来有一天，她会把她的故事一一告诉我听。 某年某月的某一天，你是否也会把我这傻瓜想念。"},{"title":"元","path":"/wiki/人生图书馆/裁云剪水/元.html","content":"山高水长，物象万千。 非有老笔，清壮何穷。 芦花被贯云石仆过梁山泊，有渔翁织芦花为被。仆尚其清，欲易之以绸者。翁曰：“君尚吴清，愿以诗输之。”遂赋，果却绸。采得芦花不涴尘，翠蓑聊复藉为茵。西风刮梦秋无际，夜月生香雪满身。毛骨已随天地老，声名不让古今贫。青绫莫为鸳鸯妒，欸乃声中别有春。元 蟾宫曲卢挚江城歌吹风流，雨过平山，月满西楼。几许年华，三生醉梦，六月清秋。按锦瑟佳人劝酒，卷珠帘齐按凉州。客去还留，云树萧萧，河汉悠悠。元曲"},{"title":"唐","path":"/wiki/人生图书馆/裁云剪水/唐.html","content":"山高水长，物象万千。 非有老笔，清壮何穷。 酬李穆见寄刘长卿孤舟相访至天涯，万转云山路更赊。欲扫柴门迎远客，青苔黄叶满贫家。唐诗 江楼夕望招客白居易海天东望夕茫茫，山势川形阔复长。灯火万家城四畔，星河一道水中央。风吹古木晴天雨，月照平沙夏夜霜。能就江楼消暑否？比君茅舍较清凉。唐诗 江亭夜月送别 · 其二王勃乱烟笼碧砌，飞月向南端。寂寞离亭掩，江山此夜寒。唐诗 田舍杜子美田舍清江曲，柴门古道旁。草深迷市井，地僻懒衣裳。榉柳枝枝弱，枇杷树树香。鸬鹚西日照，晒翅满鱼梁。唐诗 积雨辋川庄作王维积雨空林烟火迟，蒸黎炊黍饷东菑。漠漠水田飞白鹭，阴阴夏木啭黄鹂。山中习静观朝槿，松下清斋折露葵。野老与人争席罢，海鸥何事更相疑。唐诗 端居李商隐远书归梦两悠悠，只有空床敌素秋。阶下青苔与红树，雨中寥落月中愁。唐诗"},{"title":"宋","path":"/wiki/人生图书馆/裁云剪水/宋.html","content":"山高水长，物象万千。 非有老笔，清壮何穷。 诉衷情·七夕毛滂短疏萦绿象床低，玉鸭度香迟。微云淡暑河汉，凉过碧梧枝。秋韵起，月阴移，下帘时。人间天上，一样风光，我与君知。宋词 吉祥寺赏牡丹苏东坡人老簪花不自羞，花应羞上老人头。醉归扶路人应笑，十里珠帘半上钩。宋词 北陂杏花王安石一陂春水绕花身，花影妖娆各占春。纵被无情吹作雪，绝胜南陌碾作尘。宋词 赠刘景文苏子瞻荷叶已无擎雨盖，菊残犹有傲霜枝。一年好景君须记，正是橙黄橘绿时。宋词 虞美人陈与义扁舟三日秋塘路，平度荷花去。病夫因病得来游，更值满川微雨洗清秋。去年长恨拏舟晚，空见残荷满。今年何以报君恩，一路繁花相送过青墩。宋词 鄂州南楼書事黄庭坚四顾山光接水光，凭栏十里芰荷香。清风明月无人管，并作南楼一味凉。宋词 南歌子张先蝉抱高高柳，莲开浅浅波。倚風疏叶下庭柯。况是不寒不暖，正清和。浮世欢会少，劳生怨别多。相逢休惜醉颜酡。赖有西园明月，照笙歌。宋词 初秋俞桂火老金柔暑告残，乘凉正好望西山。秋声来处无寻觅，只作窗前竹叶间。宋 村居书喜陆游红桥梅市晓山横，白塔樊江春水生。花气袭人知骤暖，鹊声穿树喜新晴。坊厂酒贱贫犹醉，原野泥深老亦耕。最喜先期官赋足，经年无吏扣柴荆。宋 题画李唐云里烟村雨里滩，看之容易作之难。早知不入时人眼，多买胭脂画牡丹。宋诗 九日次韵王巩苏东坡我醉欲眠君罢休，已教从事到青州。鬓霜饶我三千丈，诗律输君一百筹。闻道郎君闭东阁，且容老子上南楼。相逢不用忙归去，明日黄花蝶也愁。宋诗 春游王令春城儿女纵春游，醉倚层台笑上楼。满眼落花多少意，若何无个解春愁？宋诗"},{"title":"明","path":"/wiki/人生图书馆/裁云剪水/明.html","content":"滚滚长江东逝水，浪花淘尽英雄。 是非成败转头空，青山依旧在，几度夕阳红。 白发渔樵江渚上，惯看秋月春风。 一壶浊酒喜相逢，古今多少事，都付笑谈中。"},{"title":"清","path":"/wiki/人生图书馆/裁云剪水/清.html","content":"相见欢张惠言年年负却花期，过春时，只和安排愁绪送春归。梅花雪，梨花月，总相思。自是春来不觉去偏知。清 水调歌头·春日赋示杨生子掞张惠言长镵白木柄，劚破一庭寒。三枝两枝生绿，位置小窗前。要使花颜四面，和着草心千朵。向我十分妍。何必兰与菊，生意总欣然。晓来风，夜来雨，晚来烟。是他酿就春色，又断送流年。便欲诛茅江上，只恐空林衰草，憔悴不堪怜。歌罢且更酌，与子绕花间。清"},{"title":"Docker入门","path":"/wiki/技术加油站/CloudService/Docker.html","content":"一、Docker入门 二、准备 镜像源配置 1. 命令行设置国内镜像源 2. 编辑配置文件设置镜像加速 三、常用命令 四、Docker进阶 1. Docker为什么提供网络功能？ 2. docker数据卷（volume） 五、Dockerfile 六、docker-compose 1. 常用命令 2. docker-compose.yml示例 3. 使用portainer可视化工具 4. 卸载 Docker 一、Docker入门 镜像与容器概念？ 用重装系统来解释的话，镜像（images）就是我们要装的系统（win7、win10、manjaro 等 iso 文件），容器好比是 U 盘。我们可以把系统放进各种容量足够的 U 盘里，那么这个 U 盘就是一个容器，当我们需要重装系统的时候，就使用（启动）这个 U 盘（容器）。 因此，一个镜像可以去创建多个容器，各个容器之间互不干扰。 Q：docker 拉取的镜像为什么比我们直接下载的文件体积大？ A：一个镜像不仅仅是原来的软件包，它还包含了软件包运行所需的操作系统依赖、软件自身依赖等。所以随着我们的使用，使用的镜像越多，新的镜像下载会越来越快，因为有些依赖已经存在，后续的镜像如果对存在的依赖有使用的话，它会复用已经存在的依赖，而不会去再次下载。 二、准备 为了避免使用普通用户运行 docker 的相关命令时出现报错，我们可以在docker命令前加上sudo去运行，但是每次都加显然很麻烦。那么在安装完docker后，可以使用以下命令： 12345678# 创建 docker 用户组sudo groupadd docker# 将当前普通用户加入 docker 组中sudo gpasswd -a $USER docker# 更新 docker 组newgrp docker# 测试命令docker ps 镜像源配置 有两种方法修改镜像源，一种是命令行命令，另一种是修改相关文件。 1. 命令行设置国内镜像源 1dockerd --registry-mirror=https://hub-mirror.c.163.com 2. 编辑配置文件设置镜像加速 /etc/docker/daemon.json12345678910111213&#123; &quot;registry-mirrors&quot; : [ &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;https://hub-mirror.c.163.com&quot; ], &quot;insecure-registries&quot; : [ &quot;registry.docker-cn.com&quot;, &quot;hub-mirror.c.163.com&quot;, &quot;docker.mirrors.ustc.edu.cn&quot; ], &quot;debug&quot; : true, &quot;experimental&quot; : true&#125; 设置完毕重启 docker 服务。 1systemctl restart docker 加速源 url 说明 Docker 官方提供 https://registry.docker-cn.com 无需注册，已关闭，无法使用 中科大 https://docker.mirrors.ustc.edu.cn/ 无需注册（推荐）暂时无法使用，留意官网通告 阿里云 登录阿里云的容器hub服务，镜像加速器那一栏里会为你独立分配一个加速器地址 需要注册 网易云 https://hub-mirror.c.163.com 无需注册 三、常用命令 1234567891011121314151617181920212223242526272829303132333435# 镜像操作docker search name # 根据镜像名称查找镜像docker pull 镜像名称:版本号 # 拉取镜像，注意对应的版本号docker images -a # 列出本地所有的镜像docker images --digests # 显示镜像的摘要信息docker images --no-trunc # 显示完整的镜像信息docker rmi name/id # 删除镜像，-f 选项强制删除docker info # docker详细信息# 容器操作docker ps # 列出当前正在运行的容器docker ps -a # 列出所有的容器docker ps -q # 列出所有的容器IDdocker inspect name/id # 查看容器内部信息docker stop name/id # 停止容器运行docker start name/id # 启动容器docker restart name/id # 重启容器docker rm name/id # 删除容器，-f 选项强制删除docker logs name/id # 查看容器服务运行日志docker logs -f name/id # 实时监听服务运行日志docker logs -t name/id # 为服务运行日志加入时间戳# 复制容器内部的配置文件到宿主机# docker cp name/id:源文件source 宿主机目录targetdocker cp nginx:/etc/nginx/nginx.conf /data/docker-service/nginx/nginx.conf# 进入容器docker exec -it name/id bash# 将容器打包成一个新的镜像docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot; 容器名称或者ID tarName:tag# 将镜像备份,备份为 .tar 文件docker save 镜像名称:标签 -o fileName 以上的 name/id 均指容器创建时指定的名称或者容器的标识id（docker ps可以查看）. 接下来以 MySQL 为例来体会一下docker，使用之前确定网络连接良好。 12345678910111213141516171819202122232425262728293031323334353637383940414243# 查找docker hub中是否有MySQL镜像，可以去 [docker hub](https://hub.docker.com/) 的官网搜索版本docker search mysql# 拉取MySQL8.0.20版本docker pull mysql:8.0.20# 查看拉取的镜像docker images# 创建并运行容器 MYSQL_ROOT_PASSWORD 该项在启动时必须指定，不然容器启动失败# mysql:8.0.20 就是使用刚刚下载的镜像创建容器；如果不写会自动下载最新版本的镜像docker run -d -p 9999:3306 --name mysql8 -v /docker-data/mysql/data:/var/lib/mysql -v /docker-data/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --restart=always mysql:8.0.20# 查看 mysql8 容器是否运行docker ps# 查看容器信息docker inspect mysql8# 进入容器docker exec -it mysql8 bash# 进入 mysql 命令行，登录 mysqlmysql -u root -p# 退出 bash，退出容器exit# 停止容器docker stop mysql8# 再次查看正在运行的容器docker ps# 查看本地所有的容器（启动成功和启动失败的都会显示）docker ps -a# 删除容器docker rm mysql8# 再次查看本地所有的容器docker ps -a# 删除下载的 mysql8.0.20 镜像docker rmi mysql:8.0.20# 查看已下载的镜像docker images 选项 说明 run 运行一个docker容器 –name 指定容器的名字 mysql8 -p 9999:3306 设置端口映射：宿主机映射端口:容器运行端口；客户端工具(例如navicat)连接时可以通过 9999 端口进行连接 -e MYSQL_ROOT_PASSWORD=123456 添加环境变量：初始化root用户的密码为 123456 -d 表示使用守护进程运行，即服务挂在后台运行 -v 数据卷映射，本地目录在前，容器内目录在后。删除容器后，映射的本地目录内容仍然存在 –restart=always 在 docker 服务启动后，自动运行该容器 如果已经运行的容器想要设置跟随 docker 服务启动，使用下面的命令 docker update --restart=always name/id 四、Docker进阶 1. Docker为什么提供网络功能？ Docker允许通过外部访问容器或容器互联的方式来提供网络服务，方便了不同容器间进行通信。一般在使用docker网桥(bridge)实现容器与容器通信时，都是站在一个应用角度进行容器通信。 12345678910# 查看网桥配置docker network ls# 创建网桥docker network create 自定义网桥名称# 删除网桥docker network rm 网桥名称或ID# 查看网桥详情docker inspect 网桥名称或ID# 运行容器时使用 --network 网桥名称 指定该容器在那个网桥段docker run -d --name mysql -p 3306:3306 --network ems mysql:8.0 网桥不会自动创建，如果要使用网桥，必须 先创建，再使用； 运行容器时指定的网桥不存在，那么会导致这个容器运行失败。在容器启动时指定了网桥后，在这个网桥中的所有容器，可以直接使用容器名称与其它容器通信。类似于同一局域网进行联机对战。 1234docker run -d --name tomcat01 -p 8081:8080 --network ems tomcat:8.0-jre8docker run -d --name tomcat02 -p 8082:8080 --network ems tomcat:8.0-jre8# 之后可以通过名称去访问tomcat02的主页信息curl http://tomcat02:8082 2. docker数据卷（volume） 数据卷的修改会立即影响到容器； 对数据的更新修改，不会影响镜像； 数据卷默认一直存在，即使容器被删除 实现容器与宿主机之间数据共享。数据卷就是上面创建mysql时的 -v 指定的映射目录，可以把容器内的数据持久化，这样删除容器时我们不必担心数据丢失。但是注意，这样做外部的改变和容器内部的改变会互相影响。 如果我们希望外部影响内部，但是内部操作不影响外部的话，在创建容器时我们可以这样指定： -v /usr/mysql/data:/var/lib/mysql:ro，其中 ro 代表只读(read only)。前面的映射目录我们也可以使用数据卷简称，这个简称可以随便起名，例如：-v aa:/var/lib/mysql，这样docker会自动帮我们创建 aa 存储目录，可以使用 docker volume inspect aa查看它的路径。 12345678910# 查看数据卷docker volume ls# 查看数据卷信息docker volume inspect 卷名# 创建数据卷docker volume create 卷名# 删除数据卷docker volume rm 卷名# 删除没有使用的数据卷，删除前需要我们手动确认docker volume prune 五、Dockerfile 如果不清楚 Dockerfile 的相关指令含义，可以查阅官方文档，有清晰的介绍。Dockerfile 文件中的命令必须使用大写，通常以 FROM 指令开始。 官方文档https://docs.docker.com/engine/reference/builder/ 下面使用 Dockerfile 创建 Java 镜像在容器运行作为一个简单的 Demo，其实，它也是很简单的。首先创建一个空的文件夹，在空文件夹中创建 DockerFile 文件，编辑： 123456789101112# 以 openjdk:8-jre 为基础FROM openjdk:8-jre# 指定目录后，下面的命令都是基于此目录进行的WORKDIR /application# 基于 WORKDIR 的路径,/application/aaWORKDIR aa# 该文件上传后，直接改名为 app.jarADD app-0.0.1-SNAPSHOT.jar app.jar# 暴露的端口EXPOSE 8081# 运行时执行的命令ENTRYPOINT java -jar app.jar 构建自定义镜像：docker build -t demo:1.0 .，注意最后的 . 不要漏掉。 用自定义镜像启动容器：docker run -d -p 8081:8081 --name demo demo:1.0 六、docker-compose docker-compose 和 Dockerfile 很相似，都是需要我们写一个文件，文件中按照特定的格式去写一些内容和指令，再使用命令去运行这个文件。一个 docker-compose 对应一个 stack。 和 docker 的不同：docker是面向容器的，而 docker-compose 是面向服务的，这也是两者本质区别。 另外，如果是 Window 系统，安装 Docker for Window 后就包括了 dcoker-compose 工具；如果是 Linux 系统，那么额外需要安装 docker-compose 插件。没错，docker-compose 是 docker 的一个插件。 docker-compose官网安装说明https://docs.docker.com/compose/install/ 1. 常用命令 123456789101112131415161718192021222324252627282930313233343536# 查看帮助docker-compose --help# 启动服务的命令,默认前台启动；如果文件名称是 `docker-compose.yml` 可以省略，其它名称不可省略。docker-compose up docker-compose.yml 或者直接 docker-compose updocker-compose up docker-test.yml# 后台启动docker-compose up -d# 停止所有 up 启动的服务,并移除网络docker-compose down# 进入指定的容器，注意写的是服务名称docker-compose exec# 列出当前 docker-compose 运行的所有容器docker-compose ps# 重启项目中服务，后面不写服务名代表重启所有服务。还有 start stop 指令，与之类似，略过。docker-compose restart# 强制删除（-f）并删除数据卷（-v，慎用-v选项）docker-compose rm -f -v# 查看每个服务容器内的进程docker-compose top# 唤醒服务docker-compose unpause# 暂停服务docker-compose pause# 查看服务日志docker-compose 服务 logs 2. docker-compose.yml示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071version: &quot;3.8&quot; # 4.0以下services: tomcat: # 唯一服务名称 image: tomcat:8.0-jre8 # 使用哪个镜像创建 # 用来指定 dockerfile 所在目录。 # 和 image 的不同：先根据该文件构建镜像，之后再运行容器 build: # dockerfile 文件所在的目录 context: demo dockerfile: Dockerfile container_name: tomcat # 指定容器名称 ports: # 宿主机与容器的的端口映射 - &quot;8080:8081&quot; volumes: # 宿主机与容器的目录映射 #- /root/data:/usr/local/tomcat/ # 自定义映射 - tomcatwebapps:/usr/local/tomcat/webapps networks: # 指定容器启动后使用的哪个网桥 - hello mysql: image: mysql:8.0 container_name: mysql ports: - &quot;3306:3306&quot; volumes: - /root/mysql/data:/var/lib/mysql - /root/mysql/config:/etc/mysql enviroment: - MYSQL_ROOT_PASSWORD=root # 可以把 environment 的内容写到配置文件中 env_file: # 配置文件必须以 .env 结束 - mysql.env # 代表这个容器启动时依赖哪些模块，服务名称,不是容器名称 depends_on: - tomcat - redis # 用来修改容器内部参数；因为如果不修改的话容器可能无法启动 sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp.syncookies=0 # 修改容器中系统内部进程数限制；根据当前容器运行服务要求更改 ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 redis: image: redis:6.2.5 container_name: redis ports: - &quot;6379:6379&quot; volumes: - redisdata:/data # 启动时覆盖容器的默认命令 command: &quot;redis-server --appendonly yes&quot;volumes: tomcatwebapps: # 自定义映射卷标需要显式声明 # 是否确定使用指定卷标 # false 会使用 项目名 + 卷标名 external: true redisdata: networks: # 定义上面服务用到的网桥名称，默认就是 bridge hello: # 是否确定使用指定名称的网桥 # false 会使用 项目名 + 网桥名称 external: true 同一网络中的服务可以使用服务名称进行通信 3. 使用portainer可视化工具 下载可视化工具：docker pull portainer/portainer 启动 portanier，需要开放两个端口，8000 为监听服务的端口，9000 为向外部提供服务的端口。 docker -d -p 8000:8000 -p 9000:9000 --name portanier --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 浏览器访问 http://localhost:9000 4. 卸载 Docker 1234sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extrassudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd"},{"title":"Docker启动常用服务","path":"/wiki/技术加油站/CloudService/Docker启动常用服务.html","content":"Docker Hub 上可以搜索并查看镜像以及版本~~（2023 年算是挂了，访问不了了，只能使用镜像源在命令行搜索了），选择合适的进行拉取/下载。相应的镜像里都有官方的的启动说明可以参考（参考不了了，烦死了，拉取速度不是问题，问题是文档！）~~，本文只是水文。 Docker Hub 上的镜像有三种标签是可以信任的： DOCKER OFFICIAL IMAG：Docker 官方镜像，是一组精心策划的 Docker 开源和即插即用解决方案存储库。 Verified Publisher：Docker 验证镜像，来自 Docker 验证的出版商的高质量镜像。这些产品由商业实体直接发布和维护。这些镜像不受速率限制。 Sponsored OSS：Docker 赞助的开源软件镜像，这些镜像由 Docker 通过开源计划赞助的开源项目发布和维护。 本文基于 OFFICIAL IMAG，较为通用。如果各位少侠使用用户打包的镜像，目录、配置文件什么的需要参照文档，但是现在，文档看不了啦，呜呜呜。 1. MySQL 1234567891011121314# 创建所需目录mkdir -p /data/server/mysql/conf.d &amp;&amp; mkdir -p /data/server/mysql/datacd /data/server/mysql# 拉取镜像docker pull mysql:8.0.34# 启动一个简单的基础镜像（只是用来复制配置文件，用完就删除）docker run --name mysql-test -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0.30# 官方镜像的配置文件在 /etc/my.cnf 中docker cp mysql-test:/etc/my.cnf conf.d/# 删除镜像docker rm mysql-test# 使用自定义的配置文件启动MySQL并且在启动时创建一个数据库docker run -d -p 3306:3306 --name mysql8 -v /data/server/mysql/conf:/etc/mysql/conf.d -v /data/server/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -v MYSQL_DATABASE=要创建的数据库名称 --restart=always mysql:8.0.30 -e 选项必须指定！如果可以访问 docker hub 官网的话，MySQL 镜像文档中有说明示例（这才是真正有用的！网上全是提速的配置，其实完全不用担心，大公司/高校肯定是有加速源的）。 启动完成后，进入 MySQL 的 bash 环境: docker exec -it mysql bash，执行下面几个条命令开启远程连接： 12345678910111213141516use mysql;# MySQL8.0 之前授权远程连接，password 根据自身情况修改GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27; WITH GRANT OPTION;# 刷新权限FLUSH PRIVILEGES;# MySQL8.0 之后授权远程连接# 方式一create user root@&#x27;%&#x27; identified by &#x27;password&#x27;;grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;flush privileges;# 方式二grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;flush privileges; 如果需要导入之前的数据库备份文件到此容器中，使用以下命令 12docker cp /data/server/mysql/data/备份文件.sql mysql:/var/lib/mysqlsource 备份文件.sql; 如果本机使用可视化工具（dbeaver、navicat）连接出现以下错误：Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’，请使用 127.0.0.1 连接，不要使用 localhost。 从容器中备份数据 1234567891011# 导出单张表的数据（含结构）docker exec -it [contain_id/contain_name] mysqldump [db_name] -u[username] -p[password] --tables [table_name] &gt; /home/user/xxx.sql# 导出单张表的数据（不含结构）docker exec -it [contain_id/contain_name] mysqldump -t [db_name] -u[username] -p[password] --tables [table_name] &gt; /home/user/xxx.sql# 导出数据库数据（含结构）docker exec -it [contain_id/contain_name] mysqldump -u[username] -p[password] [db_name] &gt; /home/user/xxx.sql# 导出数据库数据（不含结构）docker exec -it [contain_id/contain_name] mysqldump -t -u[username] -p[password] [db_name] &gt; /home/user/xxx.sql# 只导出整个数据库的结构docker exec -it [contain_id/contain_name] mysqldump --opt -d -u[username] -p[password] [db_name] &gt; /home/user/xxx.sql 2. Redis Redis默认开启的是快照模式(RDB)，可以开启AOF持久化(最多丢1s内数据) 12345678# 创建所需目录mkdir -p /data/server/redis/conf &amp;&amp; mkdir -p /data/server/redis/datacd /data/server/redis# 此处如果使用自定义配置文件，在 conf 文件中建立 redis.conf 文件添加内容即可# 指定配置文件并开启AOF持久化后台启动docker run -p 6379:6379 --name redis -v /data/server/redis/conf:/usr/local/etc/redis -v /data/server/redis/data:/data -d redis:6 redis-server /usr/local/etc/redis/redis.conf --appendonly yes Redis6.2 配置文件：https://raw.githubusercontent.com/redis/redis/6.2/redis.conf https://redis.io/docs/management/config/ 3. Nginx 12345678910111213141516171819# 创建所需目录mkdir -p /data/server/nginx/conf.dmkdir -p /data/server/nginx/htmlmkdir -p /data/server/nginx/logcd /data/server/nginx# 拉取镜像docker pull nginx:1.24# 启动一个简单的基础镜像（只是用来复制配置文件，用完就删除）# 如果自己复制文件内容，此步可以跳过docker run --name nginx-test -d nginx:1.24docker cp nginx-test:/etc/nginx/nginx.conf ./docker cp nginx-test:/etc/nginx/conf.d/default.conf conf.d/# 删除镜像docker stop nginx-test &amp;&amp; docker rm nginx-test# 启动docker run --name nginx -p 80:80 -v /data/server/nginx/nginx.conf:/etc/nginx/nginx.conf:ro -v /data/server/nginx/html:/usr/share/nginx/html -v /data/server/nginx/log:/var/log/nginx -v /data/server/nginx/conf.d:/etc/nginx/conf.d -d nginx:1.24 注意：nginx的配置文件必须和版本一致。 ro 代表只读(read only): 外部的改变能够影响内部，内部的改变不会影响外部。 4. RabbitMQ 12# 使用自定义配置信息启动docker run -d --name RabbitMQ -p 15672:15672 -p 5672:5672 -v /data/server/rabbitmq/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf rabbitmq:3.8-management 5672 端口是与程序进行通信的，比如Java。rabbitmq:3.8-management 连带服务和管理界面的插件一并启动(默认的账号密码：guest/guest)，而 rabbitmq:3.8 是没有管理界面的。 如果在启动时指定用户名、密码可以加上以下内容。 123-e RABBITMQ_DEFAULT_VHOST=/ems-e RABBITMQ_DEFAULT_USER=root-e RABBITMQ_DEFAULT_PASS=root 5. ElasticSeach And Kibana ElasticSeach 官方指导教程：https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html Kibana 官方教程传送：https://www.elastic.co/guide/en/kibana/current/docker.html 直接启动 ES 容器会报错，解决方案： 1.编辑宿主机 vim /etc/sysctl.conf 加入 vm.max_map_count=262144，保存退出 2.sysctl -p"},{"title":"Docker安装Oracle11g","path":"/wiki/技术加油站/CloudService/Docker安装Oracle11g.html","content":"使用 Docker 安装 Oracle 数据库，注意拉取的镜像名称，该镜像非官方镜像，所有的操作都是在拉取的镜像的基础上进行的。 镜像获取 1234567# 拉取镜像，推荐使用这一个，不然后续无法进行docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g# 运行oracle 11g镜像docker run -d -p 1521:1521 --name oracle11g registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g# 进入容器docker exec -it oracle11g bash 导入环境变量 12# 切换到root用户 密码：helowinsu - root 编辑 vim /etc/profile /etc/profile123export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2export ORACLE_SID=helowinexport PATH=$ORACLE_HOME/bin:$PATH Oracle配置 123456789101112131415# 切换到oracle用户su - oracle# 进入oracle目录cd $ORACLE_HOME# 启动$ORACLE_HOME/bin/sqlplus /nolog# 连接conn /as sysdba# 修改system的密码并设置密码的有效时间为无限alter user system identified by oracle;ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;# 创建 test 用户create user test identified by test;# 授权grant connect,resource,dba to test; 创建表空间 表空间需要如下设置后才能创建，否则会创建失败。 123show parameter db_create_file; ALTER SYSTEM SET db_create_file_dest = &quot;/home/oracle/app/oracle/oradata&quot;"},{"title":"初识 Kubernetes","path":"/wiki/技术加油站/CloudService/Kubernetes.html","content":"官方文档https://kubernetes.io/zh-cn/docs/home/ 中文文档https://kubernetes.io/docs/home/ Pod &amp; Container Kubernetes 的最小调度单元是 Pod，在 Pod 中包含多个 Container。 Pod 基本操作 查看 Pod pod 默认有 kube-default 和 kube-system 两个命名空间。 1234567891011121314151617# 查询默认 podkubectl get po|pod|pods# 查询指定命名空间的所有 podkubectl get pods -n [namspace]# 查询当前命名空间的所有 podkubectl get pods -A# 查看指定命名空间下 pod 的详细信息kubectl get pod -o wide -n [namspace]# 查看所有命名空间下 pod 的详细信息kubectl get pod -o wide -A# 查看指定 pod 的详细信息（不能查看 pod 中的具体容器，pod 为最小管理单元）kubectl describe pod [pod-name] 创建 Pod 先说一种不常用的方式，这种方式很 docker，该方式生产中一般不用。 12# 创建 podkubectl run [podname] --image=nginx:1.24 常用的创建方式：yml 文件(必须)，创建 nginx-pod.yml 文件加入以下内容： nginx-pod.yml12345678910111213141516171819# api 版本apiVersion: v1# 创建的分类kind: Pod# 标准的对象元数据（用户自定义信息，例如 pod 名称等）。更多信息： https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadatametadata: name: nginx # 标签 labels: key: value# 对 Pod 预期行为的规约。更多信息： https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-statusspec: containers: - name: nginx image: nginx:1.24 ports: - containerPort: 80 restartPolicy: Always IDEA 使用 Kubernetes 插件创建 yml 文件后输入 k 可以选择创建模板。 创建 pod： 12345# 创建时如果 pod 已经存在则报错kubectl create -f nginx-pod.yml# 创建时如果 pod 已经存在则更新（推荐使用）kubectl apply -f nginx-pod.yml 默认会部署 pod 到当前的命名空间，如果要部署应用到指定的命名空间：kubectl apply -f filename.yml --namespace [namespace] 删除 Pod 12345# 直接删除 podkubectl delete pod [podname]# 通过配置文件也可以删除已经存在的 pod(推荐使用)kubectl delete -f [pod-yml] Pod 其它操作 1234567# 进入 pod 中的指定容器，-c 指定进入 pod 的容器名称kubectl exec -it [podname] -c [containername] -- bash# 查看 pod 所有容器的日志，使用 -f 可以查看实时日志kubectl logs -f [podname]# 查看 pod 指定容器的日志kubectl logs -f [podname] -c [containername] Pod 的 label 标签 标签是一组键值对组成，每个 key 对与给定对象必须是唯一的。 Pod Labels 必须小于 63 个字符；必须以字母、数字、字符开头和结尾；包含破折号、下划线、点和字母数字； 操作 123456789101112# 显示所有 pods 的 labelskubectl get pods --show-labels# 为已经创建的 pod 添加 labelkubectl label pod [podname] [key=value]# 修改 pod 的 labelkubectl label --overwrite pod [podname] [key=value]# 删除 key 后面添加一个 - 即可删除kubectl label pod [podname] [key-]# 筛选指定标签的 podskubectl get pods -l [key/key=value] Pod 的生命周期 Container 容器 容器重启策略 Pod 的 spec 包含一个 restartPolicy 字段，有三个可选值：Always（总是重启）、OnFailure（容器异常退出）、Never，默认为 Aways。 该值适用于 Pod 中的所有容器。 自定义容器的启动命令 推荐在 k8s 中使用 command 修改启动命令，使用 args 为启动命令传递参数。 1234567891011121314151617apiVersion: v1kind: Podmetadata: name: redis # 标签 labels: app: redisspec: containers: - name: redis image: redis:7.0.14 command: [&quot;redis-server&quot;] args: [&quot;--appendonly yes&quot;] ports: - containerPort: 6379 imagePullPolicy: IfNotPresent restartPolicy: Always 容器探针 probe 是由 kubelet 对容器执行的定期诊断，可以看作一个诊断工具。探针检测后有三种状态： Sucess：成功，容器通过诊断； Failure：失败，容器未通过诊断； Unknown：未知，诊断失败，不会采取任何行动。 三种探针类型 livenessProbe：检测容器是否正在运行。 readinessProbe：检测容器是否准备好为请求提供服务。 startupProbe（1.7+）：检测容器中的应用是否已经启动。 每种类型的探针都有以下几个机制/命令： exec：在容器内部执行命令，如果命令退出代码时返回 0，则诊断成功； grpc：使用远程过程调用，如果响应的状态是 “Serving”，则诊断成功。gRPC 探针是一个 Alpha 特性，需要启用 GPRCContainerProbe 特性时才能使用； httpGet：发送一个 GET 请求，如果响应码大于等于 200 且小于 400，则诊断成功； tcpSocket：对容器的 IP 地址上的指定端口执行 TCP 检查，如果端口打开，则诊断成功。如果远程系统在打开连接后立即将其关闭，这算作健康状态。 每种命令都有几个探针参数： 12345678910# 初始化时间initialDelaySeconds: 5# 检测间隔时间periodSeconds: 4# 默认检测超时时间 1 stimeoutSeconds: 1# 默认失败次数为 3 次，达到 3 次后重启 PodfailureThreshold: 3# 默认成功次数为 1 次，1 次监测成功代表成功successThreshold: 1 举个例子： 举个例子execgRPChttpGettcpSocket123456789101112131415161718192021222324252627apiVersion: v1kind: Podmetadata: name: liveness-exec labels: app: nginxspec: containers: - name: nginx image: nginx:1.19 ports: - containerPort: 80 args: - /bin/sh - -c - sleep 7;nginx -g &quot;daemon off;&quot; #这一步会和初始化同时开始运行，也就是在初始化5s后和7秒之间，会检测出一次失败，7秒后启动后检测正常，所以pod不会重启 imagePuLLPoLicy: IfNotPresent livenessProbe: exec: command: - ls - /var/run/nginx.pid initialDelaySeconds: 5 #初始化时间5 speriodSeconds: 4 # 检测间隔时间4 timeoutSeconds: 1 # 默认检测超时时间为1s failureThreshold: 3 #默认失败次数为3次、达到3次后重启 successThreshoLd: 1 #默认成功次数为1次，1次代表成功参考官网：https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-grpc-liveness-probe123456789101112131415apiVersion: v1kind: Podmetadata: name: etcd-with-grpcspec: containers: - name: etcd image: registry.k8s.io/etcd:3.5.1-0 command: [ &quot;/usr/local/bin/etcd&quot;, &quot;--data-dir&quot;, &quot;/var/lib/etcd&quot;, &quot;--listen-client-urls&quot;, &quot;http://0.0.0.0:2379&quot;, &quot;--advertise-client-urls&quot;, &quot;http://127.0.0.1:2379&quot;, &quot;--log-level&quot;, &quot;debug&quot;] ports: - containerPort: 2379 livenessProbe: grpc: port: 2379 initialDelaySeconds: 101234567891011121314151617181920212223242526apiVersion: v1kind: Podmetadata: name: Liveness-httpget labels: httpget: httpgetspec: containers: - name: nginx image: nginx:1.19 ports: - containerPort: 80 args: - /bin/sh - -c - sleep 7;nginx -g &quot;daemon off;&quot; #这一步会和初始化同时开始运行，也就是在初始化5s后和7秒之间，会检测出一次失败，7秒后启动后检测正常，所以pod不会重启 imagePuLLPoLicy: IfNotPresent livenessProbe: httpGet: # httpget port: 80 #访问的端口 path: /index.htmt #访问的路径 initialDelaySeconds: 5 #初始化时间5 speriodSeconds: 4 # 检测间隔时间4 timeoutSeconds: 1 # 默认检测超时时间为1s failureThreshold: 3 #默认失败次数为3次、达到3次后重启 successThreshoLd: 1 #默认成功次数为1次，1次代表成功12345678910111213141516171819202122232425apiVersion: v1kind: Podmetadata: name: liveness-tcp labels: app: nginxspec: containers: - name: nginx image: nginx:1.19 ports: - containerPort: 80 args: - /bin/sh - -c - sleep 7;nginx -g &quot;daemon off;&quot; # 这一步会和初始化同时开始运行，也就是在初始化5s后和7秒之间，会检测出一次失败，7秒后启动后检测正常，所以pod不会重启 imagePuLLPoLicy: IfNotPresent livenessProbe: tcpSocket: port: 80 initialDelaySeconds: 5 #初始化时间5 speriodSeconds: 4 # 检测间隔时间4 timeoutSeconds: 1 # 默认检测超时时间为1s failureThreshold: 3 #默认失败次数为3次、达到3次后重启 successThreshoLd: 1 #默认成功次数为1次，1次代表成功 资源限制 在 Kubernetes 中对于容器的资源限制主要分为两类：内存资源限制、CPU 资源限制。Kubernetes 可以定义容易运行占用的资源限制，超过最大资源容器会被 kill，并报 OOM Error。 安装 [metrics](https://github.com/kubernetes-sigs/metrics-server)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196apiVersion: v1kind: ServiceAccountmetadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: labels: k8s-app: metrics-server rbac.authorization.k8s.io/aggregate-to-admin: &quot;true&quot; rbac.authorization.k8s.io/aggregate-to-edit: &quot;true&quot; rbac.authorization.k8s.io/aggregate-to-view: &quot;true&quot; name: system:aggregated-metrics-readerrules:- apiGroups: - metrics.k8s.io resources: - pods - nodes verbs: - get - list - watch---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: labels: k8s-app: metrics-server name: system:metrics-serverrules:- apiGroups: - &quot;&quot; resources: - nodes/metrics verbs: - get- apiGroups: - &quot;&quot; resources: - pods - nodes verbs: - get - list - watch---apiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: labels: k8s-app: metrics-server name: metrics-server-auth-reader namespace: kube-systemroleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: extension-apiserver-authentication-readersubjects:- kind: ServiceAccount name: metrics-server namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: labels: k8s-app: metrics-server name: metrics-server:system:auth-delegatorroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:auth-delegatorsubjects:- kind: ServiceAccount name: metrics-server namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: labels: k8s-app: metrics-server name: system:metrics-serverroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:metrics-serversubjects:- kind: ServiceAccount name: metrics-server namespace: kube-system---apiVersion: v1kind: Servicemetadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-systemspec: ports: - name: https port: 443 protocol: TCP targetPort: https selector: k8s-app: metrics-server---apiVersion: apps/v1kind: Deploymentmetadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-systemspec: selector: matchLabels: k8s-app: metrics-server strategy: rollingUpdate: maxUnavailable: 0 template: metadata: labels: k8s-app: metrics-server spec: containers: - args: - --cert-dir=/tmp - --secure-port=4443 - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname - --kubelet-use-node-status-port - --metric-resolution=15s image: registry.k8s.io/metrics-server/metrics-server:v0.6.4 imagePullPolicy: IfNotPresent livenessProbe: failureThreshold: 3 httpGet: path: /livez port: https scheme: HTTPS periodSeconds: 10 name: metrics-server ports: - containerPort: 4443 name: https protocol: TCP readinessProbe: failureThreshold: 3 httpGet: path: /readyz port: https scheme: HTTPS initialDelaySeconds: 20 periodSeconds: 10 resources: requests: cpu: 100m memory: 200Mi securityContext: allowPrivilegeEscalation: false readOnlyRootFilesystem: true runAsNonRoot: true runAsUser: 1000 volumeMounts: - mountPath: /tmp name: tmp-dir nodeSelector: kubernetes.io/os: linux priorityClassName: system-cluster-critical serviceAccountName: metrics-server volumes: - emptyDir: &#123;&#125; name: tmp-dir---apiVersion: apiregistration.k8s.io/v1kind: APIServicemetadata: labels: k8s-app: metrics-server name: v1beta1.metrics.k8s.iospec: group: metrics.k8s.io groupPriorityMinimum: 100 insecureSkipTLSVerify: true service: name: metrics-server namespace: kube-system version: v1beta1 versionPriority: 100 安装之后可以使用 kubectl top pod [pod-name] 命令查看当前占用的系统资源情况。 限制内存 1234567891011121314151617apiVersion: v1kind: Podmetadata: name: liveness-tcp labels: app: nginxspec: containers: - name: nginx image: nginx:1.19 imagePuLLPoLicy: IfNotPresent # 设置该 container 的请求限制最小 100M，最大 200M resources: requests: memory: 100M limits: memory: 200M 12# 查看容器当前内存使用情况kubectl get pod [pod-name] -o yaml 内存请求和限制的目的 通过为集群中运行的容器配置内存请求和限制，可以有效利用集群节点上可用的内存资源。通过将 Pod 的内存请求保持在较低水平，你可以更好地安排 Pod 调度。通过让内存限制大于内存请求，你可以完成两件事： Pod 可以进行一些突发活动，从而更好的利用可用内存。 Pod 在突发活动期间，可使用的内存被限制为合理的数量。 没有指定内存限制 如果你没有为一个容器指定内存限制，则自动遵循以下情况之一： 容器可无限制地使用内存。容器可以使用其所在节点所有的可用内存，进而可能导致该节点调用 OOM Killer。此外，如果发生 OOM KiLL，没有资源限制的容器将被杀掉的可行性更大。 运行的容器所在命名空间有默认的内存限制，那么该容器会被自动分配默认限制。 限制 CPU 1234567891011121314151617apiVersion: v1kind: Podmetadata: name: liveness-tcp labels: app: nginxspec: containers: - name: nginx image: nginx:1.19 imagePuLLPoLicy: IfNotPresent # 设置该 container 的请求限制最小 100M，最大 200M resources: requests: cpu: 10m limits: cpu: 50m CPU 请求和限制的初衷 通过配置你的集群中运行的容器的ICPU请求和限制，你可以有效利用集群上可用的CPU资源。通过将Pod CPU 请求保持在较低水平，可以使 Pod 更有机会被调度。通过使 CPU 限制大于 CPU 请求，你可以完成两件事： Pod 可能会有突发性的活动，它可以利用碰巧可用的 CPU 资源。 Pod 在突发负载期间可以使用的 CPU 资源数量仍被限制为合理的数量。 如果不指定 CPU 限制 如果你没有为容器指定 CPU 限制，则会发生以下情况之一： 容器在可以使用的 CPU 资源上没有上限。因而可以使用所在节点上所有的可用 CPU 资源。 容器在具有默认 CPU 限制的名称空间中运行，系统会自动为容器设置默认限制。 如果你设置了 CPU 限制但未设置 CPU 请求，Kubernetes 会自动为其设置与 CPU 限制相同的 CPU 请求值。类似的，如果容器设置了内存限制值但未设置内存请求值，Kubernetes 也会为其设置与内存限制值相同的内存请求。 Pod 中的 Init 容器 Init 容器是一种特殊容器，在 Pod 内的应用容器启动之前运行。Init 容器可以包括一些应用镜像中不存在的实用工具和安装脚本。每个 Pod 中可以包含多个容器，应用运行在这些容器里面，同时 Pod 也可以有一个或多个先于应用容器启动的 Init 容器。 Init 容器与普通的容器非常像，除了如下两点： 它们总是运行到完成。 每个都必须在下一个启动之前成功完成。 如果 Pod 的 Init 容器失败，kubelet 会不断地重启该 Init 容器直到该容器成功为止。 然而，如果 Pod 对应的 restartPolicy 值为 “Never”，并且 Pod 的 Init 容器失败， 则 Kubernetes 会将整个 Pod 状态设置为失败。 Init 容器不支持 lifecycle、livenessProbe、readinessProbe 和 startupProbe， 因为它们必须在 Pod 就绪之前运行完成。 如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。 每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时， Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行。 Pod 节点 label 作用：根据 label 确定 Pod 运行的节点（yaml 中使用 nodeSelector ）。 123456# 显示所有节点kubectl get nodes# 显示所有的节点及其标签kubectl get nodes --show-labels;# 添加标签kubectl label node [node-name] [key=value] 节点标签调度 Pod 使用 nodeSelector 时如果指定的 label 不存在，k8s 将不会运行 Pod。 节点名称调度 Pod nodeName 节点亲和性和反亲和性调度 Pod 污点和容忍度 Pod 拓扑分布约束 Controller 控制器 一般不单独创建 Pod，而是通过 Controller 创建并管理，Controller 也是通过 label 来关联 Pod 并进行管理。 Deployment 1234567891011121314151617181920212223242526apiVersion: apps/v1# Deployment 类型控制器kind: Deploymentmetadata: name: nginx-deployment # 控制器 label labels: app: nginx-deploymentspec: # 一次创建 3 个副本：即启动 3 个 nginx replicas: 3 # 表明控制器如何查找要管理的 Pod selector: matchLabels: app: nginx template: metadata: # 必须对应 selector: matchLabels: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 deployment 的一些命令和 Pod 类似，把 pod 换为 deployment 即可。这里不再举例。 deployment 伸缩 1234# 查询副本kubectl get rs|replicaset# 扩展 deploymentkubectl scale deployment [deployment-name] --replicas=num deployment 回滚 12345678910111213141516#查看上线状态kubectl rollout status [deployment deployment-name| deployment/deployment-name]# 查看版本历史kubectl rollout history deployment [deployment-name]#查看某个版本的详细信息kubectl rollout history deployment/[deployment-name] --revision=version-num#回到上个版本kubectl rollout undo deployment [deployment-name]#回到指定版本kubectl rollout undo deployment [deployment-name] --to-revision=version-num# 重启kubectl rollout restart deployment [deployment-name]#暂停运行，暂停后，对depLoyment的修改不会立刻生效，恢复后才应用设置kubectl rollout pause deployment [deployment-name]#恢复kubectl rollout resume deployment [deployment-name] StatefulSet StatefulSet 和 Deplotment 差不多，但是可以为 Pod 提供持久存储和持久标识符。 删除或这扩缩 StatefulSet 的时候，不会删除的它关联的数据卷，以此保证数据的安全。 不推荐删除 StatefulSet 的 yml。 DaemonSet Job Service Kubernetes 中 Service 是 将运行在一个或一组 Pod 上的网络应用程序公开为网络服务的方法。 Helm Helm 是一个 Kubernetes 的包管理器。 123456789101112# 联网查找软件包helm search hub [name]# 查找本地包helm search repo [name]# 查看本地启动的列表helm list# 安装自定义 charthelm create [chart-name]# 校验编写的脚本helm lint [chart-name]# 打包helm package path"},{"title":"Nginx的安装与简单使用","path":"/wiki/技术加油站/CloudService/Nginx的安装与简单使用.html","content":"一、下载安装 Nginx 有几个模块，实际项目中经常使用，但在编译安装的时候默认是不安装的，需要加入命令选项。当然，如果刚开始没有安装，后续也是可以再次编译替换的。具体选项配置可以参阅官网文档：http://nginx.org/en/docs/configure.html 123456789101112# 支持 ssl 即 HTTPS--with-http_ssl_module# HTTP2--with-http_v2_module# 修改替换相应的字符串--with-http_sub_module# gunzip 压缩--with-http_gunzip_module# gzip--with-http_gzip_static_module# 提供获得基本状况的信息--with-http_stub_status_module 以上几个模块默认都是不安装的。如果目前已经存在线上运行的 Nginx 服务，并且缺少上面的某些模块，那么再次下载和线上版本一致的 Nginx，然后重新编译（不需要安装），把需要用到的模块编译进去，然后替换源文件（nginx）即可。（如果线上版本较低，顺带想要升级，可以直接编译安装，覆盖原来的，注意 配置备份）。 这里就以更新为主，新安装的比较简单，编译完成后直接安装（make install）。 1234567891011121314151617# 安装依赖包sudo apt install libpcre3 libpcre3-dev zlib1g-dev libssl-dev build-essential -y# 下载新的源文件wget https://nginx.org/download/nginx-1.24.0.tar.gz# 解压后进入解压目录tar -xzvf nginx-1.24.0.tar.gzcd nginx-1.24.0# 配置./configure --prefix=/usr/local/nginx \\--with-http_sub_module \\--with-http_stub_status_module \\--with-http_ssl_module \\--with-http_gunzip_module \\--with-http_gzip_static_module# 编译make 经过以上步骤后，在该目录下（.../xx/nginx-1.24.0）会多出来一个 objs 的目录，该目录下有一个 nginx 文件，这个就是新编译可执行文件。现在有两种选择：备份目前正在使用的 .../sbin/nginx 文件，然后拷贝新生成的 nginx 到该目录下；或者直接替换掉旧版本（最好版本一致时这样做）。 二、命令 123456# 停止./nginx -s stop# 查看配置文件的状态是否可用./nginx -t# 修改配置文件后重新加载配置文件./nginx -s reload 三、配置 Nginx 的 location 块中可以使用两种配置方式。一种是 root，一种是 alias。注意，root 不单单可以在 location 中使用，而 alias 只能在 location 中使用。 123456789...location /share &#123; root /data;&#125;location /test &#123; alias /data/share/;&#125;... 上面的两种配置方式在地址栏访问路径是不同的，但是访问的结果是相同的。 比如上面的配置可以访问：http://localhost:port/share、http://localhost:port/test，展示的效果都是一样的。 那么我们可以发现，alias 后跟的是资源的绝对路径，location 后只是使用 http 访问时的别名。而 root 需要加上 location 后的目录。 另外根据官方文档的示例，root 方式可以不用在路径最后添加 /；alias 则必须添加。 https://nginx.org/en/docs/http/ngx_http_core_module.html#root https://nginx.org/en/docs/http/ngx_http_core_module.html#alias 1. 默认配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 2. 自定义配置 conf/nginx.conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 日志打印 log_format main &#x27;$time_iso8601|$remote_addr|$remote_user|$request_method|$uri|&#x27; &#x27;$status|$request_time|$request_length|$body_bytes_sent|$bytes_sent|&#x27; &#x27;$connection|$http_x_forwarded_for|$upstream_addr|$upstream_status|&#x27; &#x27;$upstream_response_time|$args|$http_referer|$http_user_agent&#x27;; access_log logs/access.log main; # 负载均衡服务器 upstream server_name &#123; # 设置权重，权重越高，使用此服务器的概率越大 # 8080 出现的频率是其它服务器的两倍 server localhost:8080 weight=2; server localhost:8081; server localhost:8082; &#125; server &#123; listen 80; server_name localhost; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location / &#123; # 使用负载均衡服务器，默认策略轮询 proxy_pass http://server_name/; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; # 配置静态资源 location ~ .*\\.(css|gif|ico|jpg|js|png|ttf|woff)$ &#123; expires 24h; # 指定图片存放路径 root D:/image/; proxy_store on; proxy_store_access user:rw group:rw all:rw; # 图片路径 proxy_temp_path D:/image/; proxy_redirect off; proxy_set_header Host 127.0.0.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; cl ient_max_body_size 10m; client_body_buffer_size 1280k; proxy_connect_timeout 900; proxy_send_timeout 900; proxy_read_timeout 900; proxy_buffer_size 40k; proxy_buffers 40 320k; proxy_busy_buffers_size 640k; proxy_temp_file_write_size 640k; if ( !-e $request_filename) &#123; proxy_pass http://127.0.0.1:80; #代理访问地址 &#125; &#125; &#125; # 使用 nginx 映射文件服务器 server &#123; listen 8181; server_name localhost; # 配置跨域 # add_header Access-Control-Allow-Origin *; # add_header Access-Control-Allow-Headers X-Requested-With; # add_header Access-Control-Allow-Methods GET,POST,OPTIONS; # charset koi8-r; # access_log logs/host.access.log main; location /share &#123; # /share 的上级全目录 root /data; # 如果使用 alias，最后一定要加 /，而且只能用于 location 块 # alias /data/share/ # 显示索引序号 autoindex on; # 显示文件的时间 autoindex_localtime on; &#125; &#125;&#125; 若修改配置文件后再次启动报错：[emerg]: bind() to 0.0.0.0:80 failed (80: Address already in use) 执行命令：sudo fuser -k 80/tcp，然后重新启动 ./nginx 四、附 1. 常用的 nginx 全局变量 1234567891011121314151617181920212223$args #请求行中的参数。$content_length #请求头中的Content-length字段。$content_type #请求头中的Content-Type字段。$document_root #当前请求在root指令中指定的值。$host #请求主机头字段，否则为服务器名称。$http_user_agent #客户端agent信息$http_cookie #客户端cookie信息$limit_rate #这个变量可以限制连接速率。$request_body_file #客户端请求主体信息的临时文件名。$request_method #客户端请求的动作，通常为GET或POST。$remote_addr #客户端的IP地址。$remote_port #客户端的端口。$remote_user #已经经过Auth Basic Module验证的用户名。$request_filename #当前请求的文件路径，由root或alias指令与URI请求生成。$query_string #与$args相同。$scheme #HTTP方法（如http，https）。$server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$server_addr #服务器地址，在完成一次系统调用后可以确定这个值。$server_name #服务器名称。$server_port #请求到达服务器的端口号。$request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。$uri #不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。$document_uri #与$uri相同。"},{"title":"ZooKeeper","path":"/wiki/技术加油站/CloudService/ZooKeeper.html","content":"Zookeeper 简称 ZK，是基于 Java 语言编写的开放源码的分布式应用程序协调服务，主要服务于分布式系统：统一配置管理、统一命名服务、分布式锁、集群管理。可以使用 jps 命令查询相关进程。 Dubbo、Spring Cloud 框架使用 ZK 作为注册中心； Hadoop、Hbase组件使用 ZK 作为集群管理者； Redis 可以使用 ZK 实现分布式锁。 1 Zookeeper的结构认识 ZK 的内存结构和 Linux 文件系统非常相似。 ZK中的节点称为 ZNode，节点模型的特点： 每个子目录都被称为一个节点，这个节点是它所在路径的唯一标识。 节点可以有子节点目录，每个子节点都可以存储数据。 节点是有版本的，每个子节点中的数据都可以有多个版本，也就是一个访问路径可以存储多份数据。 节点可以被监控，包括这个目录节点中存储的数据的修改，节点目录的变化等，一旦变化可以通知监听的客户端。 1.1 节点 ZK 节点分类： 持久性节点：PERSISTENT 持久性顺序节点：PERSISTENT_SEQUENTIAL 临时节点：EPHEMERAL 临时顺序节点：EPHEMERAL_SEQUENTIAL 1. 特点 临时/临时顺序节点上不可以包含任何的子节点。 ZK 默认在根路径中有一个 zookeeper 节点，zookeeper 节点下有一个 quota 子节点。 2. 节点监听机制 一个 Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据和目录发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端以便通知他们。节点的监听是一次性的，监听一次就会失效。 12345# 监听路径变化ls /node true# 监听数据变化get /node true 2 ZK的配置文件 12345678910# 集群节点之间的心跳时间tickTime=2000# 初始化集群时集群节点的同步超时时间，10代表 10 个滴答声，20秒initLimit=10# 同步时间限制 5 个滴答声syncLimit=5# 持久化数据存放目录dataDir=/tmp/zookeeper# ZK 服务监听端口号clientPort=2181 3 客户端基本指令 指定配置文件启动：./bin/zkServer.sh start ./conf/zoo.cfg 客户端连接：./bin/zkCli.sh -server localhost:2181 1234567891011121314151617181920212223242526272829303132# 查看路径节点ls /node# 创建一个持久顺序节点：create -s /node jhlz# 创建一个临时数据节点create -e /node jhlz# 创建一个临时顺序节点create -e -s /node jhlz# 查看节点的状态stat /node# 查看节点数据和状态get /node# 设置节点的值set /node xiaoming# 组合 相当于 ls / + stat /ls2 /node# 删除节点，只能删除没有子节点的节点delete /node# 递归删除节点rmr /node# 退出当前会话quit 创建节点时，默认创建的是持久化节点。create /node jhlz，这样就创建了一个 jhlz 的持久化节点 4 ZK伪集群搭建示例 集群的搭建和其它集群的搭建都是一样的，非常简单：创建不同的配置文件，在服务启动时指明需要的配置文件即可。 首先建立三个文件夹： zk1 zk2 zk3 在每一个数据目录中创建一个 myid 文件。并在每一个 myid 文件中添加标号。 1234567mkdir zk1 zk2 zk3touch zk1/myid /zk2/myid zk3/myidecho &quot;1&quot; &gt; zk1/myidecho &quot;2&quot; &gt; zk2/myidecho &quot;3&quot; &gt; zk3/myid 修改各自的配置 123456789101112131415161718192021222324252627282930# 编辑第一个vim zk1/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/tmp/zk1clientPort=3001server.1=localhost:3002:3003server.2=localhost:4002:4003server.3=localhost:5002:5003# 编辑第二个vim zk1/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/tmp/zk1clientPort=4001server.1=localhost:3002:3003server.2=localhost:4002:4003server.3=localhost:5002:5003# 编辑第三个vim zk3/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/tmp/zk1clientPort=5001server.1=localhost:3002:3003server.2=localhost:4002:4003server.3=localhost:5002:5003 其中，server.1 的区分就是上面创建的 myid 文件的编号，ZK 会自动根据 myid 的编号去识别，但是我们在集群配置中需要写明。 3002: 数据同步使用的端口号。 3003： leader 选举使用的端口号。 指定配置文件启动服务 12345./bin/zkServer.sh start zk1/zoo.cfg./bin/zkServer.sh start zk2/zoo.cfg./bin/zkServer.sh start zk3/zoo.cfg"},{"title":"云原生与微服务","path":"/wiki/技术加油站/CloudService/index.html","content":"微服务时代充满着自由的气息，微服务时代充斥着迷茫的选择。 微服务（Microservices）是一种架构风格，它将一个大型的软件应用程序划分为一组小型、自治的服务，每个服务都运行在独立的进程中，并通过轻量级的通信机制（通常是HTTP API）相互协作。每个微服务都专注于一个特定的业务功能，可以独立开发、部署、扩展和更新。 以下是微服务架构的一些关键特点和原则： 服务拆分： 将整个应用程序拆分为小型的、可独立部署的服务单元。 每个服务关注一个明确定义的业务功能，有自己的数据存储、业务逻辑和用户界面。 自治性： 每个微服务都是自治的，即它们可以独立开发、部署和运行。 每个服务有自己的数据库，服务之间的通信通过明确定义的API进行。 分布式架构： 微服务架构是一种分布式系统，各个服务可以部署在不同的服务器上。 服务之间通过网络通信进行协作，通常使用HTTP/REST或消息队列等通信机制。 独立部署： 微服务可以独立部署，不会影响其他服务的正常运行。 这使得团队可以更快地迭代和发布新的功能，降低发布风险。 多语言支持： 不同的微服务可以使用不同的编程语言和技术栈，选择最适合其业务需求的工具。 自动化部署和运维： 微服务架构通常使用容器化技术，如Docker，以简化部署和运维工作。 自动化工具和平台可以帮助管理大量微服务的部署和监控。 弹性和可伸缩性： 微服务架构使得系统更容易实现弹性和可伸缩性。 每个微服务可以独立水平扩展，以满足不同服务的不同负载。 服务发现和治理： 由于服务数量庞大，微服务架构需要一种机制来发现和管理服务。 服务注册和发现、负载均衡、断路器等是微服务治理的关键组件。 微服务架构的引入旨在提高系统的可维护性、可扩展性和灵活性。然而，它也带来了一些挑战，如分布式系统的复杂性、服务之间的通信开销以及一致性和事务的管理等。因此，在采用微服务架构时，需要权衡其优势和挑战，并根据具体的应用场景来选择。"},{"title":"初识 Podman","path":"/wiki/技术加油站/CloudService/初识Podman.html","content":"Podman 和 Docker 一样，也是一个容器化技术的一种实现。它是全开源的。但是它们的底层架构是不同的，Podman 不需要使用 root 用户创建容器，也没有 deamon 进程，所以 Podman 不支持--restart 策略。但是为了迁移方便，Podman 团队采用了和 Docker 类似的命令。 以下内容摘自 官网文档： Podman 是一个无守护进程、开源的 Linux 原生工具，旨在使用开放容器倡议 （OCI） 容器和容器映像轻松查找、运行、构建、共享和部署应用程序。Podman 提供了一个命令行界面 （CLI），任何使用过 Docker 容器引擎的人都很熟悉。大多数用户可以简单地将Docker别名化为Podman（别名docker=podman），没有任何问题。与其他常见的容器引擎（Docker，CRI-O，containerd）类似，Podman依赖于符合OCI的容器运行时（runc，crun，runv等）与操作系统接口并创建正在运行的容器。这使得 Podman 创建的正在运行的容器与任何其他常见容器引擎创建的容器几乎没有区别。 Podman 控制下的容器可以由 root 或非特权用户运行。Podman 使用 libpod 库管理整个容器生态系统，包括 pod、容器、容器镜像和容器卷。Podman 专注于帮助您维护和修改 OCI 容器映像的所有命令和功能，例如拉取和标记。它允许您在生产环境中创建、运行和维护这些容器和容器映像。 一、安装 撰写本文的时候 Podman 已更新到 4.4.0 版本，本文所有涉及 Podman 的命令全部都是在此版本的基础上进行的。 1234567891011121314151617# 1. 安装paru -S podman podman-compose# 2. 查看当前用户名称whoami# 3. 把用户名称加入到 `/etc/subuid、/etc/subgid` 两个文件中usermod --add-subuids 100000-165535 --add-subgids 100000-165535 username# 执行命令并测试podman system migratepodman -v# 使用搜索命令，会发现没有任何结果。这是因为需要配置一下podman search nginx# 编辑配置文件 /etc/containers/registries.conf# 备份文件sudo cp /etc/containers/registries.conf /etc/containers/registries.conf.baksudo vim /etc/containers/registries.conf registries.conf 内所有的内容都是被注释掉的，找到以下内容去掉注释并修改，保存退出。 /etc/containers/registries.conf12345unqualified-search-registries = [&quot;docker.io&quot;][[registry]]prefix = &quot;docker.io&quot;location = &quot;hub-mirror.c.163.com&quot; unqualified-search-registries 可以配置多个源，镜像的搜索会从这些源中去寻找。 registry##prefix、location 是镜像拉取时使用的地址。 现在不推荐中科大源，原因详见：https://mirrors.ustc.edu.cn/help/dockerhub.html 此外也可以使用红帽提供的镜像，这些镜像有文档说明：https://catalog.redhat.com/software/containers/search 举个栗子，用以上配置举例： 123456789# 搜索 unqualified-search-registries 配置的所有源中所有符合条件的镜像# 如果你配置了多个，那么你就会在结果中看到有的镜像带有不同的前缀podman search nginx# 拉取镜像podman pull nginx# 虽然自己写的是上面的命令，但是 Podman 会自动加入配置# 我们配置了 prefix，实际命令是这样：podman pull docker.io/nginx# 如果还配置了 location，就会是这样：podman pull registry.docker-cn.com/nginx 二、命令 命令选项大多和 Docker 一样，如果不习惯可以配置 docker 别名（前提是只安装了 podman）。具体的使用可以参阅官方文档：https://docs.podman.io/en/latest/Commands.html。"},{"title":"GitHub+PicGo搭建图床","path":"/wiki/技术加油站/Git/GitHub+PicGo搭建图床.html","content":"一、PicGo是什么？在本机如何使用？ PicGo 是图片上传到其它存储平台的助手。它支持多种图床：weibo, qiniu, tcyun, upyun, github, aliyun, imgur and SM.MS。 我们在写文章的过程中，免不了要在文章内放置图片，对于自己搭建的博客网站，或者是自己编写 md 文档，那么图片的处理就比较麻烦了，截图、命名、存储等都是问题。 二、本机安装 PicGo 安装完成启动 PicGo 客户端，点击图床设置，选择 Github图床，点击 设为默认图床，然后进行图床的配置： 设定仓库名：username/repo 设定分支名：main 设定Token：GitHub 平台创建的 token 指定存储路径：指定仓库下的指定分支下的文件夹路径。简单理解就是把图片放在仓库的哪个目录下。 设定自定义域名：图片成功上传后返回的链接。 配置完成后就可以在上传区选择需要上传的图片啦。比如打开资源管理器选择图片，或者直接拖动需要上传的图片到上传区域，PicGO 就会把这些图片上传到指定的 Github 仓库的路径下。 三、配置 Github 1. 创建一个存放图片的仓库 2. 建立一个目标分支，默认是 main 3. 创建 Github Token 登录Github，点击头像，依次选择 settings -&gt; Developer settings -&gt; Personal access tokens，选择 Generate new token，进入填写如下信息，填写完毕点击最后的绿色按钮 Generate token 保存。注意：生成的 token 只会显示一次，一定要复制后保存下来。 否则需要重新生成。 上面的步骤都完成之后把相应的信息填写到 PicGo 中，然后就可以使用该软件进行图片上传啦~ 四、VSCode+PicGo插件 浪子经常使用 VsCode 写 markdown 文件，之前不经常在文章里放图片，后来放图片的时候感觉真麻烦。不过幸好，VsCode 里也有 PicGo 的插件供我们使用。单纯在 VsCode 中使用这个插件不需要安装 PicGo 客户端。 1. VsCode安装PicGo插件 打开 VsCode 的扩展商店搜索 picgo，安装图中红框框中插件。 安装完成后使用 Ctrl + Shift + P 快捷键，搜索打开 settings.json 文件，添写以下内容保存，这里面的内容和上面的配置类似。 settings.json12345678910111213141516171819// 如果在本机安装了 PicGo 客户端，第一次启动后会自动生成 json 文件，然后你只需要配置这一项就 OK 啦// &quot;picgo.configPath&quot;: &quot;C:\\\\Users\\\\你的用户名\\\\AppData\\\\Roaming\\\\picgo\\\\data.json&quot;,// 如果本机没有安装 PicGo 客户端，只安装了 PicGo 插件，需要配置以下信息// 当前使用图床 可选：weibo, qiniu, tcyun, upyun, github, aliyun, imgur and SM.MS&quot;picgo.picBed.current&quot;: &quot;github|weibo|qiniu|tcyun|upyun|aliyun|imgur|SM.MS&quot;,&quot;picgo.picBed.uploader&quot;: &quot;github|weibo|qiniu|tcyun|upyun|aliyun|imgur|SM.MS&quot;,// 设定分支&quot;picgo.picBed.github.branch&quot;: &quot;branch&quot;,// 设定仓库&quot;picgo.picBed.github.repo&quot;: &quot;repo&quot;,// token&quot;picgo.picBed.github.token&quot;: &quot;token&quot;,// 自定义返回的链接&quot;picgo.picBed.github.customUrl&quot;: &quot;return-url&quot;,// 上传路径&quot;picgo.picBed.github.path&quot;: &quot;path&quot;, 2. 在VsCode中使用快捷键 OS 从剪切板上传 从资源管理器上传图像（打开文件夹选择上传） 从输入框上传图像 Windows/Unix Ctrl + Alt + U Ctrl + Alt + E Ctrl + Alt + O OsX Cmd + Opt + U Cmd + Opt + E Cmd + Opt + O"},{"title":"Git 入门","path":"/wiki/技术加油站/Git/Git入门.html","content":"Git官方文档https://git-scm.com/book/zh/v2 Git简单知识 工作目录（Working Directory）： 这是您在计算机文件系统中实际编辑和修改代码的地方。在工作目录中，您可以对代码进行更改、新增文件或删除文件，但这些变更并不会立即被Git跟踪。 暂存区（Staging Area）：也称为“索引（Index）”，是介于工作目录和版本库之间的中间区域。当您修改了工作目录中的文件后，您可以使用 git add 命令将这些更改添加到暂存区。暂存区中存储了您要在下一次提交中包含的更改快照。 版本库（Repository）： 也称为“Git仓库”，它是保存所有项目历史记录的地方。版本库包含了您提交的快照，以及用于跟踪这些快照如何相互关联的元数据。每次使用git commit命令提交更改时，会在版本库中创建一个新的提交对象。 除了上面的常用词汇外，可能您还听过远程库、上游仓库，其中远程库泛指代码托管平台：Github、Gitee 等代码托管平台，上游仓库特指 fork 的仓库。 常用命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 将当前目录中所有文件文件改动添加到git暂存区，也可以一次提交多个指定文件，使用空格分开$ git add -A# 提交到版本库并备注提交信息$ git commit -m &quot;my first commit&quot;# 上面两条命令可以合并成一条$ git commit -am &#x27;commit msg&#x27;# 如果第一次提交（commit但未push）的内容写的不好或者还有新的相关文件未提交，可以使用下面的命令覆盖之前一次的 commit$ git commit --amend -m &quot;override first commit&quot;# 推送到远程仓库,如果本地和远程的分支名称相同，只写一个分支名称即可# 第一个 master 是本地分支，后面的一个是远程分支$ git push -u origin [local-branch]:[remote-branch]# 移除文件# 从暂存区移除文件，会把工作区相应文件一并删除，回收站无法还原。如果该文件没有提交，则无法删除，可以使用 -f 选项强制删除。$ git rm [file]# 只删除暂存区文件，保留工作区文件；如果不加 --cached，那么暂存区和本地的文件都会被删除$ git rm --cached [file]# 提交历史$ git log# 图形化显示$ git log --graph # 单行显示、短格式、长格式 oneline，short，full$ git log --pretty=oneline/short/full# 撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到指定版本$ git reset --hard 版本ID# 回退到某个版本，但工作目录和暂存区不会受到影响$ git reset --soft 版本库ID# 切换分支$ git checkout [branch] / git switch [branch]# 删除本地分支$ git branch -d [branch]# 查看本地所有分支$ git branch -a# 查看远程分支$ git branch -r# 查看本地与远程分支的一映射关系$ git branch -vv# 重命名本地分支$ git branch -m [old-branch] [new-branch]# 删除远程分支 --delete 简写为 -d$ git push origin -d branch_name# 将本地分支推送到远程分支并建立映射，如果远程不存在将自动创建$ git push -u origin branch_name# 克隆远程库到本地$ git clone https://github.com/user/repo.git# 克隆指定的分支$ git clone -b 分支名称 仓库地址# 关联远程仓库$ git remote add origin https://github.com/user/repo.git# 取消远程关联$ git remote remove origin# 重置远程关联的仓库$ git remote set-url origin [repo-url]# 关联上游仓库$ git remote add upstream 仓库地址# 取消关联上游仓库$ git remote remove upstream# 更新上游仓库$ git pull upstream 其它 入门的时候可能会遇见一些错误，这里记一下。 合并不相关的历史 不直接 clone 仓库，直接在本地创建新的 git 目录，在此目录中添加新的文件，然后再关联远程存在的仓库。在此前提下，如果远程仓库中 已经存在文件，直接 pull 的时候会报错：拒绝合并不相关的历史。 1fatal: refusing to merge unrelated histories 这时我们可以使用 --allow-unrelated-histories 选项强制合并。 1git pull origin [remote-branch] --allow-unrelated-histories 22 端口被占用 如果你配置了 C:\\Users\\youruser\\.ssh\\config 文件，一般是如下配置： C:\\Users\\youruser\\.ssh\\config12345Host github.com User git Hostname github.com Port 22 IdentityFile ~/.ssh/your_private_key 但是突然有一天，浪子本地（在老家）使用 SSH 协议的 Git 仓库就都推不上去了（还包括 pull、clone 等），使用的时候显示以下错误： 123456$ git pullssh: connect to host github.com port 22: Connection refusedfatal: Could not read from remote repository.​Please make sure you have the correct access rightsand the repository exists. 使用代理时不对 Git 进行设置也会报这个错。 这是 GitHub 为了应对网络限制，默认的 SSH 端口 22 可能会被一些机构或地区的防火墙封锁。因此，GitHub 提供了通过 HTTPS 端口 443 访问 Git 仓库的替代方案，这个端口通常用于 HTTPS 协议，大多数网络环境不会对它进行限制。 因此我们可以在 SSH 配置中，将端口设置为 443，实际上是让 SSH 连接通过 HTTPS 端口与 GitHub 的服务器建立连接。这样即使在默认的 22 端口被阻塞的情况下，您依然可以通过 443 端口进行正常的 Git 操作。但是 hostname 需要 修改 一下。 C:\\Users\\youruser\\.ssh\\config12345Host github.com User git Hostname ssh.github.com Port 443 IdentityFile ~/.ssh/your_private_key 这样配置之后可以 ssh -T git@github.com 测试一下，如果有输入的话输入 yes 即可。 如果使用了 Watt Toolkit 加速工具(SSH 默认的 22 端口连接会被拒绝，应该是该工具做了修改)，也可以使用上面的配置，或者形如下面的配置，都是相同的： 123456789Host github.com# 指定 SSH 使用 443 端口Port 443# HostName 是代码托管平台的域名，例如：code.aliyun.com, github.com, gitee.come 等HostName ssh.github.com# 设置用户身份认证方式，这里当然使用 公/私钥 的方式PreferredAuthentications publickey# 指定公钥对应的 私钥 路径IdentityFile ~/.ssh/github_id_rsa 如果还是不行，就尝试一下网络上的普遍方式： HTTP/HTTPS 代理设置 将 &lt;proxy-url&gt; 替换为您的代理服务器地址及端口 12git config --global http.proxy http://&lt;proxy-user&gt;:&lt;proxy-password&gt;@&lt;proxy-url&gt;git config --global https.proxy https://&lt;proxy-user&gt;:&lt;proxy-password&gt;@&lt;proxy-url&gt; 如果不需要身份验证，则直接使用代理服务器地址： 12git config --global http.proxy http://&lt;proxy-url&gt;:&lt;proxy-port&gt;git config --global https.proxy https://&lt;proxy-url&gt;:&lt;proxy-port&gt; 取消代理： 12git config --global --unset http.proxygit config --global --unset https.proxy SSH 代理设置 对于 SSH，Git 不直接支持 HTTP(S) 代理，但可以通过系统级的 SOCKS 代理转发。假设您有一个 SOCKS 代理运行在本地 1080 端口，可以在终端中启动 SSH 的动态端口转发： 1234ssh -D 1080 &lt;your-socks-proxy-server&gt;# 设置环境变量 GIT_SSH_COMMAND 来启用 socks 代理转发：git config --global core.sshCommand &#x27;ssh -o ProxyCommand=&quot;nc -X 5 -x localhost:1080 %h %p&quot;&#x27; 1080 是 SOCKS 服务的默认端口。 Windows 系统中没有 nc 命令，可以去 Nmap 官网下载适用于 Windows 的版本安装。然后使用以下命令设置： 1git config --global core.sshCommand &#x27;ssh -o ProxyCommand=&quot;ncat --proxy-type socks5 --proxy localhost:1080 %h %p&quot;&#x27; 另外，Windows 系统下也可以尝试使用 PuTTY 的 plink.exe 工具代替 ssh 实现类似功能： 1git config --global core.sshCommand &#x27;&quot;C:/Program Files (x86)/PuTTY/plink.exe&quot; -agent -proxycmd &quot;ncat --proxy-type socks5 --proxy localhost:1080 %host %port&quot;&#x27; plink 的路径需要修改为少侠本地的路径"},{"title":"Git 进阶","path":"/wiki/技术加油站/Git/Git进阶.html","content":"一、 git submodule git submodule 是一个很好的多项目使用共同类库的工具，它允许类库项目做为 repo，子项目做为一个单独的 git 项目存在父项目中。 子项目可以有自己的独立的commit，push，pull。而父项目以 Submodule 的形式包含子项目，父项目中会的提交信息包含 Submodule 的信息， 1git submodule add [repo-url] [repo-path] 如果是 clone 一个含有 submodule 的仓库，直接 clone 后，子模块将是一个空的文件夹（需要使用命令初始化），当然也支持直接 clone 子模块： 12345678# 直接 clone 仓库以及子仓库git clone --recurse-submodules [repo-url]# 先 clone 仓库，再初始化子模块git clone [repo-url] [repo-path]cd [repo-path]# init 和 update 也可以使用一个命令git submodule update --init --recursive 1. 删除 submodule 123456cd [repo]git submodule deinit [submodule-path]# 有需要的话可以使用 --force 移除git rm -r [submodule-path]git commit -m &quot;delete submodule&quot;git push 之后需要手动删除 .git/modules/ 路径下的子项目文件夹。 2. 更新 submodule 打开仓库下的 .gitmodules 文件，修改对应的 url 地址并保存； 使用命令进行 .git/config 文件的更新； 1git submodule sync 此时，submodule 的信息已经更新，可以删除旧的子模块再使用 git submodule update --init --recursive 进行子模块初始化。 二、 git stash git stash 命令将当前未提交的修改(即，工作区的修改和暂存区的修改)先暂时储藏起来，这样当前的工作区就干净了。然后可以直接切换到其它分支进行修改。修改完成后重新切换到当前分支下通过 git stash pop 命令将之前储藏的修改取出来，继续进行新功能的开发工作。 1234567# 贮藏当前的工作区文件的修改git stash# 切换其它分支进行开发，开发完成后再切换到当前分支# 取出最近一次的贮藏文件git stash pop 上面的只是简单的使用，此选项是支持多次使用的，并且可以查看列表。 123456789101112131415161718# 第一次修改文件# 藏储文件时附加消息git stash save [message]# 第二次修改文件# 藏储文件时附加消息git stash save [message]# 查看列表git stash list# 取出最近一次的文件git stash pop# 取出指定index的储藏的修改到工作区中git stash apply stash@&#123;index&#125;# 将指定index的储藏从储藏记录列表中删除git stash drop stash@&#123;index&#125;"},{"title":"Git","path":"/wiki/技术加油站/Git/index.html","content":"在三、四、五、六线城市以及像浪子所在的偏远小山村中想要直接使用浏览器访问 GitHub 是有问题的，输入网址后按下回车键，这个页面都不带刷新的，会直接出现 “无法访问该网站” 的错误。解决办法之一就是修改 hosts 文件。 hosts 文件不同的操作系统位置不同，如果是 window 系统，他在 C:\\Windows\\System32\\drivers\\etc 目录下；如果是 Linux 系统，则在 /etc/hosts。这里推荐火绒，修改 hosts 文件超级方便。注意先对 hosts 文件备份，修改错误后可以还原。 访问 IPAddress.com，输入 github.com 回车查询。将获取到的 IP 与 github.com 对应写入到 hosts 文件中，例如： 1140.82.113.4 github.com Git 下载 Git 的官网下载比较慢，可以去 淘宝镜像站 选择合适的版本进行下载。 配置基本信息 可选配置，新手不推荐123456789101112# git status 显示中文$ git config --global core.quotepath false# 图形界面编码$ git config --global gui.encoding utf-8# 提交信息编码$ git config --global i18n.commit.encoding utf-8# 输出 log 编码$ git config --global i18n.logoutputencoding utf-8$ set LESSHARESET=utf-8# 关闭 http 的 SSL 验证(不推荐 --global 选项)，哪个仓库需要在当前的 git 仓库目录下执行即可git config http.sslverify false 12345678# 配置个人信息，方便远程托管平台统计个人的贡献$ git config --global user.name &quot;个人名称或昵称&quot;$ git config --global user.email &quot;邮箱&quot;# 列出所有配置信息：$ git config --list / git config -l# 取消某一项全局配置$ git config --global --unset user.name 检入：提交，检出：下载 http.sslverify：通过 HTTPS 访问 Git 远程仓库时，如果服务器上的 SSL 证书未经过第三方机构认证，Git就会报错。未知的没有签署过的证书意味着可能存在很大的风险。解决办法就是通过下面的命令将 git 中的 sslverify 关掉； git config http.sslverify false 在 Git 执行配置的时候有一些选项： --local 仅指定当前本地 git 仓库 --global 指定所有当前用户的 git 仓库 --system 指定当前系统的所有 git 仓库（很少使用） 生成多个 SSH 1. 生成Github用的SSH-Key 1234# Linux Mac$ ssh-keygen -t ed25519 -C &#x27;xxx@xx.com&#x27; -f ~/.ssh/github_id# Window$ ssh-keygen -t ed25519 -C &#x27;xxx@xx.com&#x27; -f C:/Users/用户名/.ssh/github_id 2. 生成gitee使用的SSH-Key 1234# Linux Mac$ ssh-keygen -t ed25519 -C &#x27;xxx@xx.com&#x27; -f ~/.ssh/gitee_id# Window$ ssh-keygen -t ed25519 -C &#x27;xxx@xx.com&#x27; -f C:/Users/用户名/.ssh/gitee_id 2022-08-22 修改为使用 ed25519 算法生成。 ssh-keygen 支持的部分选项说明： 选项 说明 -b 该选项指定密钥的位数。管理 SSH 用例的算法可能要求使用特定的密钥长度。一般来说，RSA 密钥使用 2048 位就足够了。 -t 指定要创建的 key 的类型，常见的有 RSA、DSA、ECDSA 等 -f 指定存储创建密钥的文件名。 -C 描述密钥的作用/说明 3. 配置 config config 中的配置说明： 1234567Host [git.domain.com] HostName xxx.com User [user] Port [number] PreferredAuthentications publickey PasswordAuthentication no IdentityFile ~/.ssh/[name_of_PRIVATE_key_file] 空行和以“#”开头的行是注释。 每行都以关键字开头，后跟参数。 配置选项可以用空格或可选空格分隔，并且正好是一个 =。 参数可以用双引号 &quot; 括起来，以指定包含空格的参数。 SSH 其它可选参数配置详见：https://www.ssh.com/academy/ssh/config SSH 配置按照以下顺序读取文件： 从命令行指定的选项。 ~/.ssh/config 中定义的选项(用户配置)。 /etc/ssh/ssh_config 中定义的选项(全局配置)。 .ssh/config123456789101112131415161718192021# github1# Host 可以自己定义，在此文件中必须唯一，之后在 down 源码时需要使用这个自定义的 hostHost github.com-repo1 # HostName 是代码托管平台的域名，例如：code.aliyun.com, github.com, gitee.com 等 HostName github.com # 设认证方式：公钥 PreferredAuthentications publickey # 指定公钥对应的私钥路径 IdentityFile ~/.ssh/github1_id# github2Host github.com-repo2 HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github2_id# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitee_id 如果同一个平台配置了多个不同账号的SSH密钥，那么在进行 clone、remote 等操作时，地址需要做一些改变，否则会找不到而报错。在克隆时 git@github.com:user/repo.git 需要替换为对应的 Host 内容。 例如 clone github2 账户的某个仓库： 1git clone git@github.com-repo2.com:user/repo.git 4. 测试是否配置成功 1234# 使用 ssh -T 进行测试，成功的话会打印 Hi，username……$ ssh -T git@gitee.com$ ssh -T git@github.com$ ssh -T git@github.com-repo1.com 5. Windows 下 Git-Bash 的一些配置 Windows 中的 Git-Bash 如果想要用的舒服，还是需要额外的配置，这里补充两个配置。 5.1 tree Win 中的 tree 命令功能有限，远远达不到需求，即便是使用 git bash（默认是没有的，打开此命令无效），也是需要安装的。 下载tree的二进制文件 后解压，把 bin 目录下的 tree.exe 文件复制到 Git 安装目录 xxx\\Git\\usr\\bin\\ 下即可。 5.2 git-bash 编码修改为 utf-8、设置别名 修改 Git 安装目录下的 \\xxx\\Git\\etc\\bash.bashrc 文件，在最后加入下面的内容，保存退出，重启 git-bash 即可。 D:\\xxx\\Git\\etc\\bash.bashrc123456# 设置别名命令alias ll=&quot;ls -al&quot;# git-bash 终端使用 utf-8 编码export LANG=&quot;zh_CN.UTF-8&quot;export LC_ALL=&quot;zh_CN.UTF-8&quot;"},{"title":"规范 Git 提交信息","path":"/wiki/技术加油站/Git/规范Git提交信息.html","content":"Git 提交信息规范化有助于查错（甩锅），这样团队合作的时候，如果出问题可以先看 git log。但是如果提交的信息不明确那就……所以我们可以使用工具辅助在提交的时候必须填写相关内容。 一、commitizen commitizen：基于 Node.js 的 git commit 命令行工具，辅助生成标准化规范化的 commit message。 cz-git、git-cz、cz-customizable、cz-conventional-changelog 等是 commitizen 的适配器：提交时选择的交互式页面，依赖于 commitizen 工作。 你可以把上面的适配器全部安装，然后一个一个体验一遍，找到自己喜欢的使用。使用哪个适配器在 package.json 中配置即可。 本文选用 cz-git 进行安装。Github 地址： 二、安装 1. 本地安装cz-git 12npm install -g commitizennpm install -D cz-git package.json12345678&#123; ... &quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;./node_module/cz-git|git-cz|cz-customizable|cz-conventional-changelog&quot; &#125; &#125;&#125; 2. 全局安装cz-git 1npm install -g commitizen cz-git package.json12345678&#123; ... &quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;cz-git|git-cz|cz-customizable|cz-conventional-changelog&quot; &#125; &#125;&#125; 3. 使用 1cz 多人合作避免 cz-git 版本不一致问题可以选用本地安装，使团队成员使用同一个版本，个人可以直接使用全局安装。 三、czg czg 的安装、使用非常方便，它也可以进行自定义配置，但是省去了很多的麻烦，推荐使用，具体内容可以查看 官方文档。 无需前置配置，无需适配器，没有额外的步骤，你可以使用 npx | npm 脚本 | 全局下载... 在你的任何项目中快速启动。 可定制化: 内部包含 cz-git 的核心，继承了 cz-git 的所有特性，具有相同的行为，配置加载… 你可以根据自己的需要配置的 CLI 的行为。 1234# 全局安装npm i -g czg# 特性以及帮助文档czg --help"},{"title":"Android 开发的小知识","path":"/wiki/编程后花园/Android/index.html","content":"首先 Android 开发中文版的文档还是很不错的，可以当作基础资料阅读了解： Android 开发者指南https://developer.android.google.cn/docs?hl=zh-cn Android Studio Android 开发还是使用 AS 比较多，关于 Android Studio 的版本说明，可以查看：https://developer.android.google.cn/studio/releases?hl=zh-cn。本文使用的是 Giraffe 版（2022.3.1），使用 JetBrain Tools 安装的，最新版目前就是这个。IDE 的版本不是那么重要，当然越新的版本支持的特性也越新，布局也会进化，可设置项/定制化也会较多。 关于安装使用时候的种种问题，请自行查阅解决方法。 关于创建项目使用的模板 在 Giraffe 版本中，有 Empty Activity 和 Empty Views Activity，Empty Activity 是新推出的一种组合式的模板，又叫做 Jetpack Compose，只支持 Kotlin 语言。 Empty Views Activity 则是旧的模板，支持 Java 和 Kotlin 语言。 模板的名称在不同的版本可能不一样；如果少侠使用的是较旧的版本，那么可能就看不到 Empty Activity 模板选项。 关于 Android SDK 版本选择 不同的 SDK 版本对应不同的 API 级别，可以参考官网说明。创建项目时可以选择支持的最低 Android 版本，即 Mininum SDK。 Android 开发基础 https://developer.android.google.cn/training/basics/intents/result?hl=zh-cn JetPack 库：https://developer.android.google.cn/jetpack/androidx/explorer?hl=zh-cn Jerpack Compose 教程：https://jetpackcompose.cn/docs/tutorial/ 颜色值由十六进制来表示红、绿、蓝（RGB）。 每个颜色的最低值为 0(十六进制为 00)，最高值为 255(十六进制为FF)。十六进制值的写法为 # 号后跟三个或六个十六进制字符。三位数表示法为：#RGB，转换为6位数表示为：#RRGGBB。 除此之外，你可能还见过 0x 开头的，这代表是一个十六进制的数值，这样的颜色表示形式常用在 Android 代码中。除去 0x 外，前两位代表透明度，使用 16 进制数字表示，范围是 00 ~ ff，后面 6 位为 RGB 数值。 举个例子以 0xffffcc66 为例，0x 表示是一个一般的 16 进制的数字。前两位，即这里的 ff 表示不透明，ffcc66 为颜色值。使用 #RRGGBB 格式就是 #ffcc66。透明度的表示范围为：00 ~ ff（16 进制），代表从 0 阶到 255 阶。50% 透明度就是 0x7fffcc66，7f 转为 10 进制就是 127。 Jetpack Compose 常用组件 既然提倡组合式开发，那么组件是必不可少的，有前端基础，比如 Vue3 ，那么这块很容易理解。 Compose 提供了三种布局组件， Row、Column、Box Row/LazyRow：行布局，LazyRow 会根据需要动态加载和回收子项 Column/LazyColumn：列布局，LazyColumn 会根据需要动态加载和回收子项 Text：文本，仅支持字符串类型 Image：图片 每种组件有对应的属性值可以调整 UI 的样式，此处不再列举。 Spacer：参数为 modifier，设置组件间隔 Modifier 传统开发中，我们使用 XML 文件描述组件的样式，在 Compose 中，我们可以使用 Modifier 控制。通过传入自定义的 Modifier 修改组件的样式。 Modifier 负责微调上面各种组件的样式。有以下参数 width：宽度 height：长度 size：大小 clip：形状 border：边框 clickable：点击事件 background：背景色"},{"title":"ElasticSearch + Kibana","path":"/wiki/编程后花园/Database/ElasticSearch.html","content":"ES 简单如个门，一般的业务用不上 ES。先了解一下简单的操作。 ElasticSearch分布式搜索引擎的认识 安装配置 1. ES 插曲：ES启动可能出现的问题 2. Kibana ES基本使用 1. 核心概念 2. 索引操作 3. 映射操作 4. 文档操作 高级查询 1. 关键字查询&lt;term&gt; 2. 范围查询&lt;range&gt; 3. 前缀查询&lt;prefix&gt; 4. 通配符查询&lt;wildcard&gt; 5. 多id查询&lt;ids&gt; 6. 模糊查询&lt;fuzzy&gt; 7. 布尔查询&lt;bool&gt; 8. 多字段查询&lt;multi_match&gt; 9. 默认字段分词查询&lt;query_string&gt; 10. 高亮查询&lt;highlight&gt; 11. 返回指定条数&lt;size&gt; 12. 分页查询&lt;form&gt; 13. 排序&lt;sort&gt; 14. 返回指定字段&lt;_source&gt; 分词器 1. ES 内置分词器 2. 中文分词器 3. 扩展词、停用词配置 4. 过滤查询 SpringBoot整合ES开发 1. ElasticsearchOperations 相关注解 2. RestHighLevelClient ES 集群搭建 Head插件查看ES状态 ElasticSearch分布式搜索引擎的认识 ES中的默认使用的是标准分词器(StandardAnalyzer)：中文使用单字分词；英文使用单词分词。 ES中只有 text 类型是分词的，剩下的 keyword、integer、date 等类型都是不分词的。 版本异同： es5 一个索引可以创建多个类型，在es6中仍可以使用,但是已经不推荐。 es6 之后一个索引只对应一个类型。 es7 的默认分片(即备份)从之前的5调到了1,如果想用原来的可以自己设置； es7 使用jdk11+，已经内置。不过可能会出现使用本地的jdk的情况，如果本地jdk版本低于11，需要配置。 编辑环境变量：vim /etc/profile，添加变量 export ES_JAVA_HOME=指定ES安装目录中的jdk，然后 source /etc/profile 类型已经在新版本中删除，7之后的版本不在有类型。 安装配置 注意，kibana 必须和 ES 同版本。这里以安装的 7.14 版本为例，安装方式都是解压 .tar.gz 包的方式，docker 方式安装比较简单。 ES 默认 web 端口：9200；tcp端口：9300(集群通信)；kibana默认端口：5601 启动 Kibana 之前确保 ES 服务正常启动。 1. ES ES 不能以 root 用户启动，否则会报运行时异常，请使用普通用户启动 ES 服务；首先关闭防火墙。之后修改安装目录下的 config 文件夹内的 elasticsearch.yml 文件,修改以下内容： 1234# 开启远程连接network.host: 0.0.0.0# 使用一个节点初始化集群cluster.initial_master_nodes: [&quot;node-1&quot;] 设置完成以后可以启动服务；进入安装的 bin 目录，两个命令二选一，如果是直接启动的，操作时可以再打开一个会话窗口。 1234# 直接启动./elasticsearch# 后台启动 以守护进程启动./elasticsearch -d 插曲：ES启动可能出现的问题 另外，一般在启动会出现默认配置较小的错误，我们需要更改系统文件。启动失败时 es 服务会在终端给出建议的大小，我们去修改即可： 以 root 用户修改文件 /etc/security/limits.conf ，在最后加入以下内容（CentOS系统需要。其它的系统可跳过） 1234* soft\tnofile 65536* hard\tnofile 65536* soft\tnproc 4096* hard\tnproc 4096 编辑文件 sudo vim /etc/sysctl.conf，如果没有该文件可以手动创建，加入内容：vm.max_map_count=262144。然后使用 sysctl -p 使其生效并查看输出内容是否和自己设置的一样。 2. Kibana 同样是修改 kibana 安装目录下的 config/kibana.yml 文件，修改以下内容： 1234# 开启远程连接server.host: 0.0.0.0# 监控 ES 的地址信息elasticsearch.hosts: [es的ip地址:端口号] ES基本使用 1. 核心概念 索引（Index）：一个索引就是一个拥有几分相似特征的文档的集合（类似MySQL的库的概念），ES索引的名称必须是小写。 映射（Mapping）：映射是定义一个文档和它所包含的字段如何被存储和索引的过程。可以简单认为映射就是常规数据库的字段信息。在默认配置下，ES可以根据插入的数据自动地创建mapping，也可以手动创建mapping。mapping中主要包括字段名、字段类型等。 文档（Document）：文档是索引中存储的一条条数据。一条文档是一个可被索引的最小单元。ES的文档采用了轻量级的JSON格式数据来表示。 2. 索引操作 123456// 查看es中的索引GET /_cat/indices?v// 创建索引PUT /index_name// 删除索引DELETE /index_name 谨慎使用 delete /* 的操作，删除掉会导致服务无法正常访问，需要重启服务。 查看索引有 health 标题，包含三种属性：黄色代表可用，但是有危险；绿色代表健康，可用；红色代表索引不可用。 索引没有修改操作。 3. 映射操作 一般都是在创建索引的时候创建映射，脱离了索引，映射也就没有意义了。创建映射时不需要指定类型的长度。 12345678910111213141516171819202122232425262728293031323334// 创建映射，一般在创建索引时手动创建映射PUT /index_name &#123; // 指定分片信息，可以不写，使用默认 &quot;settings&quot;:&#123; // 分片为1 &quot;number_of_shards&quot;: 1, // 副本为0 &quot;number_of_replicas&quot;: 0 &#125;, &quot;mappings&quot;:&#123; // 默认字段，映射属性信息必须写在这里面 &quot;properties&quot;:&#123; // 属性名称及其类型 &quot;id&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;price&quot;: &#123; &quot;type&quot;: &quot;double&quot; &#125;, &quot;created_at&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;, &quot;desc&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &#125; &#125;,&#125;// 查看映射信息GET /index_name/_mapping 映射信息不能删除和修改。 4. 文档操作 文档操作，插入一条文档 put /索引/类型/id（指定Id用put，让系统自动创建用post） 1234567891011121314151617181920212223242526272829303132333435// 添加文档 手动指定 idPOST /index_name/_doc/1&#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;风中捉刀&quot;, &quot;price&quot;: 0.5, &quot;created_at&quot;: &quot;2021-12-12&quot;, &quot;description&quot;: &quot;天元轮魁&quot;&#125;// 添加文档 自动创建文档 id：取UUID的一部分POST /index_name/_doc/&#123; &quot;title&quot;: &quot;无情葬月&quot;, &quot;price&quot;: 0.5, &quot;created_at&quot;: &quot;2021-10-12&quot;, &quot;description&quot;: &quot;血不染&quot;&#125;// 文档查询 基于 id 查询GET /index_name/_doc/document_id// 删除文档 基于 id 删除DELETE /index_name/_doc/document_id// 更新文档 先删除再添加，不保留其它数据PUT /index_name/_doc/document_id&#123; &quot;filed_name&quot;: &quot;修改值&quot;&#125;// 更新文档 保留原始内容PUT /index_name/_doc/document_id/_update&#123; // doc为默认字段，必填 &quot;doc&quot;: &#123; &quot;filed_name&quot;: &quot;target_value&quot; &#125;&#125; es7 在添加文档时必须在索引名称后面加上 _doc， 批量操作:_bulk(批量操作)添加、修改、删除（弱化事务甚至没有事务） 12345678910111213141516171819202122232425262728POST /index_name/_doc/_bulk&#123; // 手动添加id &quot;index&quot;: &#123;&quot;_id&quot;: 2&#125;&#125;&#123; &quot;id&quot;: 2, &quot;title&quot;: &quot;风中捉刀&quot;, &quot;price&quot;: 0.5, &quot;created_at&quot;: &quot;2021-12-12&quot;, &quot;description&quot;: &quot;天元轮魁&quot;&#125;&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 3&#125;&#125;&#123; &quot;id&quot;: 3, &quot;title&quot;: &quot;玲珑雪霏&quot;, &quot;price&quot;: 0.5, &quot;created_at&quot;: &quot;2021-12-12&quot;, &quot;description&quot;: &quot;天元轮魁&quot;&#125;// 文档批量操作 添加 更新 删除POST /index_name/_doc/_bulk&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 4&#125;&#125; &#123;&quot;id&quot;: 4,&quot;title&quot;: &quot;风中捉刀&quot;,&quot;price&quot;: 0.5,&quot;created_at&quot;:&quot;2021-12-12&quot;,&quot;description&quot;: &quot;天元轮魁&quot;&#125;&#123;&quot;update&quot;: &#123;&quot;_id&quot;: 3&#125;&#125; &#123;&quot;doc&quot;: &#123;&quot;title&quot;: &quot;荻花题叶&quot;&#125;&#125;&#123;&quot;delete&quot;: &#123;&quot;_id&quot;: 2&#125;&#125; 如果添加报错，那么信息需要放到同一行。 高级查询 ES官方提供两种检索方式，queryString(查询参数),queryDSl(特定领域查询);官方更推荐使用第二种，简洁强大。 Query DSL是利于Restful API传递JSON格式的请求体数据与ES进行交互。 1. 关键字查询&lt;term&gt; 1234567891011121314151617181920212223242526272829303132333435// 查询所有 match_all,_doc可以不写，这样在Kibana中会有语法提示GET /index_name/_doc/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125;// 关键词查询 term// keyword 类型需要输入全部内容搜索// text 类型需要输入单个词/字搜索GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; // 搜索 description 关键词 &quot;description&quot;:&#123; // 关键词包含的值 &quot;value&quot;:&quot;天元&quot; &#125; &#125; &#125;&#125;// 查询 keyword 类型，全部输入GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;title&quot;:&#123; &quot;value&quot;:&quot;风中捉刀&quot; &#125; &#125; &#125;&#125; 由于ES默认使用的是标准分词器：英文单词分词，中文单字分词。所以description 只能输入单字搜索。 keyword 类型不分词，所以必须输入全部内容才能精准查询。 ES 中，除了 text 类型之外的其它类型都不分词。 对于中文分词器，我们一般会使用其它的分词器。 2. 范围查询&lt;range&gt; 123456789101112GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;range&quot;:&#123; // 根据price查询范围在 0=&lt;price&lt;=5 的数据 &quot;price&quot;: &#123; &quot;gte&quot;:0, &quot;lte&quot;:5 &#125; &#125; &#125;&#125; 3. 前缀查询&lt;prefix&gt; 12345678910GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;prefix&quot;:&#123; &quot;title&quot;: &#123; &quot;value&quot;:&quot;&quot; &#125; &#125; &#125;&#125; 4. 通配符查询&lt;wildcard&gt; ?：匹配一个 *：匹配多个 12345678910GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;wildcard&quot;:&#123; &quot;description&quot;: &#123; &quot;value&quot;:&quot;go*&quot; &#125; &#125; &#125;&#125; 5. 多id查询&lt;ids&gt; 123456789GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;ids&quot;:&#123; // 多个文档id &quot;values&quot;: [1, 2, 4] &#125; &#125;&#125; 6. 模糊查询&lt;fuzzy&gt; 最多允许 0-2 次模糊(至多模糊匹配 0 ~ 2 个字符) 1234567891011GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;fuzzy&quot;:&#123; // 也可以搜索到 风中捉刀 &quot;description&quot;: &quot;风中捉枪&quot; // 搜索不到 风中捉刀 // &quot;description&quot;: &quot;风中捉西瓜&quot; &#125; &#125;&#125; 搜索关键词小于等于2，不允许模糊。 搜索关键词长度为3-5，只允许一次模糊。 搜索关键词长度大于5，最多允许2次模糊。 7. 布尔查询&lt;bool&gt; 12345678910111213141516171819GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; // 以下条件必须都满足才能查询到数据 &quot;must&quot;:&#123; &quot;ids&quot;: &#123; &quot;values&quot;:[1] &#125;, &#123;&quot;term&quot;:&#123; &quot;title&quot;:&#123; &quot;value&quot;: &quot;风中捉刀&quot; &#125; &#125; &#125; &#125; &#125; &#125;&#125; must 必须满足才能查询，must_not 都不满足才能查询。 8. 多字段查询&lt;multi_match&gt; 123456789GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;multi_match&quot;:&#123; &quot;query&quot;: &quot;风中捉刀&quot;, &quot;fields&quot;: [&quot;title&quot;, &quot;description&quot;] &#125; &#125;&#125; 字段类型分词，将查询条件分词之后进行查询，如果不分词，就讲查询条件作为整体进行查询。 9. 默认字段分词查询&lt;query_string&gt; 123456789GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;&#125; 10. 高亮查询&lt;highlight&gt; 让符合条件的文档高亮显示。只有能分词的才支持高亮。 注意，查询出来的文档的关键词，ES会对其加入&lt;em&gt;标签标记，具体高亮样式由我们自己定义。高亮并没有直接修改原始文档，而是放到了另一个标签。 12345678910111213141516GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123;&quot;*&quot;:&#123;&#125;&#125;, // 自定义样式 &quot;pre_tags&quot;:[&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;], &quot;post_tags&quot;:[&quot;&lt;/span&gt;&quot;], &quot;require_field_match&quot;: &quot;false&quot; &#125;&#125; 11. 返回指定条数&lt;size&gt; ES查询数据，默认只显示前10条内容。 123456789101112131415161718GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123;&quot;*&quot;:&#123;&#125;&#125;, // 自定义样式 &quot;pre_tags&quot;:[&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;], &quot;post_tags&quot;:[&quot;&lt;/span&gt;&quot;], &quot;require_field_match&quot;: &quot;false&quot; &#125;, // 指定返回条数 &quot;size&quot;:3&#125; 12. 分页查询&lt;form&gt; 123456789101112131415161718GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123;&quot;*&quot;:&#123;&#125;&#125;, // 自定义样式 &quot;pre_tags&quot;:[&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;], &quot;post_tags&quot;:[&quot;&lt;/span&gt;&quot;], &quot;require_field_match&quot;: &quot;false&quot; &#125;, &quot;from&quot;: 2, &quot;size&quot;: 3&#125; 13. 排序&lt;sort&gt; 12345678910111213141516171819202122232425GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123;&quot;*&quot;:&#123;&#125;&#125;, // 自定义样式 &quot;pre_tags&quot;:[&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;], &quot;post_tags&quot;:[&quot;&lt;/span&gt;&quot;], &quot;require_field_match&quot;: &quot;false&quot; &#125;, &quot;from&quot;:0, &quot;size&quot;:3, &quot;sort&quot;:[ &#123; &quot;price&quot;:&#123; &quot;order&quot;:&quot;desc&quot; &#125; &#125; ]&#125; 排序会干预ES的内部的规则。 14. 返回指定字段&lt;_source&gt; 12345678910GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;, &quot;_source&quot;:[&quot;id&quot;, &quot;title&quot;, &quot;description&quot;]&#125; 分词器 1. ES 内置分词器 Standard Analyzer：默认分词器，英文按单词拆分，统一小写处理。 Simple Analyzer：按照单词切分，过滤符号，中文按照空格分词，统一小写处理。 Stop Analyzer：统一小写处理，停用词过滤。 Whitespace Analyzer：按照空格切分，不转小写。 Keyword Analyzer：不分词，直接将输入当作输出。 可以在创建索引的时候为映射字段指定分词器，默认的就是标准分词器（standard）： 123456789PUT /index_name&#123; &quot;mapping&quot;:&#123; &quot;properties&quot;:&#123; &quot;title&quot;:&quot;text&quot;, &quot;analyzer&quot;: &quot;standard|simple|stop|whitespace|keyword&quot; &#125; &#125;&#125; 2. 中文分词器 ES支持的中文分词器有IK、smartCN等，推荐的是 IK分词器。 注意： IK分词器的版本要和你安装的ES版本一致。 Docker插件所在的目录 /usr/share/elasticsearch/plugins IK分词器类型：ik_smart_word(组粒度拆分)、ik_max_word(细粒度拆分) 3. 扩展词、停用词配置 定义扩展词典和停用词典可以修改IK分词器中 config 目录中 IKAnalyzer.cfg.xml 文件。 1234567&lt;properties&gt; &lt;comment&gt;扩展词配置&lt;/comment&gt; &lt;!-- 扩展词典 --&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt; &lt;!-- 停用词典 --&gt; &lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;&lt;/properties&gt; 在ik分词器目录下config目录中创建 ext_dict.dic、ext_stopwords.dic 文件，文件编码必须为 UTF-8，添加扩展词即可。 4. 过滤查询 在ES中，可以使用过滤查询获得更快的查询速度。使用过滤查询，就需要前面使用的布尔查询。 12345678910111213141516171819202122GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; &quot;must&quot;:[ &quot;term&quot;:&#123; &quot;description&quot;:&#123; &quot;value&quot;:&quot;xxx&quot; &#125; &#125; ], &quot;filter&quot;:[ &#123; // 支持 term terms range exists ids 过滤 &quot;term&quot;:&#123; &quot;description&quot;:&quot;&quot; &#125; &#125; ] &#125; &#125;&#125; 会先执行过滤查询，再执行目标查询。一般用于大数据量的查询。 过滤查询是ES中一种重要的优化手段。 SpringBoot整合ES开发 导入es依赖 配置客户端 1234567891011@Configurationpublic class RestClientConfig extends AbstractElasticsearchConfiguration &#123; @Bean @Override public RestHighLevelClient elasticsearchClient() &#123; final ClientConfiguration client = ClientConfiguration.builder() .connectedTo(&quot;esIP地址:端口&quot;) .build(); return RestHighLevelClient.create(client).rest(); &#125;&#125; 进行客户端操作 客户端对象有两个，如果进行了上面的配置，那么都会在Spring工厂中创建： ElasticsearchOperations RestHighLevelClient（推荐使用） 1. ElasticsearchOperations 特点：始终使用面向对象方式操作ES 索引：用来存放相似文档集合 映射：决定文档的每个字段以什么方式录入到ES中 字段类型 分词器 文档：可以被索引的最小单元 json 数据格式 相关注解 注解名称 说明 @Document(indexName = “index_name”, createIndex = true) 用于类，指定索引名,是否创建索引 @Id 将放入对象 id 值作为文档 _id 进行映射 @Field(type = FieldType.Keyword) 指定字段类型 2. RestHighLevelClient 使用 RestHighLevelClient 非常简单，会使用Kibana就可以，它支持使用原生的编写 ES 的语句，只要会。可能这也是大家喜欢使用的原因之一吧。 123456SearchRequest search = new SearchRequest(document);SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();sourceBuilder.query(条件);search.source(sourceBuilder);SearchResponse searchResponse = restHignLevelClient.search(search, RequestOptions.DEFAULT); ES 集群搭建 准备三个节点 cluster-|node-1-|config/elasticsearch.yml 123456789101112131415161718192021# 集群名称，3个节点必须相同cluster.name: es-cluster# 指定节点名称node.name: # 开放远程连接network.host: 0.0.0.0# 指定使用发布地址进行集群间通信network.publish_host: 192.168.124.3# 指定 web 端口http.port: 9201# 指定 tcp 端口transport.tcp.port: 9301# 指定所有节点的 TCP 通信discovery.seed_hosts: [&quot;192.168.10.1:9301&quot;, &quot;192.168.10.1:9302&quot;, &quot;192.168.10.1:9303&quot;]# 指定可以初始化集群的节点名称cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;, &quot;node-3&quot;]# 集群最少几个节点可用gateway.recover_after_nodes: 2# 解决跨域问题http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 其它节点配置类似，只要修改对应的节点名称、IP以及对应的端口即可。 查看集群状态：http://任意集群节点ip:端口/_cat/health?v Head插件查看ES状态 我们可以使用 Github 上的大佬开发的查看 ES 状态信息的插件监控服务，该插件基于 js 编写，需要 Node 环境。 12345678git clone https://github.com/mobz/elasticsearch-head.gitcd elasticsearch-head# 安装依赖npm install# 启动npm run startopen http://localhost:9100/"},{"title":"MongoDB基础操作","path":"/wiki/编程后花园/Database/MongoDB基础操作.html","content":"MongoDB5.x版本基础操作整理，新版与之前的版本有些许变化。 MongoDB的三个默认库 admin： root 数据库 local： 这个数据永远不会复制，可以用来存储限于本地单台服务器的任意集合。 config： 当 Mongo 用于分片设置时，config 数据库在内部使用，用于保存分片的相关信息。 这三个库一般不需要操作。 基础操作 1.库操作 12345678// 查看所有库show databases; / show dbs;// 切换/创建指定库(不存在即创建)use 库名;// 查看当前所在库db// 删除当前库db.dropDatabase(); 1.使用 use 创建新库时，如果库内没有集合数据时，使用 show databases 是看不到新建的库的，但是可以使用 db 查看当前所在库。 2.使用删除库的命令时，删除后使用 db 命令还是在已删除的库中的，但是该库确实已经删除，因为该库已经没有数据了。 2.集合操作 集合：就类似与 MySQL 数据库中的表的概念，一个集合对应一张表。在向不存在的集合插入数据时，会自动创建该集合并插入数据。 12345678// 创建库use 库名;// 查看集合show collections; / show tables;// 创建集合db.createCollection(&quot;集合名称&quot;);// 删除集合db.集合名称.drop(); 如果集合并不存在，使用文档操作插入数据时，会隐式的创建不存在的集合并插入该数据 3.文档操作 官方文档https://docs.mongodb.com/manual/reference/method/ 文档：就是一条条的数据，增删改查就是针对文档的。 每条文档在放入集合的时候，MongoDB会自动的维护一个 _id，当然，我们可以手动指定，该 id 不允许重复。 单条文档插入 1234567891011121314// 查询所有文档db.集合名称.find();// 插入单条文档db.集合名称.insert(&#123;&#125;);// 删除文档：第二个参数可选db.集合名称.remove(&#123;&#125;, &#123; # 只删除一条 justOne: true &#125;);// 查询文档总条数：db.user.count();// 查询符合条件的文档条数：db.user.find(&#123;age: 18&#125;).count(); 新版本使用 insert 也可以直接插入多条文档 多条插入 1234567891011121314db.集合名称.insertMany( [&#123;&#125;, &#123;&#125;], &#123; // 写入策略，默认为1，要求确认写操作;0不要求 writeConcern: 1, // 是否按顺序写入，默认true，按顺序插入 ordered: true &#125;);db.集合名称.insert([ &#123;&#125;, &#123;&#125;]); 脚本插入 123for (let i = 1; i &lt; 10; i++) &#123; db.集合名称.insert(&#123;name: &quot;小明&quot; + i, age: i+10, bir: &quot;2021-10-0&quot; + i&#125;);&#125; 文档删除 1234// 删除所有文档db.集合名称.remove(&#123;&#125;);// 删除指定条件的文档db.集合名称.remove(&#123;条件&#125;); 文档更新：最后一个参数是可选的 12345678910111213db.集合名称.update( &#123;查询指定文档(类似 where)&#125; &#123;目标更新值(set 后面的值)&#125;, &#123; // 如果查不到更新的文档，是否将当前文档插入集合中， // 默认false不插入 upsert: &lt;boolean&gt;, // 是否只更新查询到的第一条记录。默认false，只更新第一条记录 multi: &lt;boolean&gt;, // 抛出异常的级别 riteConcern: &lt;document&gt; &#125;); 1234// 默认更新方式：先删除，后插入 结果不保留其它字段db.user.update(&#123;name: &quot;小明&quot;&#125;, &#123;age: 19, likes: [&quot;看书&quot;, &quot;听音乐&quot;]&#125;);// 如果想在原始记录上直接更新：使用 $setdb.user.update(&#123;name: &quot;小明&quot;&#125;, &#123;$set:&#123;age: 19, likes: [&quot;吃饭&quot;, &quot;睡觉&quot;]&#125;&#125;); 默认的更新方式是先删除再插入，如果想保留其它的字段，在原始的记录上进行修改，需要使用 $set，例如：db.user.update(&#123;name:&quot;小明&quot;&#125;, &#123;$set:&#123;name:&quot;小黑&quot;&#125;&#125;)。 文档查询 123456789101112131415161718192021222324252627282930313233343536// 查询所有文档(默认显示前 20 条数据)db.集合名称.find();// 查询文档数量db.集合名称.count();db.集合名称.find(条件).count();// 格式化后展示数据db.集合名称.find().pretty();// 查询年龄大于20的db.集合名称.find(&#123;age: &#123;$gt: 20&#125;&#125;);// and 且查询：名字年龄同时满足db.集合名称.find(&#123;name: &#x27;小明&#x27;, age: 24&#125;);// or 或查询：名字年龄有一个满足db.集合名称.find(&#123;$or: [&#123;nmae: &quot;小明&quot;&#125;, &#123;age: 20&#125;]&#125;);// $size 按照数组长度查询db.集合名称.find(&#123;likes: &#123;$size: 2&#125;&#125;);// 排序（1：升序；-1：降序）// 按年龄升序排列输出db.集合名称.find().sort(&#123;name: 1, age: 1&#125;);// 模糊查询(使用正则实现，不能使用引号，使用 /)db.集合名称.find(&#123;name: /小/&#125;);// 分页查询 skip：起始条数 limit：每页条数db.集合名称.find(&#123;&#125;).skip(0).limit(2);// 去重db.集合名称.distinct(&#x27;age&#x27;);// 查询时指定返回字段(1：返回，0;不返回)。0和1不能同时用// 默认返回 _iddb.集合名称.find(&#123;&#125;, &#123;name: 1&#125;);// $type 查询，只查询字段为指定类型的文档数据db.集合名称.find(&#123;key: &#123;$type: 2&#125;&#125;);db.集合名称.find(&#123;key: &#123;$type: &#x27;String&#x27;&#125;&#125;); 符号 含义 $lt 小于 $gt 大于 $lte 小于等于 $gte 大于等于 $eq 等于 $ne 不等于 类型 对应数字 说明 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript(with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Max key 127 注意： And查询时，如果同一个条件出现多次，那么后面的值会覆盖前面的。例如 db.user.find(&#123;name: '小明',name: '小红'&#125;); 那么，会查找 name 为小红的数据。 使用正则表达式实现近似的模糊查询时，需要使用 / 作为正则匹配符。 $type 查询的 undefined 类型在新版本中已经废弃。 MoongoDB中数字类型默认按 Double 类型存储，不论小数或者整数。 查询时只返回指定的字段时，0和1不能同时使用。 索引 1. 基本操作 123456789101112131415161718192021222324// 创建索引(1:升序；-1:降序)：db.集合名称.createIndex(&#123;name: 1&#125;);// 创建复合索引(左前缀原则):db.集合名称.createIndex(&#123;name: 1, age: -1&#125;)// 查看所有索引：db.集合名称.getIndexes();// 查看索引大小(字节大小)：db.集合名称.totalIndexSize();// 创建升序索引：db.集合名称.createIndex(&#123;name:1&#125;)// 创建降序索引：db.集合名称.ensu// 创建索引指定索引名称：db.集合名称.createIndex(&#123;name:1&#125;, &#123;name: &quot;name_index&quot;&#125;)// 创建唯一索引：db.集合名称.createIndex(&#123;name:1&#125;, &#123;unique: true&#125;)// 创建指定时间过期的索引，单位：秒db.集合名称.createIndex(&#123;name: 1&#125;, &#123;expireAfterSeconds: 20&#125;);// 删除指定索引db.集合名称.dropIndex(&quot;索引名称&quot;);// 删除所有索引，不包含 _iddb.集合名称.dropIndexes(); 2. 复合索引 一个索引的值由多个key共同维护的索引称为复合索引。 MongoDB的复合索引和关系型数据库一样，也满足最左匹配原则。 3. 聚合查询（aggregate） 主要用于处理数据。 表达式 描述 $sum 计算总和 $avg 计算平均值 $min 获取集合中所有文档对应值的最小值 $max 获取集合中所有文档对应值的最大值 $push 将值加入一个数组中，不会判断是否只有重复的值 $addToSet 将值加入一个数组中，会判断是否有重复的值，若该值数组中已经存在，则不加入 $first 根据资源文档的排序获取第一个文档数据 $last 根据资源文档的排序获取最后一个文档数据 举例： 1234567// _id 不是文档的id，而是聚合查询的标识符db.test.aggregate([&#123;$group: &#123;_id: &#x27;$by_user&#x27;, &#x27;avg_by_user&#x27;: &#123;$avg: &#x27;$likes&#x27;&#125;&#125;&#125;])//聚合查询：查询喜欢该作者的人数的平均值、最大值、最小值。// 即获取 liskes 列的平均值，最大值，最小值db.test.aggregate([&#123;$group: &#123;_id: &#x27;$by_user&#x27;, &#x27;avg_by_user&#x27;: &#123;$avg: &#x27;$likes&#x27;&#125;&#125;&#125;])db.test.aggregate([&#123;$group: &#123;_id: &#x27;$by_user&#x27;, &#x27;max_by_user&#x27;: &#123;$max: &#x27;$likes&#x27;&#125;&#125;&#125;])db.test.aggregate([&#123;$group: &#123;_id: &#x27;$by_user&#x27;, &#x27;min_by_user&#x27;: &#123;$min: &#x27;$likes&#x27;&#125;&#125;&#125;]) 注意： 在使用以上的聚合查询时，使用的 _id 不是文档默认维护的id，而是以哪个字段为标识符进行分组查询。上面的例子就是以 by_user 字段为标识符。类似MySQL中的 order by xxx。 SpringBoot 整合 MongoDB 引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;version&gt;2.6.4&lt;/version&gt;&lt;/dependency&gt; 配置 properties 或者 yaml 编写程序 MongoDB架构 1. 主从复制（4.0 版本废弃，了解即可） 备份、故障恢复、读扩展 生产环境中，如果使用的是老版本的 MongoDB，推荐的从节点不超过 12 个。 从节点：仅仅负责数据同步，冗余备份，不能进行自动故障转移。 启动主节点： ./mongod --port 27017 --dbpath /root/data/master --master --bind_ip 0.0.0.0 --oplogSize 100 启动多个从节点： ./mongod --port 27018 --dbpath /root/data/slave1 --slave --bind_ip 0.0.0.0 --source 192.168.10.1:27017 --only 100 --autoresync ./mongod --port 27019 --dbpath /root/data/slave2 --slave --bind_ip 0.0.0.0 --source 192.168.10.1:27017 --only 100 –source： 指定主库的位置 –only： 指定复制哪个库 默认的从节点也不能查看，开启从节点的查看权限： rs.slaveOK(); yum install -y lrzsz 文件的上传和下载 2. 副本集 为了解决主从复制中自动转移的问题，尽管主从在新版本中已经废弃，MongoDB 又提出了新的结构，就是副本集。可以理解为带有自动故障转移的主从复制架构。推荐的副本集为奇数个。 副本集必须进行初始化。 123mongod --port 27017 --dbpath ../repl/data1 --bind_ip 0.0.0.0 --replSet myreplace/[localhost:27018,localhost:27019]mongod --port 27018 --dbpath ../repl/data2 --bind_ip 0.0.0.0 --replSet myreplace/[localhost:27017,localhost:27019]mongod --port 27019 --dbpath ../repl/data3 --bind_ip 0.0.0.0 --replSet myreplace/[localhost:27017,localhost:27018] –replRet 副本集，myreplace 副本集名称/集群中其它节点的主机和端口。 对副本集进行查看时，如果不允许查询，使用 rs.secondaryOk()后再进行查询。 多个副本集组成的的名称必须一样 推荐使用本机IP地址，尽量不要使用 localhost 配置副本集，连接任意节点：use admin 初始化副本集： 12345678910111213# 初始化配置：如果错了可以多次修改，以最后一次为准&gt; var config = &#123; _id:&quot;myreplace&quot;, members:[ # 副本集主机地址：端口 # 推荐使用本机的IP地址，不要使用 localhost &#123;_id:0, host: &quot;localhost: 27017&quot;&#125;, &#123;_id:1, host: &quot;localhost: 27018&quot;&#125;, &#123;_id:2, host: &quot;localhost: 27019&quot;&#125;, ]&#125;# 调用初始化函数&gt; rs.initiate(config); 当集群超过半数以上的节点宕机时，集群无法对外提供服务。 3. 分片（sharding） 目的：解决单点压力问题（并发访问） Shard：用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组成一个replica set承担，防止主机单点故障。 Config Server：mongod实例，存储了整个ClusterMetadata。 Query Routers：前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。 Shard Key：片键，设置分片时需要在集合中选择一个片键作为拆分数据的依据。片键的选取决定了数据散列是否均匀。 4. 环境搭建 MongoDB4.0版本之后要求Config Server必须以副本集方式部署，以保证系统的高可用。也建议每一个Shard也为一个副本集，目前没有强制要求必须为副本集。 创建三个分片，每一个分片创建一个副本集，一共是6个。再创建3个Config Server和一个Router Process，一共10个端口，9个数据目录。 1.启动s0 r0 1234567891011121314# 分片./mongod --port 27017 --dbpath ../cluster/shard/s0 --bind_ip 0.0.0.0 shardsvr --replSet r0/121.5.167.13:27018# 对应副本集./mongod --port 27018 --dbpath ../cluster/shard/s0-repl --bind_ip 0.0.0.0 shardsvr --replSet r0/121.5.167.13:27017# 登录任意节点执行use admin# 编写配置config = &#123;_id: &quot;r0&quot;, members:[ &#123;_id: 0, host: &quot;121.5.167.13:27017&quot;&#125;, &#123;_id: 1, host: &quot;121.5.167.13:27018&quot;&#125;,]&#125;# 初始化，在初始化之前的配置信息可以多次执行，以最后一次为准rs.initiate(config); 2.启动s1 r1 12345678910111213./mongod --port 27019 --dbpath ../cluster/shard/s1 --bind_ip 0.0.0.0 shardsvr --replSet r1/121.5.167.13:27020./mongod --port 27020 --dbpath ../cluster/shard/s1-repl --bind_ip 0.0.0.0 shardsvr --replSet r1/121.5.167.13:27019# 登录任意节点执行use admin# 编写配置config = &#123;_id: &quot;r1&quot;, members:[ &#123;_id: 0, host: &quot;121.5.167.13:27019&quot;&#125;, &#123;_id: 1, host: &quot;121.5.167.13:27020&quot;&#125;,]&#125;# 初始化rs.initiate(config); 3.启动s2 r2 12345678910111213./mongod --port 27021 --dbpath ../cluster/shard/s2 --bind_ip 0.0.0.0 shardsvr --replSet r3/121.5.167.13:27022./mongod --port 27022 --dbpath ../cluster/shard/s2-repl --bind_ip 0.0.0.0 shardsvr --replSet r2/121.5.167.13:27021# 登录任意节点执行use admin# 编写配置config = &#123;_id: &quot;r2&quot;, members:[ &#123;_id: 0, host: &quot;121.5.167.13:27021&quot;&#125;, &#123;_id: 1, host: &quot;121.5.167.13:27022&quot;&#125;,]&#125;# 初始化rs.initiate(config); 4.启动3个config服务 12345678910111213141516./mongod --port 27023 --dbpath ../cluster/shard/config1 --bind_ip 0.0.0.0 --replSet config/[121.5.167.13:27024,121.5.167.13:27025] --configsvr./mongod --port 27024 --dbpath ../cluster/shard/config2 --bind_ip 0.0.0.0 --replSet config/[121.5.167.13:27023,121.5.167.13:27025] --configsvr./mongod --port 27025 --dbpath ../cluster/shard/config3 --bind_ip 0.0.0.0 --replSet config/[121.5.167.13:27023,121.5.167.13:27024] --configsvr# 初始化configuse admin# 编写配置config = &#123;_id: &quot;config&quot;, configsvr: true, members:[ &#123;_id: 0, host: &quot;121.5.167.13:27023&quot;&#125;, &#123;_id: 1, host: &quot;121.5.167.13:27024&quot;&#125;, &#123;_id: 1, host: &quot;121.5.167.13:27025&quot;&#125;,]&#125;# 初始化rs.initiate(config); 5.启动路由服务 1./mongod --port 27026 --configdb config/121.5.167.13:27023,121.5.167.13:27024,121.5.167.13:27025 --bind_ip 0.0.0.0 6.登录 mongos 服务 123456789101112./mongo --port 27026use admin# 添加分片信息db.runCommand(&#123;addshard: &quot;121.5.167.13:27017&quot;, &quot;allowLocal&quot;:true&#125;);db.runCommand(&#123;addshard: &quot;121.5.167.13:27019&quot;, &quot;allowLocal&quot;:true&#125;);db.runCommand(&#123;addshard: &quot;121.5.167.13:27021&quot;, &quot;allowLocal&quot;:true&#125;);# 启用指定数据库的分片db.runCommand(&#123;enablesharding: &quot;xxx&quot;&#125;);# 设置库的片键信息 xxx库的xxxx集合，使用 _id 作为片键（不推荐）db.runCommand(&#123;shardcollection: &quot;xxx.xxxx&quot;, key: &#123;_id: 1&#125;&#125;);# 使用 xxx库xxxx集合的 _id 的哈希作为散列（推荐）db.runCommand(&#123;shardcollection: &quot;xxx.xxxx&quot;, key: &#123;_id: &quot;hashed&quot;&#125;&#125;);"},{"title":"MySQL","path":"/wiki/编程后花园/Database/MySQL.html","content":"一、MySQL 配置 /etc/my.cnf12345678[mysqld]# 修改等待时间，两个选项必须同时修改wait_timeout=28800;interactive_timeout=28800;# 调整默认时区为东八区default-time-zone=&#x27;+08:00&#x27;# 开启 MySQL 事件定时任务（5.7 支持，8.0 默认开启）event_scheduler = 1 二、查看配置的命令 1234567891011121314151617-- 查看事件是否开启。SHOW VARIABLES LIKE &#x27;event_scheduler&#x27;;-- 创建事件删除当天数据，每天凌晨 1 点执行CREATE EVENT every_day_delete_gantry ON SCHEDULE EVERY 1 DAY STARTS &#x27;2023-08-20 01:00:00&#x27; ON COMPLETION PRESERVEDO delete from table_name where TO_DAYS(now_time) &lt;= TO_DAYS(now())-- 显示最大连接参数show VARIABLES like &#x27;max_connections&#x27;-- 显示等待时间show VARIABLES like &#x27;%wait_time%&#x27;-- 显示数据库时区show variables like &quot;%time_zone%&quot;; PRESERVE 表示此次执行完不删除该事件，等到下次继续执行。 三、附 1. 关于分布式主键的几个问题 在 MySQL 的分布式架构中，为什么不能使用自增主键？ 如果基于主键范围分片，压力可能集中在某个分片，采用其它业务字段 hash 分片，可以缓解压力 如果使用 auto_increment 和 replace into 自增 ID，每当插入数据时，都会占用自增锁和插入锁 分布式系统中，每个节点都会有自己的自增 ID，合并数据时，会出现 ID 冲突 UUID 可以做主键？存在哪些问题？ 由于其生成随机、无序，所以会发生索引断裂、磁盘碎片。 uuid 的问题可以通过有序 uuid 来解决，MySQL 8.0 提供 uuid_to_bin 函数来互换uuid的时间低位和高位，将无序的 uuid 转为有序的 uuid，同时保证了唯一性和有序性，也能解决索引性能下降的问题。 雪花算法生成的 id 有什么缺点？ 雪花算法的原理：把当前时间戳转为 unix_time 形式，再将 unix_time 形式的时间戳转为 二进制 数字，这串二进制数据长度为 41 bit。在前面补 0 当作符号位。机器编码的二进制补到 10 bit 机器编号位置，序列号的二进制补到 12 bit 序列号位置，最后把这一长串转为 10 进制数字，这串数字就是该算法生成的 id。 雪花算法基于时间戳的自增完成的，可以实现分布式的部署；所以缺点也是显而易见：高度依赖服务器的时间。如果时间发生了回拨，就会出现时间重复，对应生成的 id 可能会重复。 另外 41 bit 存储的时间跨度是 69 年。而 unix_time 从 1970 年算起，到现在已经过去了 53 年，所以现在生成的可以使用 16 年，会出现 41 bit 不够用的情况。可以使用当前时间减去系统的上线时间，这样可以使用 69 年。 Unix 时间戳是从 1970 年 1 月 1 日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒。 四、MySQL 调优 优化是相对的。 引擎分类 InnoDB InnoDB 包含四种索引类型 类型 说明 主键索引 innoDB 默认为聚簇索引，该列的值不能为 null； 单值索引 普通索引）：一个索引只包含单个列； 唯一索引 该列的值允许为 null； 复合索引 多列的值； MyISAM 全文索引 MySQL 的最左包含原则是条件中含有最左的字段，但并不限制该字段所在的位置顺序。 优化口诀 阿里巴巴手册中说：SQL优化标准是到 ref，最差是 range，达到 const 最好。 索引失效： 全值匹配最喜欢，最左前缀规矩严。 带头大哥不能死，中间兄弟不能断。 索引列上少计算，范围之后全完蛋。 LIKE百分最右边，覆盖索引*全不见。 不等空值还有OR，你建索引也失效。 VAR引号要出现，SQL高级也不难。 建立索引口诀： 主键索引自动建，频繁查询索引现； 查询关联其他表，外键索引也要看； 频繁更新引不建，where条件用到算； 单键/组合选择难，高并发下组合建； 若要速度有体现，排序字段索引建； 统计、分组你咋看？索引索引建建建。 一般守则 尽量不在数据库做复杂运算； 单库不超过 300~400 张表，单表不超过 500w 数据，表字段控制在 20~50 个； 顺序读1G文件需N秒，单行不超过 200 Byte 单表不超过50个纯INT字段 单表不超过20个CHAR(10)字段 在一些场景中，不必严格遵循三范式，可以适当时牺牲范式，加入冗余； 防止 3B：Big SQL、Big Transaction、Big Batch； 统一字符集为UTF-8 统一命名规范 库表等名称统一用小写，注意避免用保留字命名。 索引命名默认为“idx_字段名” 库名用缩写，尽量在2~7个字母 字段 1. 用好数值类型 TINYINT(1Byte)、SMALLINT(2B)、MEDIUMINT(3B)、INT(4B)、BIGINT(8B)、FLOAT(4B)、DOUBLE(8)、DECIMAL(M,D) 数字型VS字符串型索引： 更高效 查询更快 占用空间更小 举例：用无符号INT存储IP，而非CHAR(15)，使用数据库的函数去查看INT UNSIGNED、INET_ATON()、INET_NTOA() 2. 少用并拆分TEXT/BLOB TEXT 类型处理性能远低于 VARCHAR，会强制生成硬盘临时表，浪费更多空间：VARCHAR(65535) ==&gt; 64K (注意UTF-8)； 尽量不用TEXT/BLOB数据类型，若必须使用则拆分到单独的表 3. 不在数据库里存图片 索引 1. 合理添加索引 改善查询 减慢更新 索引不是越多越好，需要综合评估数据密度和数据分布；最好不超过字段数20%，结合核心SQL优先考虑覆盖索引 举例：不要给“性别”列创建索引 2. 不在索引列做运算 不在索引列进行数学运算或函数运算，否则会导致无法使用索引以及全表扫描。 3. 自增列或全局ID做INNODB主键 对主键建立聚簇索引 二级索引存储主键值 主键不应更新修改 按自增顺序插入值 忌用字符串做主键 聚簇索引分裂 推荐用独立于业务的 AUTO_INCREMENT 列或全局 ID 生成器做代理主键 若不指定主键，InnoDB会用唯一且非空值索引代替 4. 尽量不用外键 尽量不使用外键，由程序来保证约束，实际中确实很少使用。虽然外键可节省开发量，但是有额外开销：逐行操作，可‘到达’其它表，意味着锁；在高并发场景容易死锁。 SQL SQL语句尽可能简单 保持事务连接小 尽可能避免使用SP/TRIG/FUNC 尽可能少用存储过程、触发器；减用使用MySQL函数对结果进行处理，由客户端程序负责。 尽量不用SELECT *，只取需要的数据列 改写OR为IN() 同一字段，将OR改写为IN()。 OR效率：O(n)，IN 效率：O(Log n) 当n很大时，OR会慢很多。注意控制IN的个数，建议n小于200。 12select * from opp WHERE phone=&#x27;12347856&#x27; or phone=&#x27;42242233&#x27;;select * from opp WHERE phone in (&#x27;12347856&#x27; , &#x27;42242233&#x27;); 改写OR为UNION 不同字段，将or改为union 减少对不同字段进行 “or” 查询 Merge index往往很弱智，如果有足够信心：set globaloptimizer_switch='index_merge=off'; 123456-- 原写法select * from opp WHERE phone=&#x27;010-88886666&#x27; or cellPhone=&#x27;13800138000&#x27;;-- 优化写法Select * from opp WHERE phone=&#x27;010-88886666&#x27; union Select * from opp WHERE cellPhone=&#x27;13800138000&#x27;; LIMIT高效分页 LIMIT 的偏移量越大则查询越慢。 123456-- 分页方式一Select * from table WHERE id&gt;=23423 limit 11;-- 分页方式二Select * from table WHERE id &gt;= ( select id from table limit 10000,1 ) limit 10;-- 分页方式三SELECT * FROM table INNER JOIN (SELECT id FROM table LIMIT 10000,10) USING (id) ; 用UNION ALL而非UNION 若无需对结果去重，则用 UNION ALL，UNION 有去重开销。 Load Data导数据 批量数据导入： 成批装载比单行装载更快，不需要每次刷新缓存 无索引时装载比索引装载更快 Insert values ,values，values 减少索引刷新 Load data 比 insert 快约20倍 尽量不用 INSERT INTO... SELECT，可能会出现延迟、同步出错 Know Every SQL 1234567EXPLAINSHOW PROFILEShow Slow LogShow ProcesslistSHOW QUERY_RESPONSE_TIME(Percona)MySQLdumpslowMySQLsla"},{"title":"PostgreSQL","path":"/wiki/编程后花园/Database/PostgreSQL.html","content":"一、简介 PostgreSQL 是一个功能强大的开源对象关系数据库系统，它使用并扩展了 SQL 语言，并结合了许多可安全存储和扩展最复杂数据工作负载的特性。PostgreSQL 的起源可以追溯到 1986 年，作为POSTGRES项目的一部分，并在核心平台上进行了 30 多年的积极开发。 PostgreSQL 因其久经考验的架构、可靠性、数据完整性、强大的功能集、可扩展性以及软件背后的开源社区致力于始终如一地提供高性能和创新解决方案而赢得了良好的声誉。PostgreSQL 可在所有主要操作系统一直符合 ACID，并具有强大的附加组件，例如流行的PostGIS地理空间数据库扩展器。毫不奇怪，PostgreSQL 已成为许多人和组织选择的开源关系数据库。 PostgreSQL 具有许多功能，旨在帮助开发人员构建应用程序、帮助管理员保护数据完整性和构建容错环境，并帮助您管理数据，无论数据集大小。除了免费和开源，PostgreSQL 还具有高度可扩展性。例如，您可以定义自己的数据类型、构建自定义函数，甚至使用不同的编程语言而无需重新编译数据库！ PostgreSQL 试图符合SQL 标准，这样的一致性不会与传统特性相矛盾或可能导致糟糕的架构决策。支持 SQL 标准所需的许多功能，但有时语法或功能略有不同。随着时间的推移，可以预期进一步朝着一致性迈进。从 2021 年 9 月发布的第 14 版开始，PostgreSQL 至少符合 SQL:2016 Core 一致性的 179 个强制性特性中的 170 个。在撰写本文时，没有任何关系数据库完全符合此标准。 以上内容摘自官网：https://www.postgresql.org/about/ 二、安装和操作 Win 下的安装请参见浪子的首页 Windows 环境配置一章的内容。 操作推荐网站：https://www.sjkjc.com/postgresql 一些PostgreSQL Shell命令 1234567891011121314151617# 连接本地数据库psql -U [username] -W dbname# 连接到远程数据库psql -h [host] -U [username] -W dbname# 修改密码ALTER USER postgres WITH PASSWORD &#x27;postgres&#x27;;# 显示所有数据库\\l# 显示当前数据库的所有表\\d# 显示数据库的表空间\\db+# 进入指定的数据库\\c dbname# 退出bash\\q 自增列 PG 中在创建表的时候不像 MySQL 那样可以直接设置主键自增，有两种方式设置： 第一种，自增列使用 serial 类型； 123CREATE TABLE table_name ( id serial primary key); 第二种，先创建序列，然后使用序列： 12345678-- 创建一个序列 sequence_name 自己命名的序列名称CREATE SEQUENCE sequence_name;-- 若表还未创建CREATE TABLE table_name ( id int2 NOT NULL DEFAULT nextval(&#x27;sequence_name&#x27;));-- 如果是表已经存在：修改表字段的默认值为序列名称ALTER TABLE table_name ALTER COLUMN column_name SET DEFAULT nextval(&#x27;sequence_name&#x27;::regclass); 第一种的本质和第二种是一样的，只是省去了我们自己创建序列的步骤，但是使用第二种可以自定义序列名称。"},{"title":"Redis","path":"/wiki/编程后花园/Database/Redis.html","content":"一、Redis 简介 Redis 是一个开源（BSD 许可）的内存数据结构存储库，可用作数据库、缓存、消息代理和流引擎。Redis 提供字符串、哈希值、列表、集合、带范围查询的排序集合、位图、hyperloglogs、地理空间索引和流等数据结构。Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久性，并通过 Redis Sentinel 和 Redis Cluster 自动分区提供高可用性。 你可以在这些类型上运行原子操作，如追加字符串；递增哈希值；向列表添加元素；计算集合的交集、联合和差值；或获取排序集合中排名最靠前的成员。 为了达到最佳性能，Redis 使用内存数据集。根据使用情况，Redis 可以通过定期将数据集转储到磁盘或将每条命令附加到基于磁盘的日志来持久化数据。如果你只需要功能丰富的网络内存缓存，也可以禁用持久化功能。 Redis 支持异步复制，具有快速无阻塞同步和自动重新连接功能，并可在网络拆分时进行部分重新同步。 Redis 由 ANSI C 编写，可在大多数 POSIX 系统（如 Linux、*BSD 和 Mac OS X）上运行，无需外部依赖。Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方建议使用 Linux 进行部署。Redis 可在 Solaris 衍生系统（如 SmartOS）中运行，但只能尽力提供支持。Windows 版本没有官方支持。 Windows 版下载 官方没有提供 Windows 的安装包，推荐部署到 Linux 中的，但是有时候我们需要在客户的 Windows 中开发，本地的服务还是很有必要的。可以在 Github 中下载 Redis-Version-Windows-x64-with-Service.tar.gz，with-service 后缀的包可以注册服务自动运行。 注册 Redis 服务并启动 12sc.exe create Redis binpath=&quot;RedisService.exe所在的绝对路径&quot; start= autonet start Redis binpath 声明的路径必须使用引号！ 停止并卸载 1234# 停止 Redis 服务net stop Redis# 卸载sc.exe delete Redis Linux 安装 123456curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpgecho &quot;deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main&quot; | sudo tee /etc/apt/sources.list.d/redis.listsudo apt-get updatesudo apt-get install redis Redis 各个版本的配置文件 https://redis.io/docs/management/config/ 二、Redis 不同版本 Redis 4.0 中开始使用多线程，但是用户无法定义；Redis 的业务主要由主线程处理，后台线程只处理一些较慢的操作，例如：清理数据、释放无用连接。 Redis 6.0 中引入多线程，并且用户可以配置，多线程默认是 关闭 的，开启需要修改 io-threads-do-reads 为 yes，然后修改使用的线程数：io-threads。 在 Redis 7 及更高版本中，可以使用 Redis Functions 来管理和运行脚本。在 Redis 6.2 及更低版本中，可以使用带有 EVAL 命令的 Lua 脚本对服务器进行编程。 Functions 与数据本身一起存储。Functions 也会持久化到 AOF 文件中，并从主服务器复制到副本，因此它们与数据本身存储的时间一样。当 Redis 用作短暂缓存时，还需要额外的机制（如下所述）来提高函数的持久性。 与 Redis 中的所有其他操作一样，函数的执行是原子性的。函数的执行会在整个过程中阻塞所有服务器活动，这与事务的语义类似。这些语义意味着脚本的所有效果要么尚未发生，要么已经发生。已执行函数的阻塞语义始终适用于所有已连接的客户端。由于运行函数会阻塞 Redis 服务器，因此函数的目的是快速完成执行，因此应避免使用长时间运行的函数。 每个程序库至少需要包含一个注册函数才能成功加载。已注册函数会被命名，并作为库的入口点。目标执行引擎在处理 FUNCTION LOAD 命令时，会注册库的函数。 在 v7.0 中添加的 Redis 函数本质上是作为第一类数据库元素的脚本。因此，函数将脚本与应用程序逻辑分离，并支持脚本的独立开发、测试和部署。若要使用函数，需要先加载它们，然后它们可供所有连接的客户端使用。在这种情况下，将函数加载到数据库成为一项管理部署任务，这会将脚本与应用程序分开。 Redis 持久化方式 RDB（Redis Database）：RDB 持久性可按指定时间间隔对数据集执行时间点快照。 AOF（Append Only File）： AOF 持久化会记录服务器收到的每个写操作。这些操作可以在服务器启动时再次重放，重建原始数据集。命令记录格式与 Redis 协议本身相同。 无持久性 可以完全禁用持久化。这有时会在缓存时使用。 RDB + AOF：还可以在同一实例中结合使用 AOF 和 RDB。 1. RDB（时间间隔内的数据快照） 优势 RDB 是 Redis 数据非常紧凑的单文件时间点表示。RDB 文件非常适合备份。例如，你可能希望每小时归档最近 24 小时的 RDB 文件，每天保存一个 RDB 快照，持续 30 天。这样就可以在发生灾难时轻松恢复数据集的不同版本。 RDB 非常适合灾难恢复，因为它是一个紧凑的文件，可以传输到远处的数据中心或亚马逊 S3（可能已加密）等。 RDB 能最大限度地提高 Redis 的性能，因为 Redis 父进程为持久化所需做的唯一工作就是分叉一个子进程，由子进程完成其余所有工作。父进程永远不会执行磁盘 I/O 或类似操作。 与 AOF 相比，RDB 允许更快地重启大数据集。 在副本上，RDB 支持重启和故障切换后的部分重新同步。 不足 如果需要在 Redis 停止工作（例如停电后）时尽量减少数据丢失的几率，那么 RDB 就不太合适。你可以配置生成 RDB 的不同保存点（例如，数据集至少经过 5 分钟和 100 次写入后，你可以有多个保存点）。不过，你通常会每五分钟或更长时间创建一次 RDB 快照，因此，如果 Redis 因故停止工作而没有正确关机，你应该做好丢失最近几分钟数据的准备。 如果数据集很大，fork() 可能会很耗时，如果数据集很大，CPU 性能又不高，可能会导致 Redis 在几毫秒甚至一秒内停止为客户端提供服务。AOF 也需要 fork()，但频率较低，你可以调整重写日志的频率，而无需牺牲可用性。 2. AOF（操作记录） 优势 使用 AOF Redis 则更耐用：你可以使用不同的 fsync 策略：完全不执行 fsync、每秒执行 fsync、每次查询都执行 fsync。fsync 是使用后台线程执行的，主线程会在没有 fsync 的情况下努力执行写入操作，因此只会损失一秒钟的写入量。 AOF 日志是一种仅追加的日志，因此不会出现寻道问题，也不会在断电时出现损坏问题。即使由于某种原因（磁盘已满或其他原因），日志以写入一半的命令结束，redis-check-aof 工具也能轻松修复。 当 AOF 过大时，Redis 会在后台自动重写。重写是完全安全的，因为 Redis 在继续追加旧文件的同时，会用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换这两个文件，并开始追加新文件。 AOF 包含一个接一个操作的日志，格式简单易懂，易于解析。你甚至可以轻松导出 AOF 文件。例如，即使你不小心使用 FLUSHALL 命令刷新了所有数据，只要在此期间没有重写日志，你仍然可以通过停止服务器、删除最新命令并重新启动 Redis 来保存数据集。 不足 对于相同的数据集，AOF 文件通常比相应的 RDB 文件大。 AOF 可能比 RDB 慢，这取决于具体的同步策略。一般来说，当 fsync 设置为每秒一次时，AOF 的性能仍然很高，而当 fsync 禁用时，即使在高负载情况下，AOF 的速度也应与 RDB 完全相同。不过，即使在写入负载很大的情况下，RDB 也能提供更多关于最大延迟的保证。 在 Redis 7.x 以下，还可能会有以下情况： 如果在重写过程中向数据库写入内容（这些内容在内存中缓冲，并在最后写入新的 AOF），AOF 可能会占用大量内存。 在重写过程中到达的所有写入命令都会写入磁盘两次。 Redis 可能会在重写结束时冻结向新的 AOF 文件写入和同步这些写入命令。 what should I use? 一般来说，如果你想获得与 PostgreSQL 相当的数据安全程度，就应该同时使用这两种持久化方法。 如果你非常关心你的数据，但仍然可以忍受灾难发生时几分钟的数据丢失，那么你可以只使用 RDB。 有许多用户只使用 AOF，但我们不鼓励他们这样做，因为偶尔或者说拥有一个某一时刻的 RDB 快照是一个很好的主意，这样可以进行数据库备份、更快地重新启动，以及在 AOF 引擎出现错误时使用。 以上内容机翻+自翻译官网内容 内存淘汰策略/驱逐策略 内存淘汰策略：Redis 的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。 三、Redis 的几种模式 主从模式 redis 主从复制，从节点默认是只读的，当 master 服务挂掉之后，从节点不能代替主节点；主从复制架构只是一个数据的备份。 哨兵模式(建立在主从模式上) 哨兵的作用，就是监控主、从数据库的状态，当主数据库宕机以后，哨兵会在一定的时间内去判断，然后在从数据库中选举出一个去顶替主数据库，从而实现redis数据的高可用。 集群模式 Redis 的集群模式使用了 CRC16 算法，该算法有以下特点: 对集群模式下的所有key进行 CRC16 计算，计算的结果始终在 0-16383 之间（Redis 有 16384 的 slot） 对客户端的key进行CRC16算法计算时，同一个key经过多次计算，计算结果始终一致。 对客户端的不同的key进行CRC16计算，会出现不同的key计算结果一致。 伪集群搭建配置文件示例 搭建 redis 伪集群实现 session 共享： 修改不同端口的配置文件： 1234567891011121314151617# 启动端口号port 7000# 允许远程连接bind 0.0.0.0# rdb 方式持久化数据的文件名dbfilename dump-7000.rdb# 开启守护进程(即后台运行)daemonize yes# 开启 aof 缓存并指定 aof 方式持久化数据的文件名appendonly yesappendonlyfilename &quot;appendonly-7000.aof&quot;# 开启集群配置cluster-enabled yes# 配置集群节点名称cluster-config-file nodes-7000.conf# 集群超时时间 5scluster-node-timeout 5000 配置主从数据库后使用 redis-cli 进行连接后，使用 info replication 命令查看当前数据库的 role，“master” 是主节点，“slave” 是从节点。默认从库是只读的，不能进行写操作。 四、缓存设计典型问题 1. 缓存穿透 缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。 造成缓存穿透的基本原因有两个：第一，自身业务代码或者数据出现问题。第二，一些恶意攻击、爬虫等造成大量空命中。 解决方案： 缓存空对象； 布隆过滤器 对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不存在的数据，布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说某个值存在时，这个值可 能不存在；当它说不存在时，那就肯定不存在。 布隆过滤器 布隆过滤器就是一个大型的位数组和几个不一样的无偏 hash 函数。所谓无偏就是能够把元素的 hash 值算得比较均匀。 向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash，算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。 向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在。如果都是 1，这并不能说明这 个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。 这种方法适用于数据命中不高、数据相对固定、实时性低（通常是数据集较大）的应用场景，代码维护较为 复杂，但是缓存空间占用很少。 2. 缓存击穿（失效） 由于大批量缓存在同一时间失效可能导致大量请求同时穿透缓存直达数据库，可能会造成数据库瞬间压力过大甚至挂掉，对于这种情况我们在批量增加缓存时最好将这一批数据的缓存过期时间设置为一个时间段内的不同时间。 3. 缓存雪崩 由于缓存层承载着大量请求，能够有效地保护存储层，但是如果缓存层由于某些原因不能提供服务(比如超大并 发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问bigkey，导致缓存能支撑的并发急剧下降)，于是大量请求都会打到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。 预防和解决缓存雪崩问题，可以从以下三个方面进行着手。 1） 保证缓存层服务高可用性，比如使用 Redis Sentinel 或 Redis Cluster。 2） 依赖隔离组件为后端限流熔断并降级。比如使用 Sentinel 或 Hystrix 限流降级组件。比如服务降级，我们可以针对不同的数据采取不同的处理方式。当业务应用访问的是非核心数据（例如电商商 品属性，用户信息等）时，暂时停止从缓存中查询这些数据，而是直接返回预定义的默认降级信息、空值或是错误提示信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。 3） 提前演练。在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。 4. 热点缓存key重建优化 开发人员使用“缓存+过期时间”的策略既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。 但是有两个问题如果同时出现，可能就会对应用造成致命的危害：当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等。在缓存失效的瞬间， 有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。 要解决这个问题主要就是要避免大量线程同时重建缓存。我们可以利用互斥锁来解决，此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。 伪代码12345678910111213141516171819202122String get(String key) &#123; // 从Redis中获取数据 String value = redis.get(key); // 如果value为空，则开始重构缓存 if (value == null) &#123; String mutexKey = &quot;mutext:key:&quot; + key; // 只允许一个线程重建缓存，使用nx，并设置过期时间ex if (redis.set(mutexKey, &quot;1&quot;, &quot;ex 180&quot;, &quot;nx&quot;)) &#123; // 从数据源获取数据 value = db.get(key); // 回写Redis，并设置过期时间 redis.setex(key, timeout, value); // 删除key_mutex redis.delete(mutexKey); &#125; else &#123; // 其他线程休息50毫秒后重试 Thread.sleep(50); get(key); &#125; &#125; return value; &#125; 五、规范建议 1. key 设计 可读性和可管理性：以业务名(或数据库名)为前缀(防止 key 冲突)，用冒号分隔，比如 业务名:表名:id，不要包含特殊字符。 简洁性：保证语义的前提下，控制 key 的长度，当 key 较多时，内存占用也不容忽视。 2. value 设计 拒绝bigkey(防止网卡流量、慢查询) 在Redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存 储大约40亿个(2^32-1)个元素，但实际中如果下面两种情况，就可以认为它是bigkey。 字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey。 非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。反例：一个包含200万个元素的list。非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞）。 bigkey的危害： 导致redis阻塞 网络拥塞 bigkey也就意味着每次获取要产生的网络流量较大，假设一个 bigkey 为 1 MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB/s)的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例的方式来部署，也就是说一个 bigkey 可能会对其他实例也造成影响，其后果不堪设想。 过期删除 有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但它设置了过期时间，当它过期后，会被删除，如果没有使用 Redis4.0 的过期异步删除(lazyfree-lazy-expire yes)，就会存在阻塞Redis的可能性。 一般来说，bigkey 的产生都是由于程序设计不当，或者对于数据规模预料不清楚造成的，来看几个例子： (1) 社交类：粉丝列表，如果某些明星或者大v不精心设计下，必是bigkey。 (2) 统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。 (3) 缓存类：将数据从数据库 load 出来序列化放到 Redis 里，这个方式非常常用，但有两个地方需要注意。第一，是不是有必要把所有字段都缓存；第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个 key 下，产生 bigkey。 如何优化bigkey？ 拆 big list： list1、list2、…listN； big hash：可以讲数据分段存储，比如一个大的key，假设存了1百万的用户数据，可以拆分成 200 个key，每个key下面存放5000个用户数据 如果 bigkey 不可避免，也要思考一下要不要每次把所有元素都取出来(例如有时候仅仅需要 hmget，而不是 hgetall)，删除也是一样，尽量使用优雅的方式来处理。 选择适合的数据类型。 例如：实体类型(要合理控制和使用数据结构，但也要注意节省内存和性能之间的平衡) 正例反例1hmset user:1 name tom age 19 favor football123set user:1:age 19 3 set user:1:favor footballset user:1:name tom"},{"title":"数据库SQL","path":"/wiki/编程后花园/Database/index.html","content":"JDBC URL 参考 12345678910111213141516171819202122# db2 示例：jdbc:db2://localhost:50000/MYDB:user=dbadm;password=dbadm;# https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.apdv.java.doc/src/tpc/imjcc_r0052342.htmljdbc:db2://&lt;serverName&gt;[:&lt;portNumber&gt;]/&lt;databaseName&gt;[:&lt;key1&gt;=&lt;value&gt;;[&lt;key2&gt;=&lt;value2&gt;;]]# h2 示例：jdbc:h2:tcp://localhost/~/test,jdbc:h2:mem:myDB# https://h2database.com/html/features.html#database_urljdbc:h2:&#123; &#123;.|mem:&#125;[name] | [file:]fileName | &#123;tcp|ssl&#125;:[//]server[:port][,server2[:port]]/name &#125;[;key=value…​]# mariadb 示例：jdbc:mariadb://localhost:3306/testjdbc:mariadb:[replication:|failover:|sequential:|aurora:]//&lt;hostDescription&gt;[,&lt;hostDescription&gt;…​]/[database][?&lt;key1&gt;=&lt;value1&gt;[&amp;&lt;key2&gt;=&lt;value2&gt;]] hostDescription:: &lt;host&gt;[:&lt;portnumber&gt;] or address=(host=&lt;host&gt;)[(port=&lt;portnumber&gt;)][(type=(master|slave))]# mssql 示例：jdbc:sqlserver://localhost:1433;databaseName=AdventureWorks# https://docs.microsoft.com/en-us/sql/connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver?view=sql-server-2017jdbc:sqlserver://[serverName[\\instanceName][:portNumber]][;property=value[;property=value]]# oracle 示例：jdbc:oracle:thin:@localhost:1521/ORCL_SVC# https://docs.oracle.com/en/database/oracle/oracle-database/21/jjdbc/data-sources-and-URLs.html#GUID-AEA8E228-1B21-4111-AF4C-B1F33744CA08jdbc:oracle:driver_type:@database_specifier# pg 示例：jdbc:postgresql://localhost:5432/test# https://jdbc.postgresql.org/documentation/head/connect.htmljdbc:postgresql:[//][host][:port][/database][?key=value…​] SQL MySQL MySQL 中有一个辅助表可以用来使用 mysql.help_topic，该表有 159 个自增 help_topic_id，该表可以帮助处理行转列、查询连续的信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051-- 重置表 ID 从 1 开始自增; id_key 为自增 idalter table table_name drop id_key;alter table table_name add id_key int not null primary key auto_increment first;-- 增加递增列SELECT @rank:=@rank + 1 AS num FROM (SELECT @rank:=0) a-- 构建近 12 个月的月份虚拟表-- 注意：table_name 中的数据记录条数必须 &gt;= 12 SELECT DATE_FORMAT(@cdate := date_add( @cdate, INTERVAL - 1 MONTH ),&#x27;%Y-%m&#x27;) AS cdateFROM (SELECT @cdate := date_add(NOW(), INTERVAL 1 MONTH ) FROM table_name LIMIT 12) a ORDER BY cdate-- 构建近 30 天的天数虚拟表-- 注意：table_name 中的数据记录条数必须 &gt;= 30SELECT DATE_FORMAT(@cdate := date_add( @cdate, INTERVAL - 1 DAY ),&#x27;%Y-%m-%d&#x27;) AS cdateFROM (SELECT @cdate := date_add(now(), INTERVAL 1 DAY ) FROM table_name LIMIT 30) a ORDER BY cdate-- 构建近 30 天的日期虚拟表，此种写法 indexs 不能去掉，必须查询，适合有这种需求的使用-- 同样，table_name 中的数据记录条数必须 &gt;= 30SELECT @cdate := @cdate + 1 AS indexs,DATE_FORMAT( DATE( DATE_SUB( CURRENT_DATE, INTERVAL @s DAY ) ), &#x27;%Y-%m-%d&#x27; ) AS cdate FROM table_name, ( SELECT @cdate := -1 ) tempWHERE @cdate &lt; 30ORDER BY cdate-- 查询今天的数据SELECT * FROM table_name WHERE TO_DAYS(create_time) = TO_DAYS(NOW());-- 查询当前一周的数据 1 表示一周的第一天从星期一开始SELECT * FROM table_name WHERE YEARWEEK(DATE_FORMAT(create_time,&#x27;%Y-%m-%d&#x27;), 1) = YEARWEEK(NOW(), 1);-- 查询本月的数据SELECT * FROM table_name WHERE DATE_FORMAT(create_time, &#x27;%Y-%m&#x27;) = DATE_FORMAT(CURDATE(), &#x27;%Y-%m&#x27;);-- 查询最近七天的数据(当前日期往前推七天)SELECT a.cdate AS mdayFROM ( SELECT CURDATE() AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 1 DAY) AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 2 DAY) AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 3 DAY) AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 4 DAY) AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 5 DAY) AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 6 DAY) AS cdate) a LEFT JOIN ( SELECT DATE(create_time) AS c_time, other FROM table_name GROUP BY DATE(create_time)) b ON a.cdate = b.c_time ORDER BY mday; Oracle 1234567891011121314-- 补全一年 12 个月select lpad(level,2,0) from dual connect by level&lt;13select to_char(sysdate, &#x27;yyyy-&#x27;) || lpad(level, 2, 0) datevalue from dual connect by level &lt; 13;--oracle 未来12个月SELECT TO_CHAR(ADD_MONTHS(ADD_MONTHS(SYSDATE, 0), ROWNUM - 1), &#x27;YYYY-MM&#x27;) AS YEARMONTHFROM ALL_OBJECTSWHERE ROWNUM &lt;= 12;--oracle 前12个月SELECT TO_CHAR(ADD_MONTHS(SYSDATE, 1 - ROWNUM), &#x27;YYYY-MM&#x27;) AS YEARMONTHFROM ALL_OBJECTSWHERE ROWNUM &lt;= 12; hive、oracle、mysql内建函数对照表 PG 1234-- 生成指定的一段时间的连续日期，学了这个我感觉 MySQL5.7 是个什么垃圾！！！select to_char(cdate,&#x27;YYYY-MM-DD&#x27;) as date fromgenerate_series(to_timestamp(&#x27;2023-03-27&#x27;,&#x27;YYYY-MM-DD&#x27;), to_timestamp(&#x27;2023-04-01&#x27;,&#x27;YYYY-MM-DD&#x27;),&#x27;1 days&#x27;) as cdateorder by date PG 的 generate_series 函数可以学习一下，非常 nice：https://www.cnblogs.com/mchina/archive/2013/04/03/2997722.html"},{"title":"Java总结","path":"/wiki/编程后花园/Java/index.html","content":"浪子从事 Java 的总结，不知道起个什么名字，就叫 Java 总结吧！ Java21 Java17 Java 微服务组件 目前 Java 中有两套成熟的框架：一种是 Spring Cloud 整合的微服务工具集，另一种是阿里开源的 Spring Cloud Alibaba 微服务一站式解决方案。 当然也可以自己选择最适合自己项目的工具，因为上面的工具集也是使用单一的工具整合起来使用的。 单单服务间的远程调用就有很多解决方案，比如 RMI（Sun/Oracle）、Thrift（Facebook）、Dubbo（阿里巴巴）、gRPC（Google）、otan2（新浪）、Finagle（Twitter）、brpc（百度）、Arvo（Hadoop）、JSON-RPC、REST 等。 阿里系的微服务工具可以参看 spring-cloud-alibaba 的 github 的文章：https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/README-zh.md 1. 服务注册与发现中心组件(管理微服务的健康值状态) Eureka(Netflix) Consul(HashiCorp,GO语言编写)，启动后可以访问 ip:8500 进入管理页面 Nacos(Alibaba开源)，启动后可以使用 ip:8848 进入管理页面 Zookeeper(Apache,Java语言编写) 2. 服务间通信组件（远程调用） RestTemplate + Ribbon(NetFlix)实现负载均衡 OpenFeign(包含Ribbon)伪http客户端，支持Spring注解(推荐) Dubbo（阿里开源） RestTemplate 与 Openfegin 对比： RestTemplate 将路径写死在代码中，不利于维护。 Openfegin组件(内部集成了Ribbon)：解决了 RestTemplate 实现服务间通信的所有问题，并且使用简单，支持注解。 使用 OpenFeign 组件进行客户端的服务通信时，映射地址(@RequestMapping)和被调用的 FeignClient 的对应的方法映射地址必须相同；方法名称可以不同，但为确保一致性，推荐使用相同的方法名和相同的映射地址。 3. 服务熔断器组件（解决服务雪崩问题） Hystrix(进入了维护模式)以及对应的可视化展示工具 Hystrix DashBoard Sentinel（阿里开源） Hystrix 断路器打开条件： 当满足一定的阈值，默认10秒内超过20个请求 当失败率达到一定的时候，默认10秒内超过50%的请求失败 4. 服务网关中心组件（提供请求统一入口，路由转发，过滤） Gateway (转发、负载均衡、断言、过滤) zuul1.x zuul2.x Nacos（阿里开源） 5. 服务统一配置中心组件 config 组件： ConfigServer 获取远程仓库的地址存入本地仓库 ConfigClient 根据 ConfigServer 读取自身配置 bus 组件：消息总线：将微服务所有节点链接到一起，通过总线实现自动配置刷新 Nacos（阿里开源） 6. 事务组件 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 附 在使用 Spring Cloud Alibaba 时，可以参考官方的 版本选择说明。"},{"title":"Kotlin","path":"/wiki/编程后花园/Kotlin/index.html","content":"关于 Kotlin 入门的东西，官网教的还是比较好、比较全的： Kotlin官网https://kotlinlang.org/docs/basic-syntax.html 基础 同大多数编程语言一样，Kotlin 的程序入口也是 main() 函数。在 Kotlin 中，使用 val 声明不能修改的变量，var 声明可以修改的变量。 Kotlin 的类继承使用 : 声明，并且类默认是 final 的；想要该类被继承，使用 open 声明类： 12345open class Shapeclass Rectangle(val height: Double, val length: Double): Shape() &#123; val perimeter = (height + length) * 2&#125; Ktor Ktor 本质上是异步和非阻塞的。它允许应用程序同时处理多个请求，使其成为高流量应用程序的完美选择。这是通过利用 Kotlin 的协程来实现的，它简化了异步代码的编写，使其更具可读性和可维护性。此外，标准阻塞应用程序还允许同时处理多个请求，但是，它们不如非阻塞应用程序高效。它仅提供 Web 开发的基本要素，允许开发人员根据需要添加组件。这种极简主义方法可以缩短启动时间、降低资源消耗，并更好地控制应用程序的体系结构。 Ktor 遵循 Application 、 Routing 和 Call 的概念，使其成为构建 RESTful Web 服务的自然选择。 Application：应用程序是 Ktor 应用程序中的顶级组件。它负责管理应用程序的整个生命周期，包括启动和停止服务器。一个应用程序可以有多个模块和插件，用于定义应用程序行为的不同部分。 Routing：路由是任何 Web 框架的关键方面，而 Ktor 可以优雅地处理它。路由定义如何处理 HTTP 请求以及应为特定终结点执行哪些代码。开发人员可以创建与 HTTP 方法和 URL 模式匹配的复杂路由结构，从而轻松定义应用程序的行为。 Call：表示单个 HTTP 请求和响应。它包含有关请求的所有必要信息，例如标头、参数和请求正文。 CIO 是 Coroutine-based I/O 的缩写。通常，我们将其称为使用 Kotlin 和 Coroutines 实现 IETF RFC 或其他协议逻辑的引擎，而无需依赖基于 JVM 的外部库。CIO 是 Ktor 的 Engine 之一，跨平台，推荐使用。 不同的 Engine 支持不同的平台，可以参阅 官方文档 K2 https://blog.jetbrains.com/zh-hans/kotlin/2023/02/k2-kotlin-2-0/"},{"title":"认识 Kotlin 的作用域函数","path":"/wiki/编程后花园/Kotlin/认识Kotlin的作用域函数.html","content":"一、几个作用域函数 作用域函数 对象引用 返回值 是否扩展函数 let it Lambda result Yes run this Lambda result Yes run - Lambda result No：called without the context object with this Lambda result No：takes the context object as an argument. apply this Context object Yes also it Context object Yes 这些函数让 Kotlin 编程变得更简单、更快速，当然，副作用就是不太好理解。作用域函数本质上是类似的，每个作用域函数之间有两个主要区别： 它们引用上下文对象的方式。 它们的返回值。 各个函数的作用简洁描述如下： 在不可为 null 的对象上执行 lambda：let 将表达式作为局部作用域中的变量引入：let 对象配置： apply 对象配置和计算结果： run 在需要表达式的情况下运行语句：non-extension run 附加效果： also 对对象的函数调用进行分组： with let let 将 调用对象 作为参数，并返回 lambda 表达式的结果。Kotlin let 是一个范围函数，表达式内部声明的变量不能在外部使用。it 是 let 中的一个默认的属性。如下所示，let 中的最后一个值将作为参数返回。 1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123; val str = &quot;Kotlin is so simple!&quot; val length = str.let &#123; println(&quot;$it!!&quot;) it.length &#125; println(&quot;$&#123;str.length&#125;: $length&quot;) val a = 10 val b = 20 val result = a.let &#123; a + b &#125;.let &#123; it + 1 &#125; println(&quot;result is $result&quot;)&#125;// Kotlin is so simple!!!// 20// result is 31 run 与 let 函数类似，run 函数也返回最后一条语句。 与 let 不同，run 函数 不支持 it 关键字。 also also：顾名思义，also 表达式会对被调用的对象进行一些额外的处理。与 let 不同的是，它返回的是 原始对象。与 let 一样，代码块中也使用 it。 12345678910fun main(args: Array&lt;String&gt;) &#123; val a = 10 val b = 20 val result = a.also &#123; it + b + 5 &#125; println(&quot;result is $result&quot;)&#125;// result is 10 apply apply 是类型的扩展函数。它在表达式中的对象引用（也称为接收器）上运行，并在完成时返回对象引用。 with 与 apply 一样，with 用于更改实例属性，而无需每次都在引用上调用 . 运算符。 with 运行不需要对象，而 apply 需要； apply 在对象引用上运行，而 with 只是将其作为参数传递； with 函数的最后一个表达式返回结果。"},{"title":"编程小知识","path":"/wiki/编程后花园/Programming/index.html","content":"编程语言 我们都知道，计算机中的执行者 CPU 只认识二进制的 0 和 1 组成的序列，使用 0 和 1 组成的序列我们称之为 机器码。机器码 是计算机可以直接执行的。但是直接使用机器码编写 CPU 指令不仅费时费力，还特别容易出错，于是后来有了 汇编语言。简单概括的话，汇编语言类似于一种助记符，直接面对指令，将二进制指令替换成人类便于记忆的字符串，并给定特殊的格式。每一条汇编指令对应一条二进制指令。根据内核架构的不同，不同的指令有不同的长度和格式。 汇编语言是一种 低级 编程语言，它更接近机器代码或二进制。因此，它们对人类来说更难阅读（尽管它们仍然比 1 和 0 更容易理解）。低级语言的好处是它们速度快，并且可以精确控制计算机的运行方式。 高级编程语言则更接近人类的交流方式。高级语言使用的单词（如对象、顺序、运行、类、请求等）更接近我们在日常生活中使用的单词。这意味着它们比低级编程语言更容易编程，尽管它们确实需要更多时间才能翻译成计算机的机器代码。随着计算机变得越来越强大，低级和高级编程语言之间的运行时间差异通常只有几毫秒。因此，高级语言在大多数情况下都可以解决问题。 现在我们学的 C/C++、Rust、Python、Java、Go 等都是高级语言，编写起来要简单很多。不过这些高级语言中人们又将其分类细化：编译型语言和解释型语言。 编译语言的示例：C、C++、C#、CLEO、COBOL 等。 解释语言的示例：JavaScript，Perl，Python，BASIC 等。 编译型语言顾名思义就是需要经过编译器的编译之后才能执行，只要程序通过编译，便可以由目标机器（Windows、Linux等）直接执行；而解释型语言是通过解释器直接运行的，读取一行内容便解释一行，指令不是由目标机器直接执行的。 一般来说，编译型语言比解释型语言有着更好的性能。不过有的解释型语言的解释器实现、优化非常好，加上如今硬件的升级，性能与编译型语言不相上下。 说起编译型语言就不得不提到编译器，传统的编译器通常分为三个部分，前端（frontEnd），优化器（Optimizer）和后端（backEnd）。在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。常见的编译器有 GCC（GNU组织开发）、Clang、MSVC/Mingw 等。对了，要说明的是 Clang 的后端部分就是 LLVM。 MinGW 和 MSVC 为 Windows C/C++ 语言编译支持。 网络协议 网络协议就是为计算机网络中进行数据交换而建立的规则、标准或约定的集合。例如，Linux 约定使用 UTF-8 字符集编码。 其它还有 tcp、udp、http、https、ssh、ftp、dhcp 等等等等。协议是一种大家共同遵守的规范，只要遵守了该规范就可以实现跨系统、跨主机、跨平台访问、传输，如果你一套、我一套，调用的时候层层套，甚至根本就不能通信！那么网络也不会发展为如今这样。 可以读读这篇文章：https://www.cnblogs.com/fzz9/p/8964513.html 硬件相关 中央处理器架构 比较常见是 x86、x86_64/x64/amd64、aarch/arm、risc-v、mips 架构 说明 x86 intel32 位处理器(其实更像是指令集) ia32 Intel Architecture, 32-bit，缩写为IA-32，现在，IA-32一般又能引喻成所有的支持32位计算的 x86 架构。 x86_64/x64 intel64 位处理器，兼容 intel32 位处理器 amd64 AMD64 位处理器，和 intel64 位处理器相同，下载软件的时候看到 amd64 或者 x86_64 就是可以在 64 位处理器上运行的程序了 arm ARMv3 至 ARMv7 支持 32 位寻址空间，ARMv8-A开始支持 64 位寻址空间。aarch64 和 ARM64 都是指 64 位的 ARM 架构。 aarch 同上 1999年，AMD 公司首先在 IA-32 基础上，增加了 64 位寄存器，兼容早期的16位和32位软件系统，后来命名为 amd64。之后 intel 公司因为自身 IA-64（先于 amd64 研发，但是不兼容 IA-32，也不能直接运行在 x64 上，相当于是新的产品）的失败也接受了该方案，叫做 x86_64（Intel 的产品怎么能给 AMD 打广告呢）。操作系统厂商通常用 AMD64 或者 Intel64。 目前家用 PC 一般都是 x64，IA-64 价格昂贵，多用于服务器。 CISC（Complex Instruction Set Computer）：复杂指令集计算机，使用包含微码的相对高级或复杂硬件来实现相对大量指令的计算机。每条指令可执行若干低级操作，如内存访问、算术运算或地址计算。在第一代 RISC 处理器设计出来之前，许多计算机架构师都在试图弥合 “语义鸿沟”–通过提供 &quot;高级 &quot;指令（如存储过程调用和返回）、循环指令（如 “递减和非零则分支”）和复杂寻址模式（允许将数据结构和数组访问编译成单条指令）来设计支持高级语言的指令集。 虽然这些架构达到了允许用更少的指令来表达高级语言结构的目的，但据观察，它们并不总是能提高性能。例如，在一种处理器上，人们发现不使用过程调用指令，而使用一系列更简单的指令，就有可能提高性能。此外，指令集越复杂，指令解码的开销就越大，包括执行时间和硅片面积。对于使用微码来解码（宏）指令的处理器来说，情况尤其如此。用微码实现的复杂指令集比用硅片 &quot;硬连接 &quot;解码的指令集更容易调试。CISC 处理器的例子是摩托罗拉 680x0 家族和英特尔 80186 到英特尔 486 和奔腾。 RISC（Reduced Instruction Set Computer）：精简指令集计算机，其设计基于简单指令序列的快速执行，而不是基于提供大量复杂指令。 RISC设计中通常具有的特征是统一的指令编码（例如，操作码始终位于每个指令的相同位位置，该指令始终为一个字长），这允许更快的解码;非同构寄存器集，允许在任何上下文中使用任何寄存器，简化编译器设计;以及具有更复杂模式的简单寻址模式，被简单的算术指令序列所取代。 使用 RISC 处理器（或多或少）的例子有 Berkeley RISC、HP-PA、Clipper、i960、AMD 29000、MIPS R2000 和 DEC Alpha。IBM 的第一台 RISC 计算机是 RT/PC (IBM 801)，现在他们生产基于 RISC 的 RISC System/6000 和 SP/2 系列。 内存堆栈 栈：存储局部变量，大小在编译时已知，具有良好的内存局部性； 堆：存储动态分配的对象，大小在运行时确定，具有较高的灵活性； 所有分配在堆上的数据，都是通过一个在栈上的引用来访问的。 我们编写的程序都是需要占用内存来运行的。"},{"title":"数据结构-二叉树","path":"/wiki/编程后花园/Programming/数据结构-二叉树.html","content":"二叉排序树 二叉排序树（Binary sort tree）又称为二叉查找树、二叉搜索树。 二叉排序树可以是空树，或是满足以下性质的二叉树： 若其 左子树 非空，则左子树上的结点都 小于 根结点的值； 若其 右子树 非空，则右子树上的结点都 大于等于 根结点的值； 其左右子树本身也各是一棵二叉排序树。 含有 n 个结点的二叉排序树的平均查找长度和树的形态有关。 一个无序序列可以通过二叉排序树变成一个有序序列，构造树的过程就是对无序序列进行排序的过程。 平衡二叉树 Q: 如何提高形态不均衡的二叉排序树的查找效率？ A: 做 “平衡化” 处理，尽量让二叉树的形状均衡。 定义：又称 AVL 树（Adelson-Velskii and Landis） 一棵平衡二叉树或者是子树，或者是具有下列性质的二叉排序树： 1.左子树与右子树的高度之差的绝对值小于等于1； 2.左子树和右子树也是平衡二叉排序树。 为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF） 平衡因子 = 结点左子树的的高度 - 结点右子树的高度 根据二叉平衡树的定义，平衡二叉树上所有结点的平衡因子只能是-1、0 或 1。 对于一棵有 n 个结点的 AVL 树，其高度保持在 O(log2n)O(log_2n)O(log2​n) 数量级，ASL 也保持在 O(log2n)O(log_2n)O(log2​n) 量级。 失衡二叉树平衡调整的四种类型： 二叉树平衡调整 红黑树 红黑树是一种 自平衡 的排序二叉树。 五个性质： 每个节点非红即黑； 根节点总是黑色的； 每个叶子节点都是黑色的空节点（NIL节点）； 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）； 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。 为什么要用红黑树？ 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。"},{"title":"数据结构-堆","path":"/wiki/编程后花园/Programming/数据结构-堆.html","content":"大根堆 根节点是最大值，下面的左右节点不需要比较大小。 小根堆 根节点是最小值，下面的左右节点不需要比较大小。 上滤、下滤调整堆序型 实际应用中，可能出现不满足堆序型的情况。 添加时上滤 实际存堆的还是数组结构，逻辑结构是堆，实际结构是数组 时间复杂度高（堆元素数量很大） Netty HashWheelTimer Netty自己设计的一个定时任务（延迟队列）解决方案海量的定时任务 效率比 Timer 高 时间轮算法（TimeingWheel） Netty HashWheelTimer Dubbo Akka Kafka Quartz 没有排序过程：想像一下又一个圆，圆上均分 20 块，每块使用 双向链表 存储定时任务列表，到哪一块按顺序执行便可。 超时的解决方法 加入圈数 圈数太多，效率低 分层时间轮（Kafka） 时间轮算法在 Netty 中的体现"},{"title":"数据结构-散列表","path":"/wiki/编程后花园/Programming/数据结构-散列表.html","content":"一、Hash 冲突可以避免？ Hash 冲突是肯定存在的，但是可以 尽量 避免 散列均匀：元素远小于存储空间的时候，避免冲突，要有好的 hash 算法。 二、散列冲突的解决方法 为什么 Java 的 Map 使用了 16 个 Entry？ 2n2^n2n 可以使用 位运算 替换 模运算，速度比较快。 java 中 Hash 冲突（碰撞）的解决方法 链表的方式（1.7） 红黑树（1.8） 线性探测（ThreadLocalMap） 1. 开放定址法（开地址法） 1.1 线性探测法 1.2 二次探测法 散列函数： Hi=(Hash(key)+di)mod mH_i = (Hash(key) + d_i) \\mod m Hi​=(Hash(key)+di​)modm 其中，m 为散列表长度，m 要求是某个 4k+3 的质数；did_idi​ 为增量序列： 12,−12,22,−22,...,q21^2, -1^2, 2^2, -2^2, ..., q^2 12,−12,22,−22,...,q2 1.3 伪随机探测法 Hi=(Hash(key)+di)mod m(1=&lt;i&lt;m)H_i = (Hash(key)+d_i) \\mod m (1 =&lt; i &lt; m)Hi​=(Hash(key)+di​)modm(1=&lt;i&lt;m) 其中，mod 为散列长度，did_idi​ 为伪随机数。 2. 链地址法（拉链法） 基本思想：相同散列地址的记录链成一个单链表。 m 个散列地址就设 m 个单链表，然后用一个数组将 m 个单链表的表头指针存储起来，形成一个动态的结构。 散列表的装填因子 aaa：$$a = \\frac{表中填入的数据}{哈希表的长度}$$ 散列表技术具有很好的平均性能，优于一些传统的技术； 链地址法优于开地址法； 除留取余法作散列函数优于其它类型函数（取小于等于表长的一个质数）。"},{"title":"数据结构","path":"/wiki/编程后花园/Programming/数据结构.html","content":"对于数据结构的理解和学习，浪子建议扔掉自己掌握的语言的相关实现。所谓数据结构，是一种抽象化的存储数据的结构，它是一种抽象的概念，数据结构最最重要的是它的特性，特性决定了我们在开发中的选择，进而影响程序的运行效率和占用空间。学好数据结构的相关知识，开发中在合适的地方采用合适数据结构，能够让我们的程序更好的运行。 一、 线性表 顺序表 特点（随机存取） 顺序表优缺点 链表 特点（顺序存取） 链表优缺点 二、了解数据结构:链表 2.1 单链表 2.2 双链表 2.3 循环链表 三、栈 四、队列 五、字符串、数组、广义表 六、树 七、二叉树 7.1 二叉树性质 7.2 两种特殊的二叉树 （1） 满二叉树 （2） 完全二叉树 完全二叉树的性质 7.3 二叉树的存储结构 7.4 二叉树遍历方式 八、树和森林 8.1 树与二叉树的转换 将树转换成二叉树 将二叉树转换成树 8.2 森林与二叉树的转换 森林转为二叉树 二叉树转为森林 8.3 树的遍历 8.4 森林遍历 8.5 哈夫曼树（最优二叉树） 九、图 数据结构可以简单分为两大类：线性表，非线性表。 一、 线性表 线性表是具有相同特性的数据元素的一个有限序列。 (a1a_1a1​, a2a_2a2​, a3a_3a3​, a4a_4a4​, …, ana_nan​) n = 0 时为空表。 同一线性表中的元素必定具有 相同特性（编程语言中可视为同种数据类型），数据元素间的关系是线性关系。 特征： 在非空的线性表中，有且仅有一个开始结点 a1a_1a1​，它没有直接前驱，而是仅有一个直接后继 a2a_2a2​； 有且仅有一个终端结点 ana_nan​，他没有直接的后继，而仅有一个直接前驱 an−1a_{n-1}an−1​； 其余的内部结点 aia_iai​ (2&lt;=i&lt;=n−1)(2&lt;=i&lt;=n-1)(2&lt;=i&lt;=n−1) 都有且仅有一个直接前驱 ai+1a_{i+1}ai+1​ 和一个直接后继 ai−1a_{i-1}ai−1​。 顺序表 线性表采用 顺序存储 结构存储数据时称为 顺序表。 特点（随机存取） 以 物理位置相邻 表示逻辑关系。 顺序表优缺点 优点：1. 存储密度大；2. 可以随机存取表中任一元素。 缺点：1. 插入、删除时，需要移动大量元素；2. 浪费存储空间；静态存储形式，数据元素的个数不能自由扩充。 链表 线性表采用 链式存储 结构存储数据时称为 链表。链表分为单向链表，双链表，循环链表。 特点（顺序存取） 结点在存储器中是任意的，即逻辑上相邻的数据在物理上不一定相邻。 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个和最后一个结点所花费的时间不等。 链表优缺点 优点：逻辑上连续，物理上未必连续存储。有效利用碎片空间。插入、删除的效率高。 缺点：随机查找元素时效率不高，需要从头遍历所有元素。 二、了解数据结构:链表 术语名称 含义 数据域 存储元素数值数据。 指针域 存储直接后继结点的存储位置。 结点 数据元素的存储映像，由数据域和指针域两部分组成。 首元结点 链表中存储第一个数据元素的结点 头指针 指向链表中第一个结点的指针 头结点 链表的首元结点之前 附设 的一个结点。（处理方便） 链表分为 带头结点 的链表和 不带头结点 的链表。 加了头结点有什么好处？ 如果加了头结点，便于首元结点的处理。首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其它操作一致，无须进行特殊处理。 空表的表示和非空表也一样。 头结点的数据域内存储的什么？ 头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。 比如给出一组线性表数据：（赵，钱，孙，李，周，吴，郑，王） 顺序表表示(内存地址递增，连续空间)： 链表表示（每个结点出了数据还包括一个指向下一个结点指针域） 2.1 单链表 单链表：结点只有一个指针域的链表；指针域指向后继结点。 2.2 双链表 双链表：结点有两个指针域的链表，在单链表的每个结点再增加一个指向其前驱结点的指针域。 2.3 循环链表 首尾相接的链表称之为循环链表。从表中任一结点出发都可以找到表中的其它结点。 单向循环链表：是一种首尾相连的链表，在单链表中的尾结点的指针域指向头结点，整个链表形成一个环。 双向循环链表：在双向链表的尾结点的尾指针域指向头结点的头指针。 三、栈 只能在线性表的一端进行操作（添加/删除等），一般是在栈顶（线性表尾部）。 四、队列 在线性表的端点进行操作，一般是在队首删除，队尾插入。 五、字符串、数组、广义表 前两种略过，只讲广义表。 广义表（又称为列表），是 n&gt;=0n &gt;= 0n&gt;=0 个元素 a0,a1,a2,...,an _ 1a_0, a_1, a_2, ..., a_n~\\_~_1a0​,a1​,a2​,...,an​ _ 1​ 的有限序列，其中每一个 aia_iai​ 或者是原子，或者是一个广义表。 广义表通常记作：LS=(a1,a2,...,an)LS = (a_1, a_2, ..., a_n)LS=(a1​,a2​,...,an​)，习惯上，一般以 大写字母 表示广义表，小写字母 表示原子。 表头：若 LS 非空(n &gt;= 1)，则其 第一个 元素就是表头，记作 head(LS) = a1a_1a1​。 表尾：除表头以外的子表，记作 tail(LS) = (a2,a3,...,an)(a_2, a_3, ..., a_n)(a2​,a3​,...,an​)。 注意： 表头可以是原子，也可以是子表。 表尾不是一个元素，而是一个子表。表尾一定是一个表。 表 举例 A()A()A() 空表，长度为 0 B(())B(())B(()) 长度为 1，表头、表尾均为 () C(a,(b,c))C(a, (b, c))C(a,(b,c)) 长度为 2，由原子 a 和子表 (b, c) 构成，表头：a，表尾：((b, c))。 D(x,y,z)D(x, y, z)D(x,y,z) 长度为 3，每一项都为原子，表头为 x，表尾为 (y, z) E(C,D)E(C, D)E(C,D) 长度为 2，表头为 C，表尾为 (D) F(a,F)F(a, F)F(a,F) 递归/嵌套广义表，长度为 2，第一项为 a，第二项为它本身。表头为 a，表尾为 (F)。 F=(a,(a,(...)))F = (a, (a, (...)))F=(a,(a,(...)))。 广义表的性质 广义表中的数据元素有相对次序，一个直接前驱和一个直接后继。 广义表的长度定义为最外层所包含的元素个数。如 C=(a,(b,c))C=(a, (b, c))C=(a,(b,c)) 是长度为 2 的广义表。 广义表的深度定义为该广义表展开后所含括号的层数；A=(b,c)A = (b, c)A=(b,c) 的深度为 1，B=(A,d)B = (A, d)B=(A,d) 的深度为 2，C=(f,B,h)C = (f, B, h)C=(f,B,h) 的深度为 3。注意： 原子的深度为 0，“空表”的深度为 1。 广义表可以和其它广义表共享。比如 A=(b,c)A = (b, c)A=(b,c)，B=(A,d)B = (A, d)B=(A,d)，表 B 就共享了表 A。 广义表可以是一个递归的表，比如：F=(a,(a,(...)))F = (a, (a, (...)))F=(a,(a,(...)))。递归表的深度是无穷的，但长度是有限的。 广义表是多层次的结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表，…。 例：D=(E,F),E=(a,(b,c)),F=(d,(e))D = (E, F), E = (a, (b, c)), F = (d, (e))D=(E,F),E=(a,(b,c)),F=(d,(e)) 图形表示(方框代表 原子，圆圈代表 子表)： 广义表可以看成是线性表的推广，线性表是广义表的特例。 广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。 当二维数组的每行（或每列）作为子表处理时，二维数组即为一个广义表。 另外，树和有向图也可以用广义表来表示。 由于广义表不仅集中了线性表、数组、树和有向图等常见的数据结构的特点，而且可以有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的案例。 广义表的基本运算：求表头、表尾 六、树 树型结构是一种非线性的数据结构，结点有分支，具有一定的层次关系。 树是n(n&gt;=0)个结点的有限集。 n=0时为空树； n&gt;0时，则它满足如下两个条件： 有且仅有一个特定的称为根的结点； 其余结点可分为 m(m&gt;=0) 个互不相交的有限集 T1,T2…Tm，其中每一个集合本身又是一棵树，并称为根的子树（SubTree）。显然，树是一个 递归 的定义。 树的其它表示方式 名词术语 术语名称 解释 结点 数据元素以及指向子树的分支 根结点 非空树中无前驱结点的结点 结点的度 结点拥有的子树数（子树的个数/分支数/直接后继结点数） 数的度 树内各结点的度的最大值 叶子结点/终端结点 度=0 分支结点/非终端结点 度 != 0 内部结点 不是根结点和叶子结点的其它结点 兄弟结点 拥有共同双亲结点的结点 树的深度/高度 树中结点的最大层次 有序树：树中结点的各子树从左到右有次序（最左边的为第一个孩子） 无序树：树中各结点无序。 森林：m（m&gt;=0）棵互不相交的树的集合。 一棵树可以看成一个特殊的森林：把根结点删除就变成了森林；给森林中的各子树加上一个双亲结点，森林就变成了树。 例如：把下面的根结点 A 删除就成了森林，把 B、C、D 三颗树加上双亲结点 A 就成了一棵树。 树一定是森林，森林不一定是树。 七、二叉树 每个结点最多有两个孩子（二叉树中不存在度大于2的结点） 子树有左右之分，其次序不能颠倒。 二叉树可以是一个空集，根可以有空的左子树或空的右子树。 二叉树不是树的特殊情况，它们是两个概念。 二叉树必须要区分左、右子树，即便只有一棵子树也要区分。 树的结点只有一个孩子时，就无须区分它是左还是右的次序。这是二叉树和树的最主要的区别。 虽然二叉树与树概念不同，但有关书的基本术语对二叉树都适用。 为何要重点研究二叉树（每个结点最多只有两个“叉”的树）？ 普通树如过不转为二叉树，则它的结构很复杂，运算很难实现。 二叉树结构最简单，规律性最强； 可以证明，所有的树都能转化为唯一对应的二叉树，不失一般性。 二叉树在树结构的应用中起着非常重要的作用，因为对二叉树的许多操作算法简单，而任何树都可以和二叉树相互转换，这样就解决了树的存储结构及其运算中存在的复杂性。 7.1 二叉树性质 在二叉树的第 i 层上至多有 2i − 12^i~^-~^12i − 1 个结点（i &gt;= 1）;第i层上至少有 1 的结点。 深度为 k 的二叉树至多有 2k2^k2k - 1 个结点(k &gt;= 1)。至少有 k 个结点。 对任何一颗二叉树 TTT，如果其叶子数为 n0n_0n0​ ,度为2的节点数为 n2n_2n2​，则 n0n_0n0​ = n2n_2n2​ + 1 性质 4、5 需要先学习两种特殊的二叉树。 7.2 两种特殊的二叉树 （1） 满二叉树 定义：深度为k且有 2k2^k2k - 1 个结点的二叉树（可以视为性质 2 特例）。 特点 每层上的结点数都是最大结点数（每层都满）。 叶子结点全部在最底层。 对满二叉树结点位置进行编号，编号规则： 自根结点开始，自上而下，从左至右。 每一个结点位置都有元素。 满二叉树在同样深度的二叉树中 结点 个数最多 满二叉树在同样深度的二叉树中 叶子结点 个数最多 （2） 完全二叉树 定义：深度为 k 的具有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号为 1 ~ n 的结点一一对应时，称为完全二叉树。 从满二叉树中从最后一个结点开始，连续 的去掉任意个结点，即是一个完全二叉树。 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。 特点： 叶子结点只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为 i，则其左子树的最大层次必为 i 或 i+1。 完全二叉树 完全二叉树的性质 具有 n 个结点的完全二叉树的深度为 log2n+1log_2n + 1log2​n+1。 如果对一棵树有 n 个结点的完全二叉树，深度为 log2n+1log_2n + 1log2​n+1 的结点按层序编号（从第一层到第 log2n+1log_2n + 1log2​n+1 层，每层从左到右），则对任一结点i（1&lt;= i &lt;=n），有： 1）如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1，则其双亲是结点 i/2; 2）如果 2i &gt; n，则结点 i 为叶子结点，无左孩子；否则，其左孩子是结点2i； 3）如果 2i+1 &gt; n，则结点 i 无右孩子；否则，其右孩子是结点 2i+1。 性质 4 表明了完全二叉树 结点数 n 与完全二叉树 深度 k 之间的关系。 性质 5 表明了完全二叉树中 双亲结点 编号与 孩子结点 编号之间的关系。 7.3 二叉树的存储结构 二叉树的顺序存储：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。（使用数组放在对应的下标位置） 存储结构 如果该二叉树不是一棵完全二叉树，那么还是按照这个方法，在没有元素的位置存储 空 或者 0。这样保证了数据能够恢复。 顺序存储的缺点：定长；如果空数据较多，浪费空间。 顺序存储适于存储满二叉树和完全二叉树。 二叉树的链式存储：一个结点包括三个要素，一个数据域和两个指针域，一个指针指向左孩子，一个指针指向右孩子。 二叉树的链式存储结构 在结点数为 n 的二叉链表中，空指针域有 n+1 个。 三叉链表：在二叉链表的基础上增加一个指向双亲的指针域，由一个数据域和三个指针域构成。 7.4 二叉树遍历方式 先序遍历DLR：访问根结点D，先序遍历左子树L，先序遍历右子树R 中序遍历LDR：中序遍历左子树L，访问根D，中序遍历右子树R 后序遍历LRD：后序遍历左子树L，后序遍历右子树R，访问根D 二叉树的层次遍历：从根结点开始按从上到下、从左到右的顺序去遍历，每个结点仅访问一次。 如果同时确定了先序、中序序列或者同时确立了后序、中序序列，那么就可以 唯一的确定 这棵二叉树结构。 线索二叉树（基于链式二叉树）： 如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱； 如果某个结点的右孩子为空，则将空的右孩子指针域改为指向其后继。 这种改变指向的指针称为“线索”。加上了线索的二叉树称为线索二叉树。 在线索二叉树中，为了区分指针域是指向前驱还是后继，在结点中又添加了两个标记域 ltag、rtag，值为 1 代表指针域指向前驱；值为 0 代表指向后继。 八、树和森林 树的双亲表示法，定义结构数组，存放树的结点，每个结点含两个域：数据域 存放结点本身信息，双亲域 指示本结点的双亲在数组中的位置。 特点：找双亲容易，找孩子难。 孩子链表： 把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。 孩子链表 特点：找孩子容易，找双亲难。 把两种方法结合，在数据的前面加入一个域存储双亲的位置下标。称为带双亲的孩子链表。 带双亲的孩子链表 孩子兄弟表示法（二叉树表示法，二叉链表表示法） 实现：用二叉链表作树的存储结构，链表中的每个结点的两个指针域。分别指向其第一个孩子结点和下一个兄弟结点。 孩子兄弟表示法 特点：找孩子、兄弟容易，找双亲难。 8.1 树与二叉树的转换 将树转换为二叉树： 由于树和二叉树都可以用 二叉链表 作存储结构，则以二叉链表为媒介可以导出树与二叉树之间的一个对应关系。 给定一棵树，可以找到唯一的一棵二叉树与之对应。如下图（最右边为转换后的二叉树） 二叉树转换 将树转换成二叉树 将树转换为二叉树 1、加线：在兄弟之间加一连线； 2、抹线：对每个结点，除了其左孩子之外，去除其与其余孩子之间的关系； 3、旋转：以树的根结点为轴心，将其整树顺时针旋转45°。 树变二叉树口诀：兄弟相连留长子。 将二叉树转换成树 将二叉树转换为树 1、加线：若 p 结点是双亲孩子的左孩子，则将 p 的右孩子，右孩子的右孩子……沿分支找到的所有右孩子，都与 p 的双亲用线连起来； 2、抹线：抹掉原二叉树中双亲与右孩子之间的连线； 3、调整：将结点按层次排列，形成树结构。 二叉树变树口诀：左孩右右连双亲，去掉原来右孩线。 8.2 森林与二叉树的转换 森林转为二叉树 森林转换为二叉树 1、将各棵树分别转换成二叉树； 2、将每棵树的根结点用线相连； 3、以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构。 森林变二叉树口诀：树变二叉根相连。 二叉树转为森林 二叉树转为森林 1、抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树； 2、还原：将孤立的二叉树还原成树。 二叉树变森林口诀：去掉全部右孩线，孤立二叉再还原。 8.3 树的遍历 先根遍历：先访问根结点，然后依次先跟遍历各子树。 后根遍历：先依次后根遍历各棵子树，然后访问根结点。 层次遍历：自上而下自左至右访问树中每个结点。 8.4 森林遍历 将森林看作由三部分构成： 1、森林中第一棵树的根结点； 2、森林中第一棵树的子树森林； 3、森林中其它树构成的森林。 先序遍历： 1、访问森林中的第一棵树的根结点； 2、先序遍历森林中的第一棵树的子树森林； 3、先序遍历森林中（除第一棵树外）其余树构成的树林。 即：依次从左至右对森林中的每一棵树进行先根遍历。 中序遍历： 1、中序遍历森林中的第一棵树的子树森林； 2、访问森林中的第一棵树的根结点； 3、中序遍历森林中（除第一棵树外）其余树构成的树林。 即：依次从左至右对森林中的每一棵树进行后根遍历。 后序遍历： 8.5 哈夫曼树（最优二叉树） 路径：从树种一个结点到另一个结点之间的分支构成两个结点间的路径。 结点的路径长度：两个结点间路径上的分支数。 树的路径长度：从树根到每一个结点的路径长度之和。记作 TL。 权：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。 结点的带权路径长度：从根结点到该结点之间的 路径长度 与该结点的权的乘积。 树的带权路径长度：树中所有叶子结点的带权路径长度之和。 哈夫曼树：最优树 就是带权路径长度最短的树。注意：带权路径长度最短是在 “度相同” 的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。 哈夫曼树：最优二叉树，带权路径长度最短的二叉树 相应的算法（构造哈夫曼树的方法）称为哈夫曼算法。 满二叉树不一定是哈夫曼树；具有相同带权路径长度的哈夫曼树不唯一。 哈夫曼树中权越大的叶子离根越远。 哈夫曼树的结点的度数为0或2，没有度为1的结点。 包含n个叶子结点的哈夫曼树中共有 2n-1 个结点。 包含 n 棵树的森林要经过 n-1 次合并才能形成哈夫曼树，共产生 n-1 个新结点。 哈夫曼树中共有 2n-1 个结点，且其所有分支结点的度都不为1。 结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。 九、图 G=(V,E) V：顶点的有穷非空集合 E：边的又穷集合 有向图：每条边都有方向 无向图：每条边都没有方向 完全图：任意连个点都有一条边相连。 n 个顶点，n(n-1)/2 条边。 稀疏图：有很少边或弧的图（e &lt; nlogn) 稠密图：有很多边或弧的图 网：边/弧带权的图 邻接：有边/弧相连的两个顶点之间的关系 关联（依附）：边/弧与顶点之间的关系 顶点的度：与该顶点相关联的边的数目 在有向图中，顶点的度等于该顶点的入度和出度 路径：接续的边构成的顶点序列 路径长度：路径上边/弧的数目/权值之和 环：第一个顶点和最后一个顶点相同的路径 简单路径：除路径的起点和终点相同，其余顶点都不相同的路径 连通图（强连通图） 在无（有）向图 G=(V, {E}) 中，若对任意两个顶点v、u都存在从 v 到 u 的路径，则称 G 是连通图（强连通图）。 权与网 图中边或弧所具有的相关数称为权。表明一个顶点到另一个顶点的距离或耗费。 带权的图称为网 子图：设有两个图 G=(V, {E}), G1=(V1, {E1})，若 V1 V, E1 E，则 G1 是 G 的子图。 连通分量：无向图G的极大连通子图称为G的连通分量 极大连通图的意思是：该子图是 G 连通子图，将 G 的任何不在该子图中的顶点加入，子图不在连通。 有向图G的极大连通子图称为G的强连通分量 极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通。 生成树：包含无向图G所有顶点的极小连通子图 生成森林：对非连通图，由各个连通分量的生成树的集合 本笔记只记录了一些图的术语，没有其他讲解。图的应用是非常多的，尤其是在关系模型中，体现尤为明显。 注： 本文截图来源于 B 站视频《数据结构与算法基础（青岛大学-王卓）》视频中的内容，由 87师兄 分享。 视频地址：https://www.bilibili.com/video/BV1nJ411V7bd"},{"title":"基础排序算法","path":"/wiki/编程后花园/Programming/算法-基础排序算法.html","content":"基础算法说明，不涉及算法的书写实现，只整理算法的操作思想，以及复杂度比较。 排序 排序的稳定性只对 结构类型数据 的排序有意义。 1. 插入排序 基本思想：每步将一个待排序的对象，按其有关键码大小，插入到前面已经排好序的一组对象的适当位置上，知道对象全部插入为止。 基本操作：有序插入。在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 1.1 直接插入排序：采用顺序查找法查找插入位置。 直接插入排序，可以使用 “哨兵”。 原始数据越接近有序，排序速度越快。最坏情况下（数据逆序排序）。 实现排序的基本操作有两个，“比较” 序列中两个关键字的大小， “移动”。如果要提高查找速度，减少元素的比较次数和移动次数。 1.2 折半插入排序：二分法 减少了比较次数，不能减少移动次数。平均性能优于直接插入。 1.3 希尔排序：缩小增量，多遍插入排序 特点： - 一次移动，移动位置较大，跳跃式的接近排序后的最终位置。 - 最后一次只需要少量移动。 - 增量序列必须是递减的，最后一个必须是1. - 增量序列必须是互质的。 如何选择最佳 d 序列，目前尚未解决；最后一个增量必须是1，无除了1之外的公因子；不宜在链式存储结构上实现。 2. 交换排序 基于交换思想的排序。 2.1 冒泡排序 冒泡排序比较简单，但是效率较低。 n 个记录，总共需要 n-1 趟。第 m 趟需要比较 n-m 次。 2.2 快速排序 基本思想：通过一趟排序，将待排序记录分割成独立的两部分，其中的部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序。 具体实现：选定一个中间数作为参考，所有元素与之比较，小的调到其左边，大的调到其右边。中间数（枢轴） 可以是第一个数、最后一个数、最中间一个数、任选一个数等。 快速排序不是原地排序。由于程序中使用了递归，需要递归调用栈的支持，而栈的长度取决于递归调用的深度（即使不用递归，也需要使用用户栈）。 在平均情况下：需要 O(logn) 的栈空间。 最坏情况下：栈空间可达 O(n)。 快速排序是一种不稳定的排序。快排不适用于对基本有序或原本有序的记录序列进行排序（越乱越快）。 3. 选择排序 3.1 简单选择排序 基本思想：在待排序的数据中选出最大（小）的元素放在其最终的位置。 基本实现 首先通过 n-1 次关键字比较，从 n 个记录中找出关键字 最小 的记录，将它与第一个记录交换。 再通过 n-2 次比较，从剩余的 n-1 个记录中找出关键字 次小 的记录，将它与第二个记录交换。 重复以上操作，共进行 n-1 趟排序后，排序结束。 时间复杂度 移动次数 最好情况：已经排好序，移动次数为 0 最坏情况：逆序，每次都需要交换，移动次数为 3(n-1) 比较次数：无论待排序序列是什么状态，选择排序所需进行的 “比较” 次数都相同。 算法稳定性：简单选择排序是不稳定排序。 3.2 堆排序 堆的定义：若 n 个元素的序列 {a1,a2,...,an{a_1, a_2, ..., a_n}a1​,a2​,...,an​} 满足 ai&lt;=a2ia_i &lt;= a_{2i}ai​&lt;=a2i​， ai&lt;=a2i+1a_i &lt;= a_{2i+1}ai​&lt;=a2i+1​ 或者 ai&gt;=a2ia_i &gt;= a_{2i}ai​&gt;=a2i​， ai&gt;=a2i+1a_i &gt;= a_{2i+1}ai​&gt;=a2i+1​。则分别称该序列 {a1,a2,...,an{a_1, a_2, ..., a_n}a1​,a2​,...,an​} 为 小根堆 和 大根堆。 从堆的定义可以看出，堆实质是满足如下性质的 完全二叉树 ：二叉树任一非叶子结点均小于（大于）它的孩子结点。 堆排序：若在输出 堆顶 的最小值（最大值）后，使得剩余 n-1 个元素的序列重又建成一个堆，则得到 n 个元素的次小值（次大值）……如此反复，便得到一个有序序列，这个过程称之为 堆排序。 实现堆排序需解决两个问题： 如何由一个无序序列建成一个堆？ 单节点的二叉树是堆。 如何在输出堆顶元素后，调整剩余元素为一个新的堆？ 对一个无序序列反复 “筛选” 就可以得到一个堆，即：从一个无序序列建堆的过程就是一个反复 “筛选” 的过程。 初始化所需时间不超过O(n) 排序阶段（不含初始化） - 一次重新堆化所需时间不超过O(logn) - n-1 次循环所需时间不超过O(nlogn) 堆排序的时间主要耗费在建初始堆和调整建新堆时进行的反复 “筛选” 上。堆排序在最坏情况下，其时间复杂度也为 O(nlog2n)O(nlog_2n)O(nlog2​n)，这是堆排序的最大优点。无论待排序列中的记录是正序还是逆序排列，都不会使堆排序处于 “最好” 或 “最坏” 的状态。 4. 归并排序 基本思想：将两个或两个以上的有序子序列 “归并” 为一个有序序列。 4.1 2-路归并排序 在内部排序中，通常采用的是 2-路归并排序。即：将两个位置相邻的有序子序列 R[l…m] 和 R[m+1…n] 归并为一个有序序列 R[l…n]。 时间效率：O(nlog2n) 空间效率：O(n) 因为需要一个与原始序列同样大小的辅助空间。 归并排序是一个 稳定 的算法。 5. 基数排序 基本思想：分配+收集 也叫 桶排序 或 箱排序，设置若干个箱子，将关键字为 k 的记录放入第 k 个箱子，然后再按序号将非空的连接。 基数排序：数字是有范围的，均有 0-9 这十个数字组成，则只需设置十个箱子，相继按个、十、百…进行排序。 例如 {614, 738, 921, 485, 637, 101, 215, 530, 790, 306} 6. 外部排序 7. 各种排序方法比较 排序方法 最好时间复杂度 最坏时间复杂度 平均时间复杂度 空间复杂度 稳定性 直接插入排序 O(nnn) O(n2n^2n2) O(n2n^2n2) O(1) 稳定 直接插入排序 O(n2n^2n2) O(n2n^2n2) O(n2n^2n2) O(1) 稳定 希尔排序 O(nnn) O(n2n^2n2) ~O(n1.3n^{1.3}n1.3) O(1) 不稳定 冒泡排序 O(nnn) O(n2n^2n2) O(n2n^2n2) O(1) 不稳定 快速排序 O(nlognnlognnlogn) O(n2n^2n2) O(nlognnlognnlogn) O(nlognnlognnlogn) 不稳定 直接选择排序 O(n2n^2n2) O(n2n^2n2) O(n2n^2n2) O(1) 不稳定 堆排序 O(nlognnlognnlogn) O(lognlognlogn) O(nlognnlognnlogn) O(n2n^2n2) 不稳定 归并排序 O(nlognnlognnlogn) O(nlognnlognnlogn) O(nlognnlognnlogn) O(n) 稳定 基数排序 O(n+mn+mn+m) O(k∗(n+m)k*(n+m)k∗(n+m)) O(k∗(n+m)k*(n+m)k∗(n+m)) O(n+m) 稳定 7.1 时间性能 按平均的时间性能来分，有三类排序方法 时间复杂度为 O(nlogn) 的方法有： 快速排序、堆排序和归并排序，其中以快速排序为最好。 时间复杂度为 O(n^2) 的有： 直接插入排序、冒泡排序和简单选择排序，其中以直接插入为最好，特别是对那些对关键字近似有序的记录序列尤其如此。 时间复杂度为 O(n) 的排序方法只有：基数排序 当待排记录序列按关键字顺序有序时，直接插入排序和冒泡排序能达到O(n)的时间复杂度；而对于快速排序而言，这是最不好的情况，此时的时间性能退化为 O(n2)O(n^2)O(n2)，因此是应该尽量避免的情况。 简单选择排序、堆排序、归并排序的时间性能不随记录序列中关键字的分布而改变。 7.2 空间性能 指的是排序过程中所需的辅助空间大小 所有的简单排序方法（包括：直接插入、冒泡和简单选择）和堆排序的空间复杂度为 O(1)O(1)O(1)。 快速排序为 O(logn)O(logn)O(logn)，为栈所需的辅助空间。 归并排序所需辅助空间最多，其空间复杂度为 O(n)O(n)O(n)。 链式基数排序需附设队列首尾指针，则空间复杂度为 O(rd)O(rd)O(rd)。 7.3 稳定性 稳定的排序方法是指：对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。 当对多关键字的记录序列进行 LSD 方法排序时，必须采用稳定的排序算法。 对于不稳定的排序方法，只要能举出一个实例说明即可。 快速排序和堆排序是不稳定的排序方法。 关于排序方法的时间复杂度的下限 以上的几种排序方法，除基数排序外，其它方法都是基于 “比较关键字” 进行排序的排序方法，可以证明，这类排序法可能达到的最快的时间复杂度为 O(nlogn)O(nlogn)O(nlogn)。基数排序不是基于 “比较关键字” 的排序方法，所以它不受这个限制。 可以用一棵判定树来描述这类基于 “比较关键字” 进行排序的排序方法。"},{"title":"设计模式-单例模式","path":"/wiki/编程后花园/Programming/设计模式-单例模式.html","content":"单例模式 介绍 优点：节约内存和保证共享计算的结果正确，以及方便管理。 应用： 全局信息类：例如任务管理器对象，或者需要一个对象记录整个网站的在线流量等信息。 无状态工具类：类似于整个系统的日志对象，我们只需要一个单例日志对象负责记录，管理系统日志信息。 写法 单例模式有 8 种，很多时候存在 饿汉式单例 以及 懒汉式单例 的概念。 饿汉式单例： 在获取单例对象之前对象已经创建完成了。 懒汉式单例： 在真正需要单例对象的时候才创建出该对象。 写法很多，给出一种推荐写法，推荐面试使用： 12345678910111213141516171819202122/*** 双重检查，延迟加载*/public class Singleton01 &#123; // volatile 保证指令不会重排序和可见性 private volatile static Singleton01 INSTANCE = null; private Singleton01() &#123; &#125; public static Singleton01 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Singleton01.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton01(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 为什么静态成员变量要加上 volatile 关键字呢？ 解释该问题之前，我们需要知道 Java 创建对象的步骤： a.分配内存空间 b.调用构造器，初始化实例 c.返回地址给引用 在这几步中，底层可能进行对象创建的重排序操作，b、c 步骤在执行的过程中会互换： a.分配内存空间 b.返回地址给引用（此时静态变量已经不为null了，对象还没有初始化） c.调用构造器，初始化实例 如果不使用 volatile 关键字，可能会发生指令重排序。下面使用 A、B 线程举例。 线程A： 1.分配内存空间 2.返回地址给引用 3.调用构造器，初始化实例 线程B： 认为静态变量不为null，直接得到对象的内存地址。但是该对象还没有初始化完成，如果线程B使用该对象去操作，会出现部分值缺失（NPE）。 所以为了确保线程安全，我们需要加上该关键字。 静态内部类单例模式 基于类的初始化实现延迟加载和线程安全的单例设计。 JVM 在类的初始化阶段（即在Class被加载后，且线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM 会获得一个锁，这个锁可以同步多个线程对同一个类的初始化。基于这个特性，可以实现另一种线程安全的延迟初始化方案。 123456789101112131415161718public class Singleton02 &#123; private Singleton02() &#123; &#125; // 静态内部类 private static class InnerClass &#123; // JVM 在类的初始化阶段（即在Class被加载后，且线程使用之前），会执行类的初始化。 // 在执行类的初始化期间，JVM 会获得一个锁，这个锁可以同步多个线程对同一个类的初始化。 // 基于这个特性，可以实现另一种线程安全的延迟初始化方案。 private static final Singleton02 INSTANCE = new Singleton02(); &#125; public static Singleton02 getInstance() &#123; return InnerClass.INSTANCE; &#125;&#125; 静态内部类是在被调用时才会被加载，这种方案实现了懒汉单例的一种思想，需要用到的时候才去创建单例，加上JVM的特性，这种方式又实现了线程安全的创建单例对象。 通过对比基于 volatile 的双重检查锁定方案和基于类的初始化方案的对比，我们会发现基于类的初始化的方案的实现代码更为简洁。但是基于 volatile 的双重检查方案有一个额外的优势： 除了可以对静态字段实现延迟加载初始化，还可以对实例字段实现延迟初始化。 枚举实现单例 枚举实际上是一种多例的模式，如果我们只定义一个实例就是单例了。 123456public enum Singleon03 &#123; INSTANCE; public void whatever() &#123; ... &#125;&#125; 枚举是 Java 提供的一种特性，已经实现了线程安全机制。 枚举实现单例只是一种实现策略，或者面试的回答方案，实际开发中通常不使用该方式。通常被用来作为信息的标志和分类。"},{"title":"设计模式-策略模式","path":"/wiki/编程后花园/Programming/设计模式-策略模式.html","content":"单例模式 介绍 优点：节约内存和保证共享计算的结果正确，以及方便管理。 应用： 全局信息类：例如任务管理器对象，或者需要一个对象记录整个网站的在线流量等信息。 无状态工具类：类似于整个系统的日志对象，我们只需要一个单例日志对象负责记录，管理系统日志信息。 写法 单例模式有 8 种，很多时候存在 饿汉式单例 以及 懒汉式单例 的概念。 饿汉式单例： 在获取单例对象之前对象已经创建完成了。 懒汉式单例： 在真正需要单例对象的时候才创建出该对象。 写法很多，给出一种推荐写法，推荐面试使用： 12345678910111213141516171819202122/*** 双重检查，延迟加载*/public class Singleton01 &#123; // volatile 保证指令不会重排序和可见性 private volatile static Singleton01 INSTANCE = null; private Singleton01() &#123; &#125; public static Singleton01 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Singleton01.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton01(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 为什么静态成员变量要加上 volatile 关键字呢？ 解释该问题之前，我们需要知道 Java 创建对象的步骤： a.分配内存空间 b.调用构造器，初始化实例 c.返回地址给引用 在这几步中，底层可能进行对象创建的重排序操作，b、c 步骤在执行的过程中会互换： a.分配内存空间 b.返回地址给引用（此时静态变量已经不为null了，对象还没有初始化） c.调用构造器，初始化实例 如果不使用 volatile 关键字，可能会发生指令重排序。下面使用 A、B 线程举例。 线程A： 1.分配内存空间 2.返回地址给引用 3.调用构造器，初始化实例 线程B： 认为静态变量不为null，直接得到对象的内存地址。但是该对象还没有初始化完成，如果线程B使用该对象去操作，会出现部分值缺失（NPE）。 所以为了确保线程安全，我们需要加上该关键字。 静态内部类单例模式 基于类的初始化实现延迟加载和线程安全的单例设计。 JVM 在类的初始化阶段（即在Class被加载后，且线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM 会获得一个锁，这个锁可以同步多个线程对同一个类的初始化。基于这个特性，可以实现另一种线程安全的延迟初始化方案。 123456789101112131415161718public class Singleton02 &#123; private Singleton02() &#123; &#125; // 静态内部类 private static class InnerClass &#123; // JVM 在类的初始化阶段（即在Class被加载后，且线程使用之前），会执行类的初始化。 // 在执行类的初始化期间，JVM 会获得一个锁，这个锁可以同步多个线程对同一个类的初始化。 // 基于这个特性，可以实现另一种线程安全的延迟初始化方案。 private static final Singleton02 INSTANCE = new Singleton02(); &#125; public static Singleton02 getInstance() &#123; return InnerClass.INSTANCE; &#125;&#125; 静态内部类是在被调用时才会被加载，这种方案实现了懒汉单例的一种思想，需要用到的时候才去创建单例，加上JVM的特性，这种方式又实现了线程安全的创建单例对象。 通过对比基于 volatile 的双重检查锁定方案和基于类的初始化方案的对比，我们会发现基于类的初始化的方案的实现代码更为简洁。但是基于 volatile 的双重检查方案有一个额外的优势： 除了可以对静态字段实现延迟加载初始化，还可以对实例字段实现延迟初始化。 枚举实现单例 枚举实际上是一种多例的模式，如果我们只定义一个实例就是单例了。 123456public enum Singleon03 &#123; INSTANCE; public void whatever() &#123; ... &#125;&#125; 枚举是 Java 提供的一种特性，已经实现了线程安全机制。 枚举实现单例只是一种实现策略，或者面试的回答方案，实际开发中通常不使用该方式。通常被用来作为信息的标志和分类。 策略模式 策略模式也是非常常用的一种模式，使用策略模式可以轻松扩展第三方服务，非常适合 if 比较多的情况。为什么这么说呢？主要是它和模板模式比较像，这样说区别比较明显。 顾名思义，策略模式使用时至少有两种不同的策略（简单理解为两个 if），所以当根据多个不同的条件走不同的分支时非常灵活，而且方便扩展。策略模式是符合开闭原则的。 模式举例 以快递举例吧，比如我国有很多的快递公司：京东、韵达、圆通、中通、申通等等。当你的系统集成这些服务时，在用户下单的时候，需要根据条件去选择不同的快递，每家快递的收费情况、运输质量等也是不同的。如果使用 if-else-if 会有大段大段的代码块，后期根据快递公司的业务变动维护自己的系统要改一些地方，这时候就比较头疼了。 这个时候就可以考虑使用策略模式，定义通用的方法在一个接口中，然后为每家快递公司创建一个类去实现这个接口，为每家快递公司编写自己的实现就可以了。 说到这里，你可能觉得它和模板模式很类似。所以接下来说说区别。 模板方法通常是抽象模板，里面通常包含两部分：通用的算法实现；留给子类实现的抽象方法。 策略模式一般使用接口提供，由具体的实现类编写处理逻辑，提供算法。 可以看到，模板方法模式一般只针对一套算法，对同一套算法的不同实现细节进行抽象；而策略模式对多种算法进行不同的实现，所以策略模式相比模板模式更加灵活，算法与算法之间一般没有冗余代码。 策略模式的关注点更广，模板模式的关注点更深。它们不能相互替换，但可以组合使用。"},{"title":"Rust","path":"/wiki/编程后花园/Rust/Rust.html","content":"Rust 官方文档https://doc.rust-lang.org/stable/book/ 一、安装 Linux Linux 安装非常简单，只需要一行命令： Window 下载 Microsoft C++ Build Tools，勾选 C++ 环境和自己的操作系统的 SDK，如下图所示。 安装的文件比较大，建议手动选择安装位置，避免占用过多系统盘。等待安装完成后，然后找到程序安装的位置：%Visual Studio 安装位置%\\Microsoft Visual Studio\\2022\\BuildTools\\VC\\Tools\\MSVC\\%version%\\bin\\Hostx64\\x64，把该值添加到环境变量中。 %Visual Studio 安装位置%、%version% 需要替换自己的安装路径和对应的版本号。 以上工作完成后就可以下载 RUST-INIT 并双击运行，默认回车等待安装完毕。 由于 crates.io 的下载速度较慢，我们需要使用国内的源来下载第三方库。编辑文件 $HOME/.cargo/config，如果没有该文件，手动创建即可。 使用稀疏索引： ~/.cargo/config123456[source.crates-io]registry = &quot;https://github.com/rust-lang/crates.io-index&quot;replace-with = &#x27;bfsu&#x27;[source.bfsu]registry = &quot;sparse+https://mirrors.bfsu.edu.cn/crates.io-index/&quot; 不使用稀疏索引： ~/.cargo/config12345[source.crates-io]replace-with = &#x27;bfsu&#x27;[source.bfsu]registry = &quot;https://mirrors.bfsu.edu.cn/git/crates.io-index.git&quot; Rust 一些命令 Rust 自带了非常完善的工具链：Cargo，Cargo 是 Rust 的构建系统和包管理器。 虽然 Cargo 的部分命令可以使用 rustc 来代替（你可以把 cargo 看作是 rustc 的高级封装），但是一旦涉及到依赖管理或者其它高级使用的问题，rustc 就相形见绌了，本文不详细介绍 rustc 的相关命令，这里放一个链接：https://doc.rust-lang.org/rustc/what-is-rustc.html，有需要自行查看。 Cargo 命令 Cargo 官方文档https://doc.rust-lang.org/cargo/index.html Cargo中文教程https://www.rustwiki.org.cn/zh-CN/cargo 123456789101112131415161718# cargo 帮助cargo --help# 查看 Rust 版本cargo --version# 创建新的 hello_cargo 项目cargo new hello_cargo# 初始化当前的目录为 Rust 项目cargo init# 构建项目cargo build# 构建并运行项目cargo run# 检查代码，确保其可编译但不生成可执行文件（速度快）cargo check# 运行项目中的测试cargo test# 构建项目文档，并直接打开文档cargo doc --open cargo 将构建的二进制执行文件放在 target/debug 目录中，与项目同名. 当你的项目准备发布时，建议使用 cargo build --release 进行优化，这些优化使你的 Rust 代码运行得更快，但会延长程序编译所需的时间。此命令将在 target/release 中创建可执行文件. 如果要对代码的运行时间进行基准测试，请务必运行 cargo build --release 并使用 target/release 中的可执行文件进行基准测试. 执行命令时，cargo 会检查代码中未使用的变量和方法并输出警告。如果这些变量和方法需要临时保留，同时不想让编译器给出警告，可以在未使用的变量和方法上加入 _ 前缀。另外还有一些注解辅助禁止警告。 #[warn(dead_code)] 标注可以消除编译器对于没有用到的代码的警告； #[warn(unused_imports)] 标注可以消除对已经导入但未使用包的警告； 版本更新 12345# 更新 Rust 版本rustup update# 使用国内源更新RUSTUP_DIST_SERVER=https://mirrors.bfsu.edu.cn/rustup rustup install stable Rust 的依赖管理 Rust 项目的文件管理清单都在 Cargo.toml 中，该清单包括项目基本信息（例如作者、仓库地址、rust版本等）、依赖（包括构建依赖、开发依赖等）等信息。如果你还不熟悉 Toml 的配置方式，可以学习一下，比较简单。 Rust 的依赖搜索可以去 crates.io 中查询，类似与 Maven 的中央仓库。 截至目前，新建的 Rust 项目中的 Cargo.toml 中默认包含以下信息： Cargo.toml12345678910# 项目的描述信息[package]name = &quot;hello_cargo&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html# 依赖[dependencies] 初步简单认识 cargo workspace 如果所构建的项目较大，那么可以使用 cargo workspace。和多模块有点儿类似。 以 rust_parent 为例，作为顶级目录，父母录中的 Cargo.toml 配置子包的目录名称即可。 1cargo new rust_parent &amp;&amp; cd rust_parent 然后打开 Cargo.toml 文件，删除所有内容，添加以下内容： Cargo.toml1234567[workspace]# 子包目录名称members = [ &quot;sub1&quot;, &quot;....&quot;,] 然后我们创建子包： 1cargo new sub1 之后运行 cargo build 目录应如下所示： 12345678── rust_parent ├── Cargo.lock ├── Cargo.toml ├── sub1 │ ├── Cargo.toml │ └── src │ └── main.rs └── target 无论有多少 crate，都只会在顶层目录的 target 中输出二进制文件。 如果要单独运行某个包中的程序，使用 cargo run -p [package]，例如 cargo run -p sub1。 二、Rust 命名规则 任何一门编程语言，都有对应的命名规范，开发时遵守规范利于他人阅读、维护。Rust 也不例外。命名规则参考 Rust 语言圣经：https://course.rs/practice/naming.html 三、初步认识 Rust 的标准库小而稳定，只提供语法特性，扩展较强，所以大部分时候都要使用 cargo 引入并管理依赖，cargo 也支持自定义扩展命令也是因此。 Rust 的生态很多内容都是通过社区提供支持的。 Rust 中，只有实现了 std::fmt::Display trait 的自定义 struct 才可以自定义输出格式并且可以使用 &#123;&#125; 进行占位。如果使用 #[derive(Debug)] 进行标注，则使用 &#123;:?&#125; 或者 &#123;:#?&#125; 美化输出。 Rust 中的属性定义和方法是分离的，方法或者函数放置在 impl 块中，便于维护、格式清晰。如下代码： 12345678910111213141516171819202122232425// 自定义结构体，实现 Debug trait 以便于使用 &#123;:?&#125; 进行打印输出#[derive(Debug)]struct Person &#123; name: String, age: i32, address: String, hobby: Vec&lt;String&gt;&#125;// 自定义类型结构体的方法impl Person &#123; fn say(&amp;self) -&gt; Self&#123; todo!() &#125; // 这种定义在 impl 中且没有 self 的函数被称之为关联函数 fn dance() &#123; todo!() &#125;&#125;fn add(a: &amp;str, b: &amp;str) &#123;&#125; self 是当前的类型实例，Self 指代当前的类型，这是一种简单的编写方式。 在 Rust 中，如果方法返回类型不是 Self，并且没有包含泛型，使用这样的特征创建的对象被称为 安全的特征对象。 Rust 函数的每一个引用参数都有自己的生命周期；如果函数只有一个引用类型的参数，那么该生命周期会同步作用到输出生命周期；若存在多个输入生命周期，且其中一个是 &amp;self 或 &amp;mut self，则 &amp;self 的生命周期被赋给所有的输出生命周期。 函数或者方法中，参数的生命周期被称为 输入生命周期，返回值的生命周期被称为 输出生命周期 Rust 智能指针 名称 简介 强项 弱项 Raw Point *mut T 和 *const T，自由基，闪电般快，极其 unsafe 速度、与外界交互 Unsafe Box&lt;T&gt; 可以把任何东西都放在 Box 中。可接受几乎任何类型的长期存储。新的安全编程时代的主力军 将值存在 Heap 大小增加 Rc&lt;T&gt; 是 Rust 的能干而吝啬的簿记员。他知道谁借了什么，何时借了什么 对值的共享访问 大小增加；运行时不安全；线程不安全 Arc&lt;T&gt; 是 Rust 的大使。它可以跨线程共享值，保证这些值不会相互干扰。 对值的共享访问；线程安全 大小增加；运行时成本； Cell&lt;T&gt; 变态专家，具有改变不可变值的能力 内部可变性； 大小增加；性能； RefCell&lt;T&gt; 对不可变引用执行改变，但有代价 内部可变性；可与仅接受不可变引用的 Rc、Arc 嵌套使用； 大小增加；运行时成本；缺乏编译时保障； Cow （Copy on write） 封闭并提供对借用数据的不可变访问，并在需要修改或所有权时 延迟克隆数据 当只是只读访问时避免写入； 大小可能会增大； String 处理可变长度的文本，展示了如何构建安全的抽象 动态按需增长；在运行时保证正确编码； 过度分配内存大小； Vec&lt;T&gt; 程序中最常用的存储系统，它在创建和销毁值时保持数据有序 动态按需增长； 过度分配内存大小； RawVec&lt;T&gt; 是 Vec 和其它动态大小类型的基石，知道如何按需给你的数据提供一个家 动态按需增长；与内存分配器一起配合寻找空间； 不直接适用于您的代码； Unique&lt;T&gt; 作为值的唯一所有者，可保证拥有完全控制权 需要独占值的类型（如 String）的基础 不适合直接用于应用程序代码； Shared&lt;T&gt; 分享所有权很难，但它使生活更轻松。 共享所有权；可以将内存与 T 的宽度对齐，即使为空的时候； 不适合直接用于应用程序代码； Drop Trait，智能指针的必备特征之一。 四、Rust 流行库 serde 序列化库； reqwest 网络请求库； tokio 异步运行时；"},{"title":"Rust 异步编程","path":"/wiki/编程后花园/Rust/Rust异步编程.html","content":"Async 官方文档https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html Rust 中的 Async Future是惰性的。只有 poll 时才能取得进展；被丢弃的 future 就无法取得进展了 Async 是零成本的。可以无需堆内存分配（heap allocation）和动态调度（dynamic dispatch），对性能较好，且允许在受限环境使用 async 不提供内置运行时，运行时由社区提供 单线程、多线程均支持，但优缺点不同 Rust 中的 async 和 thread OS线程： 适用于少量任务，有内存和CPU开销，且线程生成和线程间切换非常昂贵 线程池可以降低一些成本 允许重用同步代码，代码无需大改，无需特定编程模型 有些系统支持修改线程优先级 Async : 显著降低内存和CPU开销 同等条件下，支持比线程多几个数量级的任务（少数线程支撑大量任务） 可执行文件大（需要生成状态机，每个可执行文件捆绑一个异步运行时） Async 并不比线程好，只是不同而已。 虽然 Rust 本身就支持 async 编程，但很多应用依赖于社区的库： 标准库提供了最基本的特性、类型和功能，例如 Future trait async/await 语法直接被 Rust 编译器支持 futures crate 提供了许多实用类型、宏和函数。它们可以用于任何异步应用程序。 异步代码、IO 和任务生成的执行由 async runtimes 提供，例如 Tokio 和 async-std。大多数 async 应用程序和一些 async crate 都依赖于特定的运行时。 Rust trait 不支持 async。 兼容性说明 async和同步代码不能总是自由组合。例如：不能直接从同步函数来调用异步函数。async 代码间也不总是能自由组合。一些 crate 依赖于特定的 async 运行时。因此，尽早研究确定使用哪个 async 运行时。"},{"title":"NodeJs","path":"/wiki/编程后花园/Web/NodeJs.html","content":"NodeJs Node文档http://nodejs.cn/learn/ 一、常用命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# node versionnode -v# 后台启动 推荐使用 pm2nohup 脚本命令 &amp;# 查看npm版本npm -v# 全局安装npm install &lt;package-name&gt; -g# 所在项目安装npm install &lt;package-name&gt;# 更新单个指定包npm update &lt;package-name&gt;# 更新所有可以更新的包npm update# 卸载npm uninstall &lt;package-name&gt;# 搜索npm search &lt;package-name&gt;# 查看全局安装模块信息，不带 -g 代表查询项目模块下安装的所有模块信息npm list -gnpm ls# 列出全局安装的模块 带上 --depth 0 不深入到包的支点 更简洁npm list -g --depth 0# 查看 npm 配置npm config list# 检查过时的依赖npm outdated# 设置全局包依赖镜像地址npm config set registry https://registry.npmmirror.com# 回退npm到指定版本npm install npm@6.14 -g# 查看某个包的版本npm view &lt;package-name&gt; version# 升级npm到最新版本npm install npm -g# 显示 npm install -g 全局安装的位置npm root -g # 移除项目未使用的模块npm prune npm install 可简写为 npm i npm run 相关：除了 npm run start 和 npm run test，其它的命令都不能省略 run。 二、Yarn npm 是 Node 自带的包管理工具，使用起来很方便。也可以使用 yarn，yarn 是 facebook 发布的一款取代npm的包管理工具，详情可以查询yarn官网介绍 12345678910# 安装 yarn 包管理工具npm install -g yarn# 查看 yarn 版本yarn --version# 查询源yarn config get registry# 更换国内源yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 三、pnpm pnpm 是微软发布的一款 Node 平台的包管理工具，该工具默认使用 npm 的安装源。 官方文档https://pnpm.io/ 四、其它问题 node 版本较高时某些策略会导致 vue 项目运行不起来，编辑项目的 package.json 文件，在运行命令中添加以下内容： 12345...&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve&quot;, &#125;,..."},{"title":"TypeScript 入门","path":"/wiki/编程后花园/Web/TypeScript.html","content":"更加完善的 TS 教程：https://ts.xcatliu.com/ 基本类型 number、NaN（Not a Number） string boolean undefined null unknown any void 虽然 Any 和 unknown 都可以表示不确定的类型，但是 Any 是可以添加对象参数属性的，而 unknown 则不能。 ts 中尽量少用 Any。 1234567891011121314151617let p1: any = &#123;&#125;p1.name = &#x27;江湖浪子&#x27;let p2: unknown = &#123;&#125;// 报错// p2.name = &#x27;&#x27;// 都可以修改值let p3: any = &quot;金风玉露一相逢&quot;p3 = &quot;便胜却人间无数&quot;let p4: unknown = &quot;千里姻缘一线牵&quot;p4 = 2.36console.log(p1);console.log(p2);console.log(p3);console.log(p4); 联合类型 命名变量时使用 | 作为分隔符，写为其它类型，对该变量赋值时可以使用这几种类型的任何一种。 12let p1: number|string = 123let p2: number|string = &quot;诗酒趁年华&quot; 类型断言 将不确定的类型断言为确定的类型，类似 Java 中的强转。 有时，我们需要获取特定类型中的属性，返回值若是联合类型或者 Any，则该属性无法正常获取，编译会报错，这时我们可以采取以下方式： 1234567// 方式一let img = document.getElementById(&quot;#xxx&quot;) as HTMLImageElementimg.src = &quot;&quot;// 方式二let img = &lt;HTMLImageElement&gt;document.getElementById(&quot;#xxx&quot;)img.height 数组类型 数组一般都是同类型的。 杂乱数组/泛型数组 数组中有多种不同类型的元素。 12let arr1: any[] = [&quot;仰天大笑出门去&quot;, 9981, false]let arr2: (string|number|boolean)[] = [true, &quot;123&quot;, 456] 多维数组 1let arr: number[][] = [[1], [12]] 还有另一种写法，但是不够通用，这里略过。 类数组 元组 元组的优点是防止越界。 123456let arr1: [number, string, boolean] = [1, &quot;true&quot;, false]console.log(arr1[0]);console.log(arr1[1]);console.log(arr1[2]);// 报错// console.log(arr1[3]); 接口 接口定义类信息，类似 Java 中的 class，存在只读属性、可选属性，默认属性必须选择。 1234567891011121314151617181920interface UserInfo &#123; // 只读属性，不能修改 readonly id: number name: string age: number // ? 可选属性 address?: string like?: string[]&#125;let user: UserInfo = &#123; name: &quot;jhlz&quot; age: 18&#125;user.name = &quot;江湖浪子&quot;user.address = &quot;上下五千年&quot;// 报错// user.id = 2console.log(user);console.log(user.name); 接口中定义方法 12345678910111213141516171819202122interface UserInfo &#123; name: string age?: number // 定义函数 getName: () =&gt; string setAge: (age: number) =&gt; void&#125;let user: UserInfo = &#123; name: &quot;江湖浪子&quot;, getName() &#123; return this.name &#125;, setAge(age) &#123; this.age = age &#125;&#125;user.setAge(18)console.log(user);console.log(user.name); 继承 123456789101112131415interface User &#123; // 1 男 2 女 gender: number&#125;interface UserInfo extends User &#123; name: string age?: number&#125;let user: UserInfo = &#123; name: &quot;江湖浪子&quot;, // 必须给 gender 赋值 gender: 1&#125; 接口交叉类型 123456789101112131415161718interface User &#123; // 1 男 2 女 gender: number&#125;interface UserInfo &#123; name: string age?: number // 1 男 2 女，把这里的 number 改为其它类型将报错 gender: number&#125;let user: UserInfo &amp; User = &#123; name: &quot;江湖浪子&quot;, gender: 1&#125;console.log(user); 交叉类型仅合并属性，而不处理属性的值或类型。如果两个接口中的相同属性具有不同的类型，代码将会报错。如果需要处理相同属性类型不同的情况，可以使用联合类型或其他适当的方法来处理。 类型别名 这个简单常用，给某些类型、函数定义别名，也可以用来定义对象。 定义对象 123456789101112type infoType = &#123; readonly id : number name: string age?: number address?: string&#125;let info: infoType = &#123; id: 1, name: &quot;江湖浪子&quot;&#125;console.log(info); interface 可以继承，type 不可以，只可以使用交叉类型； interface 遇到重复命名的会自动合并；而 type 不会（直接报错）；（实际项目中基本不会这样使用） 定义函数 12345678// 定义函数类型type fn = (para1: number, para2: number) =&gt; numberlet sum: fn = (num1: number, num2: number) =&gt; num1 + num2let diff: fn = (num1: number, num2: number) =&gt; num1 - num2console.log(sum(1, 2));console.log(diff(10, 3)); 枚举 默认为数字枚举，并且从 0 开始增长，如果中间中断，那往下会继续从中断的地方自动增长。 123456789enum Color &#123; RED, BLUE, GREEN, YELLOW = 10000, BLACK&#125;console.log(Color.RED); // 0console.log(Color.BLACK); // 10001 字符串枚举 12345678enum Color &#123; RED=&quot;red&quot;, BLUE=&quot;blue&quot;, GREEN=&quot;green&quot;, // 支持混合枚举，这里提一下 // YELLOW = 10000&#125;console.log(Color.RED); 接口枚举 1234567891011121314151617interface ColorInterface &#123; color: Color, blue: Color.BLUE&#125;enum Color &#123; RED, BLUE, GREEN, YELLOW = 10000, BLACK&#125;let c: ColorInterface = &#123; color: Color.RED, blue: Color.BLUE&#125;console.log(c); const 枚举 123456789101112131415161718interface ColorInterface &#123; color: Color, blue: Color.BLUE&#125;const enum Color &#123; RED, BLUE, GREEN, YELLOW = 10000, BLACK&#125;let c: ColorInterface = &#123; color: Color.RED, blue: Color.BLUE&#125;console.log(c); 主要作用就是节省因为枚举带来的资源消耗。 例如上面的接口枚举 ts 代码编译后如下： 12345678910111213var Color;(function (Color) &#123; Color[Color[&quot;RED&quot;] = 0] = &quot;RED&quot;; Color[Color[&quot;BLUE&quot;] = 1] = &quot;BLUE&quot;; Color[Color[&quot;GREEN&quot;] = 2] = &quot;GREEN&quot;; Color[Color[&quot;YELLOW&quot;] = 10000] = &quot;YELLOW&quot;; Color[Color[&quot;BLACK&quot;] = 10001] = &quot;BLACK&quot;;&#125;)(Color || (Color = &#123;&#125;));var c = &#123; color: Color.RED, blue: Color.BLUE&#125;;console.log(c); 而使用 const 枚举编译后： 12345var c = &#123; color: 0 /* Color.RED */, blue: 1 /* Color.BLUE */&#125;;console.log(c); 泛型 泛型的好处大家也都了解，每种语言基本都会提供泛型，使用方式也都差不多。先声明后使用。 12345678910111213141516171819202122232425262728293031function array&lt;T&gt;(a: T, b: T):T[] &#123; return [a, b]&#125;function array&lt;T extends string&gt;(a: T, b: T): T[] &#123; console.log(a.length); return [a, b]&#125;function array&lt;T, E&gt;(a: T, b: E):(T|E)[] &#123; return [a, b]&#125;interface User &#123; name: string age: number&#125;let user: User = &#123; name: &quot;江湖浪子&quot;, age: 18&#125;// 泛型约束：T 只能是 User 接口中的属性function getValue&lt;T extends keyof User&gt;(u: User, key: T): User[T] &#123; console.log(u[key]); return u[key]&#125;getValue(user, &quot;age&quot;) 内置对象 ECMAScript DOM 常见的 html 标签都在 HTMLElementTagNameMap 接口中。 Location Storage localStorage sessionStorage document.cookie（string 类型） tsconfig.json 生成该文件的命令：tsc -init 该文件的说明可以查阅 官网，也可以百度网上查询，都有很多详解。下面也是从网上找的部分常用的配置项说明： 12345678910111213141516171819202122232425262728293031&#123; // ... &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;ES6&quot;, // 目标语言的版本 &quot;module&quot;: &quot;ES6&quot;, // 生成代码的模板标准 // &quot;outFile&quot;: &quot;./app.js&quot;, // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;, &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;, &quot;allowJs&quot;: true, // 允许编译器编译JS，JSX文件 &quot;checkJs&quot;: true, // 允许在JS文件中报错，通常与allowJS一起使用 &quot;outDir&quot;: &quot;./dist&quot;, // 指定输出目录 &quot;rootDir&quot;: &quot;./&quot;, // 指定输出文件目录(用于输出)，用于控制输出目录结构 &quot;removeComments&quot;:true, // 删除注释 &quot;strict&quot;: true, // 开启所有严格的类型检查 &quot;alwaysStrict&quot;: true, // 在代码中注入&#x27;use strict&#x27; &quot;noImplicitAny&quot;: true, // 不允许隐式的any类型 &quot;strictNullChecks&quot;: true, // 不允许把null、undefined赋值给其他类型的变量 &quot;strictFunctionTypes&quot;: true, // 不允许函数参数双向协变 &quot;strictPropertyInitialization&quot;: true, // 类的实例属性必须初始化 &quot;strictBindCallApply&quot;: true, // 严格的bind/call/apply检查 &quot;noImplicitThis&quot;: true, // 不允许this有隐式的any类型 &quot;noUnusedLocals&quot;: true, // 检查只声明、未使用的局部变量(只提示不报错) &quot;noUnusedParameters&quot;: true, // 检查未使用的函数参数(只提示不报错) &quot;baseUrl&quot;: &quot;./&quot;, // 解析非相对模块的基地址，默认是当前目录 &quot;paths&quot;: &#123; // 路径映射，相对于baseUrl // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置 &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery.min.js&quot;] &#125;, &#125;&#125; 声明文件 d.ts 声明全局的变量和函数等 123declare var Hello:stringdeclare function getValue&lt;T&gt;(param : T):string 装饰器 装饰器是 ES7 提出的实验性功能，默认是关闭的，可以使用以下选项进行开启： tsconfig.json12&quot;experimentalDecorators&quot;: true,&quot;emitDecoratorMetadata&quot;: true 类装饰器 在不改变原有代码的前提下，实现在原有逻辑前后增加功能。 12345678910111213141516171819202122232425262728const app: ClassDecorator = (fn) =&gt; &#123; console.log(fn) fn.prototype.userName = &quot;江湖浪子&quot;&#125;@appclass User &#123;&#125;let u = new User()console.log((u as any).userName)// 函数柯里化const app = (str: string): ClassDecorator =&gt; &#123; return (fn) =&gt; &#123; fn.prototype.userName = str fn.prototype.getUserName = () =&gt; &#123; console.log(fn.prototype.userName) &#125; &#125;&#125;@app(&quot;jhlz&quot;)class User &#123;&#125;let u = new User()console.log((u as any).userName)"},{"title":"Web","path":"/wiki/编程后花园/Web/index.html","content":"Web 知识 颜色值 颜色值由十六进制来表示红、绿、蓝（RGB）。 每个颜色的最低值为 0(十六进制为 00)，最高值为 255(十六进制为FF)。十六进制值的写法为 # 号后跟三个或六个十六进制字符。三位数表示法为：#RGB，转换为6位数表示为：#RRGGBB。 除此之外，你可能还见过 0x 开头的，这代表一个十六进制的数值，这样的颜色表示形式常用在代码中，例如 Android 的 Color。 转换也比较简单，以 #9ACD32 为例，它的一般数字表示形式就是 0xFF9ACD32。只需要前面加上两个 FF 即可，表示透明。"},{"title":"Java Flight Recording","path":"/wiki/编程后花园/Java/JVM/JFR.html","content":"JFR JFR（Java Flight Recorder）是Java虚拟机（JVM）提供的一个性能监控和故障诊断工具。它的主要作用是收集、记录并分析Java应用程序在运行时的性能数据。JFR在Java 7 Update 40及更高版本中被引入，并在Java 11及以后的版本中成为开源项目。 123456789# 程序启动的时候启动 JFR 功能java -XX:StartFlightRecording xxx.jarjava -XX:StartFlightRecording:filename=/path/foo.jfr,dumponexit=true# 已经启动的程序使用 JFRjcmd pid JFR.startjcmd pid JFR.dump filename=foo.jfr maxsize=50MB JFR View 12jfr view [view] [recording file]jcmd [pid] JFR.view [view] JFR 视图命令的初始版本中提供了 70 多种不同的视图选项，将来可能会增加。每个视图都提供了从应用程序级别到 JVM 再到环境的整个堆栈的不同视角。 123456789101112131415161718192021222324252627282930Java virtual machine views: class-modifications gc-concurrent-phases longest-compilations compiler-configuration gc-configuration native-memory-committed compiler-phases gc-cpu-time native-memory-reserved compiler-statistics gc-pause-phases safepoints deoptimizations-by-reason gc-pauses tlabs deoptimizations-by-site gc-references vm-operations gc heap-configuration Environment views: active-recordings cpu-information jvm-flags active-settings cpu-load native-libraries container-configuration cpu-load-samples network-utilization container-cpu-throttling cpu-tsc recording container-cpu-usage environment-variables system-information container-io-usage events-by-count system-processes container-memory-usage events-by-name system-properties Application views: allocation-by-class exception-count native-methods allocation-by-site file-reads-by-path object-statistics allocation-by-thread file-writes-by-path pinned-threads class-loaders finalizers socket-reads-by-host contention-by-address hot-methods socket-writes-by-host contention-by-class latencies-by-type thread-allocation contention-by-site longest-class-loading thread-count contention-by-thread memory-leaks-by-class thread-cpu-load exception-by-message memory-leaks-by-site thread-start exception-by-site modules 如下示例： 1$ jfr view thread-count [recording-file] 有几个选项可以修改从 JFR 视图返回的数据的格式： 1234--width [number-of-columns]--cell-height [number of rows]--verbose--truncate beginning 需要在视图之前提供这些选项，如以下示例所示： 123456789$ jfr view --width 40 thread-count recording.jfrOutput: Java Thread StatisticsTime Acti... Daem... Accu... Peak...------- ------- ------- ------- -------21:4... 26 22 145 34"},{"title":"JVM","path":"/wiki/编程后花园/Java/JVM/JVM.html","content":"JVM 简单理解就是运行 Java 等语言的“操作系统”，没有 JVM，Java 程序就无法运行，JVM 自己“设计”了一套适合自己使用的内存结构。本篇文章就来整理一下，没有用到的就不写进来了，用过的或者学习的整理进来。 一、JVM内存模型 JVM内存模型图 方法区和堆是所有线程共享的内存区域；而Java虚拟机栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。 Java堆（Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有 线程共享 的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 元空间（Meta Space）/方法区（Method Area），方法区（Method Area）与Java堆一样，是各个 线程共享 的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。当线程发生切换时，记录上次线程挂起的位置，之后线程切换回来的时候，继续从上次记录的位置开始执行。 虚拟机栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈（Native Method Stacks），本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK8以前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。 但现在回头来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。 考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。 以上内容摘自 《深入理解Java虚拟机第二版》 周志明 JNI（Java Native Interface） JNI 是 Java Native Interface 的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C和C++）。 JNI 的适用场景：当我们有一些旧的库，已经使用C语言编写好了，如果要移植到Java上来，非常浪费时间，而JNI可以支持Java程序与C语言编写的库进行交互，这样就不必要进行移植了。或者是与硬件、操作系统进行交互、提高程序的性能等，都可以使用JNI。需要注意的一点是需要保证本地代码能工作在任何Java虚拟机环境。 一旦使用 JNI，Java 程序将丢失了 Java 平台的两个优点： 1、程序不再跨平台，要想跨平台，必须在不同的系统环境下程序编译配置本地语言部分。 2、程序不再是绝对安全的，本地代码的使用不当可能会导致整个程序崩溃。一个通用规则是，调用本地方法应该集中在少数的几个类当中，这样就降低了 Java 和其他语言之间的耦合。 常量池 要理解常量池，首先要知道，常量池分3种类型： Class文件内容里的常量池 运行时常量池（Runtime Constant Pool） 各个包装类型里实现的常量池，例如 String 类里面的字符串常量池（String Pool） Class 常量池 Java 代码在经过编译器后，会生成一个 Class 文件，这个常量池就是Class文件里的一大段内容（通常是最大的一段内容），它主要存放着 字面量、符号引用 等信息，在 JVM 把 Class 文件加载完成后，Class 常量池里的数据会存放到运行时常量池中。 运行时常量池（Runtime Constant Pool） 运行时常量池是元空间/方法区（Method Area）的一部分，运行时常量池中存储的，是 基本类型的数据 和 对象的引用，注意是对象的引用而不是对象实例本身哦。 Java 虚拟机在加载 Class 文件时，Class 文件内容里常量池的数据会放入运行时常量池。每一个加载好的 Class 对象里都会有一个运行时常量池。 字符串常量池（String Constant Pool）&amp; 其他包装类型里实现的常量池 字符串由一个char[]构成（Java9 之后使用 byte[]），当我们的Java程序里频繁出现相同字面量的代码时，重复的创建和销毁对象是一件很浪费资源的事情，所以Java实现了一个字符串常量池。 JDK7 之后，字符串常量池从方法区迁移到了堆区，它的底层实现可以理解为是一个 HashTable。Java 虚拟机中只会存在一份字符串常量池。字符串常量池里，存放的数据可以是引用也可以是对象实例本身。 字符串常量池也具备运行时常量池动态性的特征，它支持运行期间将新的常量放入池中，这种特性被开发人员利用比较多的就是 String.intern() 方法。 上面的一堆都不重要，重要的是只要记住在 Java 中，字符串字面量都是存储在 字符串常量池 中的。例如： 12// 此种赋值方式称为字符串字面量，如果你学过 Rust 语言，很好理解String str = &quot;abcd&quot;; 基本类型的包装类和常量池 Byte、Short、Integer、Long、Character、Boolean 这 6 种包装类和 String 都各自实现了自己的常量池。Float 和 Double 这两个浮点类型没有实现常量池。 字符串常量池（String pool）的实例 1String str1 = &quot;jhlz&quot;; 当以上代码运行时，JVM会到字符串常量池查找 “jhlz” 这个字面量对象是否存在： 存在：则返回该对象的引用给变量 str1 。 不存在：则创建一个对象，同时将引用返回给变量 str1 。（JDK8之后，对象实例直接存储在字符串常量池里） 1234567String str1 = &quot;jhlz&quot;;String str2 = &quot;jhlz&quot;;System.out.println(str1 == str2);//str1 和 str2 都指向同一个对象，返回TRUE// 使用 new 关键字创建 String 对象时，不管字符串常量池中是否有相同内容的对象的引用，新的字符串对象都会创建String str3 = new String(&quot;jhlz&quot;);System.out.println(str1 == str3); //返回FALSE 对于使用了 new 创建的字符串对象，如果想要将这个对象添加到字符串常量池，可以使用 intern() 方法。 12345String str1 = &quot;jhlz&quot;;String str2 = &quot;jhlz&quot;;String str3 = new String(&quot;jhlz&quot;);String str4 = str3.intern();System.out.println(str4 == str1);//返回TRUE intern() 方法会检查字符串常量池中是否有与之匹配的对象，并做如下操作： 存在：直接返回对象引用给interns变量。 不存在：将这个对象引用加入到常量池，再返回对象引用给interns变量。 二、调优命令 Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo jps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 jstat：JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 jmap：JVM Memory Map命令用于生成heap dump文件。 jhat：JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看jstack，用于生成java虚拟机当前时刻的线程快照。 jinfo：JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。 jstack：查找死锁。 12345678jmap ‐dump:format=b,file=eureka.hprof 14660# jstack pid -A 后面数字为显示的线程所在行的后面10行，最后的参数是线程id的16进制表示。jstack 19663|grep -A 10 4cd0jstat -gc pid# 打印GC日志方法 %t：时间java ‐jar ‐Xloggc:./gc‐%t.log ‐XX:+PrintGCDetails ‐XX:+PrintGCDateStamps ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCCause ‐XX:+UseGCLogFileRotation ‐XX:NumberOfGCLogFiles=10 ‐XX:GCLogFileSize=100M xxxx.jar 三、常见调优工具 常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。 jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控 jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。 MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 GChisto，一款专业分析gc日志的工具 Arthas 首先下载到本机，用java -jar运行即可，可以识别机器上所有Java进程。 输入dashboard可以查看整个进程的运行情况，线程、内存、GC、运行环境信息。详细使用参照 官方文档。 四、JVM垃圾收集算法 引用计数法 根可达算法 标记清除算法 标记复制算法 标记整理算法 五、JVM经典优化技术 方法内联： 方法内联就是把目标方法的代码原封不动地 “复制” 到发起调用的方法之中，避免发生真实的方法调用而已。但实际上Java虚拟机中的内联过程却远没 有想象中容易，甚至如果不是即时编译器做了一些特殊的努力，按照经典编译原理的优化理论，大多 数的Java方法都无法进行内联。 除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。 只有使用 invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会 在编译期进行解析。除了上述四种方法之外（最多再除去被final修饰的方法这种特殊情况，尽管它使 用invokevirtual指令调用，但也是非虚方法，《Java语言规范》中明确说明了这点），其他的Java方法 调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，简 而言之，Java语言中默认的实例方法是虚方法。 逃逸分析： 逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。 逃逸分析的基本原理是：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线 程逃逸，称为对象由低到高的不同逃逸程度。如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径 访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实 例采取不同程度的优化 比如栈上分配、标量替换、同步消除都是以此为基。 公共子表达式消除 公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术，它的含义是：如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么 E 的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直 接用前面计算过的表达式结果代替E。 如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。 数组边界检查消除 附：JVM指令码 JVM指令码 助记符 说明 0x00 nop 什么都不做 0x01 aconst_null 将null推送至栈顶 0x02 iconst_m1 将int型-1推送至栈顶 0x03 iconst_0 将int型0推送至栈顶 0x04 iconst_1 将int型1推送至栈顶 0x05 iconst_2 将int型2推送至操作数栈顶 0x06 iconst_3 将int型3推送至栈顶 0x07 iconst_4 将int型4推送至栈顶 0x08 iconst_5 将int型5推送至栈顶 0x09 lconst_0 将long型0推送至栈顶 0x0a lconst_1 将long型1推送至栈顶 0x0b fconst_0 将float型0推送至栈顶 0x0c fconst_1 将float型1推送至栈顶 0x0d fconst_2 将float型2推送至栈顶 0x0e dconst_0 将double型0推送至栈顶 0x0f dconst_1 将double型1推送至栈顶 0x10 bipush 将单字节的常量值(-128~127)推送至栈顶 0x11 sipush 将一个短整型常量值(-32768~32767)推送至栈顶 0x12 ldc 将int, float或String型常量值从常量池中推送至栈顶 0x13 ldc_w 将int, float或String型常量值从常量池中推送至栈顶（宽索引） 0x14 ldc2_w 将long或double型常量值从常量池中推送至栈顶（宽索引） 0x15 iload 将指定的int型本地变量推送至栈顶 0x16 lload 将指定的long型本地变量推送至栈顶 0x17 fload 将指定的float型本地变量推送至栈顶 0x18 dload 将指定的double型本地变量推送至栈顶 0x19 aload 将指定的引用类型本地变量推送至栈顶 0x1a iload_0 将第一个int型本地变量推送至栈顶 0x1b iload_1 将第二个int型本地变量推送至栈顶 0x1c iload_2 将第三个int型本地变量推送至栈顶 0x1d iload_3 将第四个int型本地变量推送至栈顶 0x1e lload_0 将第一个long型本地变量推送至栈顶 0x1f lload_1 将第二个long型本地变量推送至栈顶 0x20 lload_2 将第三个long型本地变量推送至栈顶 0x21 lload_3 将第四个long型本地变量推送至栈顶 0x22 fload_0 将第一个float型本地变量推送至栈顶 0x23 fload_1 将第二个float型本地变量推送至栈顶 0x24 fload_2 将第三个float型本地变量推送至栈顶 0x25 fload_3 将第四个float型本地变量推送至栈顶 0x26 dload_0 将第一个double型本地变量推送至栈顶 0x27 dload_1 将第二个double型本地变量推送至栈顶 0x28 dload_2 将第三个double型本地变量推送至栈顶 0x29 dload_3 将第四个double型本地变量推送至栈顶 0x2a aload_0 将第一个引用类型本地变量推送至栈顶 0x2b aload_1 将第二个引用类型本地变量推送至栈顶 0x2c aload_2 将第三个引用类型本地变量推送至栈顶 0x2d aload_3 将第四个引用类型本地变量推送至栈顶 0x2e iaload 将int型数组指定索引的值推送至栈顶 0x2f laload 将long型数组指定索引的值推送至栈顶 0x30 faload 将float型数组指定索引的值推送至栈顶 0x31 daload 将double型数组指定索引的值推送至栈顶 0x32 aaload 将引用型数组指定索引的值推送至栈顶 0x33 baload 将boolean或byte型数组指定索引的值推送至栈顶 0x34 caload 将char型数组指定索引的值推送至栈顶 0x35 saload 将short型数组指定索引的值推送至栈顶 0x36 istore 将栈顶int型数值存入指定本地变量 0x37 lstore 将栈顶long型数值存入指定本地变量 0x38 fstore 将栈顶float型数值存入指定本地变量 0x39 dstore 将栈顶double型数值存入指定本地变量 0x3a astore 将栈顶引用型数值存入指定本地变量 0x3b istore_0 将栈顶int型数值存入第一个本地变量 0x3c istore_1 将栈顶int型数值存入第二个本地变量 0x3d istore_2 将栈顶int型数值存入第三个本地变量 0x3e istore_3 将栈顶int型数值存入第四个本地变量 0x3f lstore_0 将栈顶long型数值存入第一个本地变量 0x40 lstore_1 将栈顶long型数值存入第二个本地变量 0x41 lstore_2 将栈顶long型数值存入第三个本地变量 0x42 lstore_3 将栈顶long型数值存入第四个本地变量 0x43 fstore_0 将栈顶float型数值存入第一个本地变量 0x44 fstore_1 将栈顶float型数值存入第二个本地变量 0x45 fstore_2 将栈顶float型数值存入第三个本地变量 0x46 fstore_3 将栈顶float型数值存入第四个本地变量 0x47 dstore_0 将栈顶double型数值存入第一个本地变量 0x48 dstore_1 将栈顶double型数值存入第二个本地变量 0x49 dstore_2 将栈顶double型数值存入第三个本地变量 0x4a dstore_3 将栈顶double型数值存入第四个本地变量 0x4b astore_0 将栈顶引用型数值存入第一个本地变量 0x4c astore_1 将栈顶引用型数值存入第二个本地变量 0x4d astore_2 将栈顶引用型数值存入第三个本地变量 0x4e astore_3 将栈顶引用型数值存入第四个本地变量 0x4f iastore 将栈顶int型数值存入指定数组的指定索引位置 0x50 lastore 将栈顶long型数值存入指定数组的指定索引位置 0x51 fastore 将栈顶float型数值存入指定数组的指定索引位置 0x52 dastore 将栈顶double型数值存入指定数组的指定索引位置 0x53 aastore 将栈顶引用型数值存入指定数组的指定索引位置 0x54 bastore 将栈顶boolean或byte型数值存入指定数组的指定索引位置 0x55 castore 将栈顶char型数值存入指定数组的指定索引位置 0x56 sastore 将栈顶short型数值存入指定数组的指定索引位置 0x57 pop 将栈顶数值弹出 (数值不能是long或double类型的) 0x58 pop2 将栈顶的一个（long或double类型的)或两个数值弹出（其它） 0x59 dup 复制栈顶数值并将复制值压入栈顶 0x5a dup_x1 复制栈顶数值并将两个复制值压入栈顶 0x5b dup_x2 复制栈顶数值并将三个（或两个）复制值压入栈顶 0x5c dup2 复制栈顶一个（long或double类型的)或两个（其它）数值并将复制值压入栈顶 0x5d dup2_x1 &lt;待补充&gt; 0x5e dup2_x2 &lt;待补充&gt; 0x5f swap 将栈最顶端的两个数值互换(数值不能是long或double类型的) 0x60 iadd 将栈顶两int型数值相加并将结果压入栈顶 0x61 ladd 将栈顶两long型数值相加并将结果压入栈顶 0x62 fadd 将栈顶两float型数值相加并将结果压入栈顶 0x63 dadd 将栈顶两double型数值相加并将结果压入栈顶 0x64 isub 将栈顶两int型数值相减并将结果压入栈顶 0x65 lsub 将栈顶两long型数值相减并将结果压入栈顶 0x66 fsub 将栈顶两float型数值相减并将结果压入栈顶 0x67 dsub 将栈顶两double型数值相减并将结果压入栈顶 0x68 imul 将栈顶两int型数值相乘并将结果压入栈顶 0x69 lmul 将栈顶两long型数值相乘并将结果压入栈顶 0x6a fmul 将栈顶两float型数值相乘并将结果压入栈顶 0x6b dmul 将栈顶两double型数值相乘并将结果压入栈顶 0x6c idiv 将栈顶两int型数值相除并将结果压入栈顶 0x6d ldiv 将栈顶两long型数值相除并将结果压入栈顶 0x6e fdiv 将栈顶两float型数值相除并将结果压入栈顶 0x6f ddiv 将栈顶两double型数值相除并将结果压入栈顶 0x70 irem 将栈顶两int型数值作取模运算并将结果压入栈顶 0x71 lrem 将栈顶两long型数值作取模运算并将结果压入栈顶 0x72 frem 将栈顶两float型数值作取模运算并将结果压入栈顶 0x73 drem 将栈顶两double型数值作取模运算并将结果压入栈顶 0x74 ineg 将栈顶int型数值取负并将结果压入栈顶 0x75 lneg 将栈顶long型数值取负并将结果压入栈顶 0x76 fneg 将栈顶float型数值取负并将结果压入栈顶 0x77 dneg 将栈顶double型数值取负并将结果压入栈顶 0x78 ishl 将int型数值左移位指定位数并将结果压入栈顶 0x79 lshl 将long型数值左移位指定位数并将结果压入栈顶 0x7a ishr 将int型数值右（符号）移位指定位数并将结果压入栈顶 0x7b lshr 将long型数值右（符号）移位指定位数并将结果压入栈顶 0x7c iushr 将int型数值右（无符号）移位指定位数并将结果压入栈顶 0x7d lushr 将long型数值右（无符号）移位指定位数并将结果压入栈顶 0x7e iand 将栈顶两int型数值作“按位与”并将结果压入栈顶 0x7f land 将栈顶两long型数值作“按位与”并将结果压入栈顶 0x80 ior 将栈顶两int型数值作“按位或”并将结果压入栈顶 0x81 lor 将栈顶两long型数值作“按位或”并将结果压入栈顶 0x82 ixor 将栈顶两int型数值作“按位异或”并将结果压入栈顶 0x83 lxor 将栈顶两long型数值作“按位异或”并将结果压入栈顶 0x84 iinc 将指定位置的int型变量增加指定值（i++, i–, i+=2） 0x85 i2l 将栈顶int型数值强制转换成long型数值并将结果压入栈顶 0x86 i2f 将栈顶int型数值强制转换成float型数值并将结果压入栈顶 0x87 i2d 将栈顶int型数值强制转换成double型数值并将结果压入栈顶 0x88 l2i 将栈顶long型数值强制转换成int型数值并将结果压入栈顶 0x89 l2f 将栈顶long型数值强制转换成float型数值并将结果压入栈顶 0x8a l2d 将栈顶long型数值强制转换成double型数值并将结果压入栈顶 0x8b f2i 将栈顶float型数值强制转换成int型数值并将结果压入栈顶 0x8c f2l 将栈顶float型数值强制转换成long型数值并将结果压入栈顶 0x8d f2d 将栈顶float型数值强制转换成double型数值并将结果压入栈顶 0x8e d2i 将栈顶double型数值强制转换成int型数值并将结果压入栈顶 0x8f d2l 将栈顶double型数值强制转换成long型数值并将结果压入栈顶 0x90 d2f 将栈顶double型数值强制转换成float型数值并将结果压入栈顶 0x91 i2b 将栈顶int型数值强制转换成byte型数值并将结果压入栈顶 0x92 i2c 将栈顶int型数值强制转换成char型数值并将结果压入栈顶 0x93 i2s 将栈顶int型数值强制转换成short型数值并将结果压入栈顶 0x94 lcmp 比较栈顶两long型数值大小，并将结果（1，0，-1）压入栈顶 0x95 fcmpl 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一 个数值为NaN时，将-1压入栈顶 0x96 fcmpg 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一 个数值为NaN时，将1压入栈顶 0x97 dcmpl 比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中 一个数值为NaN时，将-1压入栈顶 0x98 dcmpg 比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中 一个数值为NaN时，将1压入栈顶 0x99 ifeq 当栈顶int型数值等于0时跳转 0x9a ifne 当栈顶int型数值不等于0时跳转 0x9b iflt 当栈顶int型数值小于0时跳转 0x9c ifge 当栈顶int型数值大于等于0时跳转 0x9d ifgt 当栈顶int型数值大于0时跳转 0x9e ifle 当栈顶int型数值小于等于0时跳转 0x9f if_icmpeq 比较栈顶两int型数值大小，当结果等于0时跳转 0xa0 if_icmpne 比较栈顶两int型数值大小，当结果不等于0时跳转 0xa1 if_icmplt 比较栈顶两int型数值大小，当结果小于0时跳转 0xa2 if_icmpge 比较栈顶两int型数值大小，当结果大于等于0时跳转 0xa3 if_icmpgt 比较栈顶两int型数值大小，当结果大于0时跳转 0xa4 if_icmple 比较栈顶两int型数值大小，当结果小于等于0时跳转 0xa5 if_acmpeq 比较栈顶两引用型数值，当结果相等时跳转 0xa6 if_acmpne 比较栈顶两引用型数值，当结果不相等时跳转 0xa7 goto 无条件跳转 0xa8 jsr 跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶 0xa9 ret 返回至本地变量指定的index的指令位置（一般与jsr, jsr_w联合使用） 0xaa tableswitch 用于switch条件跳转，case值连续（可变长度指令） 0xab lookupswitch 用于switch条件跳转，case值不连续（可变长度指令） 0xac ireturn 从当前方法返回int 0xad lreturn 从当前方法返回long 0xae freturn 从当前方法返回float 0xaf dreturn 从当前方法返回double 0xb0 areturn 从当前方法返回对象引用 0xb1 return 从当前方法返回void 0xb2 getstatic 获取指定类的静态域，并将其值压入栈顶 0xb3 putstatic 为指定的类的静态域赋值 0xb4 getfield 获取指定类的实例域，并将其值压入栈顶 0xb5 putfield 为指定的类的实例域赋值 0xb6 invokevirtual 调用实例方法 0xb7 invokespecial 调用超类构造方法，实例初始化方法，私有方法 0xb8 invokestatic 调用静态方法 0xb9 invokeinterface 调用接口方法 0xba – 0xbb new 创建一个对象，并将其引用值压入栈顶 0xbc newarray 创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压 入栈顶 0xbd anewarray 创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶 0xbe arraylength 获得数组的长度值并压入栈顶 0xbf athrow 将栈顶的异常抛出 0xc0 checkcast 检验类型转换，检验未通过将抛出ClassCastException 0xc1 instanceof 检验对象是否是指定的类的实例，如果是将1压入栈顶，否则将0压入栈顶 0xc2 monitorenter 获得对象的锁，用于同步方法或同步块 0xc3 monitorexit 释放对象的锁，用于同步方法或同步块 0xc4 wide &lt;待补充&gt; 0xc5 multianewarray 创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必 须包含各维度的长度值），并将其引用值压入栈顶 0xc6 ifnull 为null时跳转 0xc7 ifnonnull 不为null时跳转 0xc8 goto_w 无条件跳转（宽索引） 0xc9 jsr_w 跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶"},{"title":"Spring","path":"/wiki/编程后花园/Java/SpringFramework/Spring.html","content":"Spring 笔记整理，本文是刚开始工作学习的时候整理的，所以会显得较乱，推荐查阅 Spring 官方文档，官方文档写的还是很不错的！ 一、Spring 二、Spring的核心API：ApplicationContext 三、Spring工厂创建复杂对象 四、Spring配置文件的细节 1. 只配置bean的class属性 2. name别名的使用 3. ref标签 五、Spring注入方式 1. set注入的简化写法 2. 构造注入 3. 循环依赖 六、Spring工厂创建复杂对象的三种方式 1. FactoryBean 接口 2. 实例工厂 3. 静态工厂 七、如何控制Spring工厂创建对象的次数 1. 控制简单对象的创建次数 2. 控制复杂对象的创建次数 八、对象的生命周期 1. 创建阶段 2. 初始化阶段 3. 销毁阶段 九、配置文件参数化 十、类型转换器 1. 自定义类型转换器实现 十一、后置处理Bean 十二、静态、动态代理的概念 1. 静态代理 2. 动态代理 十三、Spring AOP（Aspect Oriented Programing） 编程 1. 开发步骤 2. AOP的底层实现原理 2.1 JDK动态代理 2.2 CGlib 动态代理 3. 基于注解的AOP开发 4. AOP开发过程中的坑 5. AOP总结 十四、拦截器、过滤器 1. 拦截器 2. 过滤器 十五、Spring的事务管理 1. 事务并发产生的问题 1.1 脏读 1.2 不可重复读 1.3 幻影读 2. 传播属性 2.1 只读属性(readOnly) 2.2 超时属性(timeout) 2.3 异常属性(rollbackFor) 2.4 事务属性常见配置总结 十六、Spring MVC 1. 为什么要整合MVC框架 2. Spring 可以整合那些 MVC 框架 3. Spring整合MVC框架的核心思路 3.1 准备工厂 4. Spring工厂创建对象的优先级 一、Spring Spring 是一个轻量级的解决方案，它有两大核心内容：AOP 和反转控制。 反转控制（Inverse of Control） 反转： 赋值交给 Spring，解耦合 把对于成员变量赋值的控制权，从代码反转到 Spring 工厂和配置文件中完成。 底层实现： 工厂设计模式。 依赖注入DI（Dependency Injection） 注入： 通过 Spring 的工厂及配置文件，为对象（bean、组件）的成员变量赋值。 依赖注入： 当以一个类需要另一个类时，就产生了依赖，一旦出现依赖，就可以把另一个类作为本类的成员变量，最终通过 Spring 配置文件进行注入（赋值）。 二、Spring的核心API：ApplicationContext ApplicationContext 是 Spring 的核心接口，它用于对象的创建，可以把它当作一个 Bean 工厂。使用这个接口可以屏蔽实现的差异，从而解耦合。 ApplicationContext 包括： ClassPathXmlApplicationContext (非 Web 环境：main junit) XmlWebApplicationContext（Web 环境） 另外，Application 是一个重量级资源，对于这类资源，我们不应去频繁的创建。 三、Spring工厂创建复杂对象 创建工厂类型； 配置文件的配置 ApplicationContext.xml 通过工厂类获得对象 123ApplicationContext |- ClassPathXmlApplicationContext |- WebXmlApplicationContext 什么是复杂对象？ 不能通过 new 关键字的构造方法创建的对象。例如，jdbc 的 Connection 对象，Mybatis 中的 SqlSessionFactory 等。 什么是简单对象？ 可以直接通过 new 构造方法创建对象，这样的对象叫做简单对象。 接口加反射，什么都能做。Spring 工厂是可以调用对象私有的构造方法创建对象，其中大量使用反射来获取信息帮助我们创建对象，这就是 Spring 工厂比我们自己创造的简易工厂强大的地方。 四、Spring配置文件的细节 1. 只配置bean的class属性 12&lt;!-- 该配置不含 id 属性 --&gt;&lt;bean class=&quot;com.xxx.User&quot;&gt;&lt;/bean&gt; 应用场景：如果这个 bean 只需要使用一次，那么就可以省略 id 值。如果 bean 会使用多次，或者被其他 bean 引用则需要设置 id 值。 2. name别名的使用 12&lt;!-- name 就是一个别名，使用 getBean(name) 方法同样也可以创建 bean 对象，与 getBean(id) 是等效的。 --&gt;&lt;bean id=&quot;user&quot; name=&quot;a,b,c&quot; class=&quot;com.xxx.User&quot;&gt; id 和 name 的不同： 别名可以定义多个，id 只能定义一个（比如，人的大名只有一个，小名可以有多个） XML 对于 id 属性的值，命名要求：必须以字母开头，后面是字母、数字、下划线、连字符。不能以特殊字符开头。name 属性值没有要求。因此，name 可以用于比较特殊命名的场景下 [注①]。 代码 containBeanDefinition(id) 只能判断 id 是否存在，不能判断 name；containBean() 可以判断 id，也可以判断 name。 注①： XML 发展到了今天：ID 属性值的限制已经不存在了。这就是语言不断更新发展的好处。 3. ref标签 1234567&lt;bean id=&quot;userDao&quot; class=&quot;com.xxx.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.xxx.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot;&gt; &lt;ref bean=&quot;userDao&quot; /&gt; &lt;/property&gt;&lt;/bean&gt; Spring 4.x 废除了 &lt;ref local=&quot;&quot;/&gt;，它和 &lt;ref bean=&quot;&quot;/&gt; 基本等效。但是前者只能引用本配置文件；后者除了可以引用本配置文件，还可以引用父配置文件。 五、Spring注入方式 名称 举例 所属 说明 setter注入 setxxx() 自动注入 @Autowired Spring提供 默认根据类型注入 自动注入 @Resource JavaEE规范 默认根据名称注入 构造方法注入 public xxxConstruct() 对于 @Autowired 和 @Resource，如果按照默认的类型找不到目标类的话，会自动使用另一种方式去查找。 属性注入：@Value 注入 map 集合时，文件中必须使用 json 格式赋值，使用 #&#123;$&#123;属性&#125;&#125; 取值，map的键如果相同，后面的值会覆盖前面的值。 1. set注入的简化写法 基于属性简化 123456789101112131415161718192021&lt;!-- jdk 类型 --&gt;&lt;!-- 原始写法 --&gt;&lt;property name=&quot;id&quot;&gt; &lt;value&gt;11&lt;/value&gt;&lt;/property&gt;&lt;!-- 简化后写法 --&gt;&lt;property name=&quot;id&quot; value=&quot;11&quot; /&gt;&lt;!-- value 属性只能简化 8 种基本类型 + String 标签 --&gt;&lt;!-- 用户自定义类型 --&gt;&lt;!-- 原始写法 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.xxx.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot;&gt; &lt;ref bean=&quot;userDao&quot; /&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 简化后写法 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.xxx.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; 基于命名空间 p 简化写法 使用命名空间需要在 xml 的头声明中导入对应的 xsd 模板，否则会报错。 12345&lt;!-- jdk 类型简化写法 --&gt;&lt;bean id=&quot;person&quot; class=&quot;&quot; p:name=&quot;xiaoming&quot; p:id=&quot;100&quot;/&gt;&lt;!-- 自定义类型简化写法 --&gt;&lt;bean id=&quot;&quot; class=&quot;&quot; p:userDao-ref=&quot;userDao&quot;/&gt; 2. 构造注入 提供有参构造方法 123456789public class User &#123; private String name; private Integer age; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; &#125; Spring 的配置文件 123456789&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;!-- 一个标签对应一个参数 --&gt; &lt;constructor-arg type=&quot;&quot;&gt; &lt;value&gt;小明&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;&quot;&gt; &lt;value&gt;20&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 如果构造方法有重载，并且参数的个数相同，这个时候需要 &lt;constructor-arg type=&quot;&quot;&gt; 指明参数的类型才能完成注入。 3. 循环依赖 先说 Spring 解决循环引用的结论：两个对象都是 单实例 的情况下，且通过 set方式 进行注入才能成功解决该问题。 Spring AOP 创建的代理是在 创建对象-&gt; 属性填充 -&gt; 初始化的时候执行的。 思考：代理对象一定会在初始化的时候创建？ 不一定，如果涉及循环引用，创建 -&gt; singletonFactries -&gt; lambda -&gt;创建 Spring解决循环依赖的步骤： 步骤一： 1.singletonObjects null 2.earlySingleObjects null 3.singletonFactories null 步骤二： 1.singletonObjects null 2.earlySingleObjects null 3.singletonFactories != null lambda getEarlyBeanRederence(beanName, mbd, bean) 创建代理 proxy，然后从 singletonFactories 中移除，proxy 放到 earlySingletonObjects 中。 先到 singletonObjects 中获取，如果为 null，则在 earlySingleObjects 中获取，如果还为 null，在 singletonFactories 中获取。 通过lambda getEarlyBeanRederence(beanName, mbd, bean) 创建代理，然后从 singletonFactories 中移除，把 proxy 放到 earlySingletonObjects 中。 creationBean a(半成品) 属性的填充：涉及 getBean(“b”)，过程和上面类似，在 b 中需要 a，上面过程中已经创建了 a，所以可以顺利拿到，进而创建 b。循环依赖就是 “你中有我，我中有你” 的解决方法。 六、Spring工厂创建复杂对象的三种方式 1. FactoryBean 接口 实现 FactoryBean 接口的三个方法：getObject()，书写创建复杂对象的代码并返回复杂对象、getObjectType()，返回创建的复杂对象的 Class 对象、isSinglrton()，return true 只创建一个复杂对象，return false 每一次调用，都生成一个复杂对象。 Spring 配置文件的配置 12&lt;!-- 虽然配置是和简单对象是一样的，但是通过 id 获取的是这个类创建的复杂对象 Connection --&gt;&lt;bean id=&quot;conn&quot; class=&quot;com.xxx.ConnectionFactoryBean&quot;&gt; 如果想要获取 ConnectionFactoryBean 对象，需要 getBean(“&amp;conn”)，就是在 id 的前面加上 &amp;。 2. 实例工厂 123&lt;!-- 先声明实例对象，再引用 --&gt;&lt;beann id=&quot;connFactory&quot; class=&quot;com.xxx.ConnectionFactory&quot;/&gt;&lt;bean id=&quot;conn&quot; factory-bean=&quot;connFactory&quot; factory-method=&quot;getConnection&quot;/&gt; 3. 静态工厂 12&lt;!-- 直接使用 --&gt;&lt;bean id=&quot;conn&quot; class=&quot;com.xxx.xxxFactoryBean&quot; factory-method=&quot;getConnection&quot;/&gt; 七、如何控制Spring工厂创建对象的次数 Q：为什么要控制对象的创建次数? A：节省不必要的内存浪费。 什么样的对象只创建一次？ SqlSessionFactory DAO Service 什么样的对象每一次都要创建 Connection SqlSession | Session Controller | Struts2 Action 总之一句话：如果可以共用，并且是线程安全的，可以只创建一次。 1. 控制简单对象的创建次数 1&lt;bean id=&quot;&quot; scope=&quot;singleton|prototype&quot; class=&quot;&quot;&gt; singleton: 只会创建一次； prototype: 每一次都会创建新的对象。 默认值 singleton。 2. 控制复杂对象的创建次数 实现 FactoryBean 的接口的复杂对象： isSingleton() { return true;只会创建一次 return false;每一次都会创建新的 } 如果没有 isSingleton() 方法，还是配置 scope 属性。 八、对象的生命周期 1. 创建阶段 scope=&quot;singleton&quot;: Spring 工厂创建的同时（new ClassPathXmlApplicationContext()），对象被创建。 如果想要在 singleton 的情况下，使用 getBean() 时才能创建对象，可以加入 lazy-init 属性，lazy-init=&quot;true&quot; scope=&quot;prototype&quot;: 在调用 getBean() 的时候创建对象。 2. 初始化阶段 Spring 工厂在创建完对象后，调用对象的初始化方法，完成对应的初始化操作。 初始化方法的提供：程序员根据需求，提供初始化方法，最终完成初始化操作。 初始化调用：Spring 工厂调用。 初始化实现方式： 实现 InitializingBean 接口，重写 afterPropertiesSet() 方法。 对象中提供一个普通的方法 在配置文件中添加 init-method 属性，值为我们定义的普通的方法名称，注意不需要 ()。 Q: 如果一个对象实现了 InitializingBean 接口，也提供了普通的方法，那么执行的顺序是什么样子的呢？ A: 先执行 InitializingBean，再执行普通方法。 3. 销毁阶段 Spring 销毁对象前，会调用对象的销毁方法，完成销毁。销毁方法的操作只适用于 scope=&quot;singleton&quot; 的对象。销毁操作主要指资源的释放操作。例如 io，connection 等的关闭。 销毁方法：程序员根据自己的需求，定义销毁方法。 调用：Spring 工厂完成调用 实现方式： 实现 DisposableBean 接口，重写 destroy() 方法； 自定义销毁方法，在配置文件的 destroy-method 属性中写自定义的方法名。 Q: Spring 什么时候销毁对象？ A: ctx.close(); Q: 如果一个对象实现了 DisposableBean 接口，也提供了普通的销毁方法，那么执行的顺序是什么样子的呢？ A: 执行顺序：先执行 DisposableBean 接口的实现方法，再执行普通方法。 九、配置文件参数化 把Spring配置文件中需要经常修改的字符串信息，转移到一个更小的配置文件中。例如，数据库的连接可能在后期维护中会更换账户和密码，这时就可以把这些内容放到另一个文件中，这个文件专门存储变化的数据。 提供一个小的配置文件（.properties 文件），名字、位置任意。 Spring 的配置文件和小配置文件整合。 db.properties 文件： 1234jdbc.driverClassName = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/jhlz?useSSL=falsejdbc.username = rootjdbc.password = root spring-config.xml 文件： 123456789&lt;!-- 配置小文件的路径 --&gt;&lt;context:property-placeholder location=&quot;classpath:/db.properties&quot;/&gt;&lt;bean id=&quot;conn&quot; class=&quot;com.xxx.ConnectionFactoryBean&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; 十、类型转换器 1. 自定义类型转换器实现 实现 Converter 接口，定义转换的类型与实现。 配置文件注册配置 1234567891011&lt;!-- 创建自定义转换对象 --&gt;&lt;bean id=&quot;myDateConverter&quot; class=&quot;com.xxx.MyDateConverter&quot;&gt;&lt;!-- 注册类型转换器 --&gt;&lt;!-- 目的：告诉 Spring 框架，开发的是一个类型转换器。 --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;myDateConverter&quot;/&gt; &lt;/set&gt;&gt; &lt;/property&gt;&lt;/bean&gt; 注册 ConversionServiceFactoryBean 时的 id 必须为 conversionService，大小写也需要一样。 Spring 框架其实内置了日期类型的转换器，但只是针对 2021/12/12 这种格式，至于其它格式依然需要程序员手动实现。 十一、后置处理Bean BeanPostProcess 作用： 对 Spring 工厂所创建的对象，进行再加工。 实现 BeanPostProcessor 接口，重写其中的方法。最好是在 after 的方法中写需要的逻辑。 BeanPostProcessor 会对 Spring 工厂创建的所有对象都生效。 十二、静态、动态代理的概念 代理设计模式的作用就是额外功能的增强，可以通过动态字节码技术创建 包括JDK CGLIB ASM Javasist（MyBatis也支持） 装饰器设计模式：本职功能的增强 1. 静态代理 静态代理：为每一个原始类，手工编写一个代理类（有 .java 和 .class 文件） 由此我们可以知道静态代理存在的问题： 静态文件数量过多，不利于项目管理； 额外功能的维护性差（代理类中，额外功能修改复杂）。 2. 动态代理 JDK 动态代理 Proxy.newProxyInstance() 通过接口创建代理的实现类。 CGlib 动态代理 Enhancer 通过继承父类创建的代理类。 十三、Spring AOP（Aspect Oriented Programing） 编程 概念：基于 Spring 的动态代理开发，通过代理类为原始类增加额外功能。 好处：利于原始类的维护。 本质：JDK 动态代理。 思考： AOP 如何创建动态代理类？（动态字节码技术） Spring 的工厂是如何加工创建代理对象？（通过原始对象的id值，获得代理对象）（BeanPostProcessor） SpringBoot中修改创建代理的方式，添加 @EnableApsectJAutoProxy，覆盖SpringBoot的内置设置。 Spring AOP： 默认使用 JDK 代理 SpringBoot AOP： 默认使用 CGlib 代理 1. 开发步骤 原始对象 额外功能（MethodInterCeptor） 切入点 组装切面（额外功能 + 切入点） 2. AOP的底层实现原理 2.1 JDK动态代理 类加载器的作用 通过了类加载器把对应类的字节码文件加载到JVM 通过类加载器创建类的 Class 对象，进而创建这个类的对象。 如何获得类加载器？ 每一个类的 .class 文件自动分配与之对应的 ClassLoader. 动态代理创建的过程中，需要 ClassLoader 创建代理类的 Class 对象，可是因为动态代理类没有对应的 .class 文件，JVM 也就不会为其分配 ClassLoader，如何创建？ 借用一个 ClassLoader，任意的 ClassLoader 都可以。 2.2 CGlib 动态代理 CGlib创建动态代理的原理：父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证两者方法一致，同时在代理类中提供新的实现（额外功能+原始方法）。 3. 基于注解的AOP开发 Spring 配置文件加入： 12&lt;!-- 告知Spring是基于注解的AOP --&gt;&lt;aop:aspect-autoproxy/&gt; 在默认情况下：AOP 编程底层使用 JDK 动态代理创建代理对象。那么如何切换到 CGlib 动态代理呢？有两种方式，一种是针对 注解式 开发，另一种是针对 传统 开发。 注解式 AOP 开发：修改 Spring 的配置文件，在开启动态代理的标签中添加属性 proxy-target-class=&quot;true&quot; 12&lt;!-- 告知Spring是基于注解的AOP --&gt;&lt;aop:aspect-autoproxy proxy-target-class=&quot;true&quot;/&gt; 传统 AOP 开发切换到 CGlib 配置 1234&lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* login(..)) or execution(* register(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;arround&quot; pointcut-ref=&quot;pc&quot;/&gt;&lt;/aop:config&gt; 编写一个 Aop 配置类：导入 aop 依赖；在 Aop 配置类上加上 @Aspect、@Configuration 注解；编写切面增强方法。 切入点表达式 方法级别的切入点表达式：execution(* com.XXX.*.*(..))，第一个 * 号代表可以返回任意类型值。 类级别的切入点表达式：within(com.XXX.*) 自定义注解表达式：@annotation(com.XXX) 增强方式 前置增强 (@Befor)、后置增强(@After)、环绕增强 (@Arround)、后置返回增强 (@AfterReturning)、异常增强 (@AfterThrowing) 前置和后置都没有返回值，方法参数都是 JointPoint 环绕增强中，需要调用 proceed() 才能继续处理业务逻辑(类似拦截器)，该方法返回值为业务的返回值，因此环绕增强的返回类型比较推荐设置为 Object。 环绕增强的方法参数是 ProceedingJointPoint 4. AOP开发过程中的坑 在同一个的业务类中，进行业务方法间的相互调用，只有最外层方法才加入了额外功能，内部的方法通过普通的方式调用，调用的都是原始方法。如果想让内层的方法也通过代理对象调用，必须实现 ApplicationContextAware 接口获得工厂，进而获得代理对象。 5. AOP总结 十四、拦截器、过滤器 1. 拦截器 实现 HandlerInterceptor 接口； 重写 preHandle、postHandle、afterCompletion 方法，其中 preHandle 方法中返回 true 代表放行，返回 false 代表中断。 preHandle 返回值为 true 时，执行控制器中的方法，当控制器方法执行完成后会返回拦截器中执行拦截器中的 postHandle 方法，postHandle 执行完成之后响应请求。在响应请求完成后会执行 afterCompletion 方法，该方法无论执行 成功 或者 失败 都会执行。 CustomerInterceptor.class12345678910111213141516171819202122232425public class CustomerInterceptor implements HandlerInterceptor &#123; /** * 先执行 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return HandlerInterceptor.super.preHandle(request, response, handler); &#125; /** * 上面结果为 true 时执行 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); &#125; /** * 最后都会执行 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; HandlerInterceptor.super.afterCompletion(request, response, handler, ex); &#125;&#125; 配置拦截器：实现 WebMvcConfigurer 接口；重写 addInterceptors 方法，添加编写的拦截器。 1234567@Configuration public class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(customerInterceptor()); &#125; &#125; 拦截器只能拦截 controller 相关请求，不能拦截 jsp 静态资源文件； 拦截器可以中断请求轨迹； 请求之前如果该请求配置了拦截器，请求会先经过拦截器，放行之后执行请求的 controller，controller 执行完成后会回到拦截器继续执行拦截器代码。 如果配置了多个拦截器，默认执行的顺序和栈结构是一样的；但是也可以通过 order() 方法修改，里面填 int 类型的数字，数字大的优先执行。 2. 过滤器 关于过滤器，它和拦截器比较像，编写方式也非常简单，实现 Filter 接口即可。但是要清楚：过滤器是 Java 提供的，拦截器是 Spring 提供的。下面的内容引用 Spring 的原文： HandlerInterceptor is basically similar to a Servlet Filter, but in contrast to the latter it just allows custom pre-processing with the option of prohibiting the execution of the handler itself, and custom post-processing. Filters are more powerful, for example they allow for exchanging the request and response objects that are handed down the chain. Note that a filter gets configured in web.xml, a HandlerInterceptor in the application context. 汉译一下：HandlerInterceptor基本上类似于Servlet Filter，但与后者不同的是，它只允许自定义预处理(带有禁止执行处理程序本身的选项)和自定义后处理。过滤器更强大，例如，它们允许交换沿链传递的请求和响应对象。注意，过滤器是在web.xml中配置的，HandlerInterceptor是在应用程序上下文中配置的。 十五、Spring的事务管理 Spring 管理事物的方式： 编程式事务，在代码中硬编码。(不推荐使用) 声明式事务，在配置文件中配置(推荐使用) 基于XML的声明式事务 基于注解的声明式事务 1. 事务并发产生的问题 1.1 脏读 一个事务读取了另外一个事务没有提交的数据。 解决方案：@Transactional(isolation=Isolation.READ_COMMITTED) 1.2 不可重复读 在同一个事务中，多次查询同一条数据，但是读取的结果不同。 解决方案：@Transactional(isolation=Isolation.REPEATABLE_READ) 本质：一把行锁 1.3 幻影读 在一个事务中，对整表数据查询，显示的结果不一样。注意：是整表。会在本事务中出现数据不一致。 解决方案：@Transactional(isolation=Isolation.SERIALIZABLE) 本质：表级锁。 隔离属性在实战中的建议：推荐使用 Spring 指定的 ISOLATION_DEFAULT MySQL repeatable_read Oracle read_commited 在真正的项目中，并发访问情况是很低的。如果真的遇到并发问题，那么可以使用乐观锁解决，基于系统层面的，不会对系统的性能有太大的影响。 比如：Hibernate（JPA） Version、MyBatis 通过拦截器自定义开发。 2. 传播属性 概念：它描述了事务解决嵌套问题的特征。 什么是事务的嵌套：它指的是一个大的事务中，包含了若干个小的事务。 问题：大事务中融入了很多小的事务，它们彼此影响，最终就会导致外部大的事务失败，丧失了事务的原子性。 属性名称 外部不存在事务 外部存在事务 用法 备注 REQUIRED 开启事务 融合到外部事务中 @Transactional(Propagation.REQUIRED) 增删改 SUPPORTS 不开启事务 融合到外部事务中 @Transactional(Propagation.SUPPORTS) 查询 REQUIRES_NEW 开启新的事务 挂起外部事务，开启新的事务 @Transactional(propagation.REQUIRES_NEW) 日志记录 NOT_SUPPORTED 不开启事务 挂起外部事务 @Transactional(Propagation.NOT_SUPPORTED) 极其不常用 NEVER 不开启事务 抛出异常 @Transactional(Propagation.NEVER) 极其不常用 MANDATORY 抛出异常 融合到外部事务 @Transactional(Propagation.MANDATORY) 极其不常用 2.1 只读属性(readOnly) 默认为 false，不开启。针对只查询的操作，可以设为 true 开启可以提高系统的运行效率。 2.2 超时属性(timeout) timeout 以秒为单位，默认值为 -1，最终由对应的数据库来指定。 2.3 异常属性(rollbackFor) Spring 的事务处理过程中，默认对于 RuntimeException 及其子类，采用的回滚的策略； 对于 Exception 及其子类，采用的是提交的策略。 手动指定： rollbackFor = Exception.class noRollbackFor = RuntimeException.class 建议在实战中使用 RuntimeException 及其子类，使用事务异常属性的默认值。 2.4 事务属性常见配置总结 隔离属性 默认值 传播属性 Required（默认值） 增删改 Supports 查询操作 只读属性 readOnly false 增删改 true 查询操作 超时属性 默认值 -1 异常属性 默认值 增删改操作 @Transaction 查询操作 @Transaction(propagation=Propagation.SUPPORTS, readOnly=true) 十六、Spring MVC 1. 为什么要整合MVC框架 MVC 框架提供了控制器调用 Service 请求响应的处理， 接收请求参数 request.getParameter() 控制程序的运行流程 视图解析（jsp JSON Freemarker Thyemeleaf） 2. Spring 可以整合那些 MVC 框架 struts 1 webwork jsf struts 2 springMVC 3. Spring整合MVC框架的核心思路 3.1 准备工厂 Web 开发过程中如何创建工厂 ApplicationContext ctx = new new WebXmlApplicationContext(&quot;/applicationContext.xml&quot;); 如何保证工厂唯一同时被共用 工厂存储在 ServletContext 这个作用域中 ServletContext.setAttribute(“xxxx”, ctx); 唯一： WebXmlApplicationContext @Configuration的使用： 使用这个注解可以让 Spring 工厂创建 bean，可以不用在 applicationContext.xml 中编写 bean 标签。 创建工厂的代码改变了，需要使用 AnnotationConfigApplicationContext。指定配置 bean 的 Class。 ApplicationContext ctx = new AnnotationConfigApplicationContext(xxxConfig.class); 指定配置 bean 所在的路径。 ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.config&quot;); 4. Spring工厂创建对象的优先级 bean 标签 &gt; @Bean &gt; @Component 及其衍生注解。 Spring 读取Properties文件： PropertiesPlaceholderConfigurer 读取yml文件转换为Proterties：YamlPropertiesFactoryBean#setResources()YamlPropertiesFactoryBean#getObject() Spring与YML集成依赖（最低所需版本：1.18） 12345&lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;version&gt;1.30&lt;/version&gt;&lt;/dependency&gt;"},{"title":"Spring API","path":"/wiki/编程后花园/Java/SpringFramework/SpringAPI.html","content":"Spring Api 1. LocalVariableTableParameterNameDiscoverer 获取参数列表 问题：Java.lang.reflect 包中提供了很多 API：获取所有的方法，获取所有的参数类型等，但是却没有一个 API 能够帮助我们获取某个方法的参数名列表（注意，Java 反射可以拿到类型，但是不能拿到具体的形参名称，而是以 arg0、arg1 返回的）。 解决办法：可以通过 ASM 提供的通过字节码获取方法的参数名称，Spring 给我们集成了这个东西，让我们使用起来非常的方便。 作用：这个东西有啥用，其实我们在 Action 层就会使用到，前端传递过来的参数是怎么反馈到具体的方法上的参数的值？它和 Httprequest.getParamer(“xxx”) 这样的很类似。然后通过反射注入到具体的值中，但是怎么一一对应起来呢？这个就需要方法的参数名称啦，你懂了？通过名称看一下传递进来的参数是否含有具体的值，然后通过反射写入到具体的位置，这样我们在 Action 层的具体的方法中，可以获取到请求的值，而不用自己去手动的处理 Httprequest.getParamer(“xxx”)，这个也是框架给我们带来的便利性。 代码实践，主要的方法：LocalVariableTableParameterNameDiscoverer.getParameterNames(Method method);然后返回参数的Stirng数组，没有返回NULL 12345678910111213141516171819202122232425262728293031import lombok.extern.slf4j.Slf4j;import org.springframework.core.LocalVariableTableParameterNameDiscoverer;import java.lang.reflect.Method;@Slf4jpublic class GetMethArguments &#123; private static final LocalVariableTableParameterNameDiscoverer parameterNameDiscoverer = new LocalVariableTableParameterNameDiscoverer(); public void testArguments(String test,Integer myInteger,boolean booleanTest)&#123; &#125; public void test()&#123; &#125; public static void main(String[] args) &#123; Method[] methods = GetMethArguments.class.getMethods(); for(Method method:methods)&#123; String[] paraNames = parameterNameDiscoverer.getParameterNames(method); log.info(&quot;methodName:&quot;+method.getName()); if(paraNames !=null)&#123; StringBuffer buffer = new StringBuffer(); for(String string:paraNames)&#123; buffer.append(string).append(&quot;\\t&quot;); &#125; log.info(&quot;parameArguments:&quot;+buffer.toString()); &#125;else&#123; log.info(&quot;无参数&quot;); &#125; &#125; &#125;"},{"title":"SpringSecurity","path":"/wiki/编程后花园/Java/SpringFramework/SpringSecurity.html","content":"一、官网学习 官方文档https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html 本文内容基于官方文档 + 其它资料 + 自己的使用经验整理。 Spring Security 是一个框架，提供针对常见攻击的身份验证、授权和保护。 它为保护命令式和响应式应用程序提供了一流的支持，是保护基于 Spring 的应用程序的事实标准。 在 Security 5.4 中引入了通过创建 SecurityFilterChain Bean 进行配置 HttpSecurity 的功能。自 Security 5.7 开始，WebSecurityConfigurerAdapter 弃用，其配置写法以 Java Bean 的方式为主，组件化配置。具体的使用可以阅读 官方文档。 1. 架构 Spring Security 基于 servlet 的过滤器链实现，这些过滤器称之为 FilterChain，同时 Security 还提供了 FilterChainProxy 允许我们设置多个 FilterChain，实现不同的认证，例如基本的认证和 OAuth2 等。在这些过滤器中，我们可以选择重写内部的具体实现完成自己的业务，也可以向 FilterChain 中添加我们自己的新的 Filter，然后在配置中添加生效的位置。 SecurityContextHolder SecurityContextHolder：存储被身份验证者的详细信息的地方； SecurityContex：从 SecurityContextHolder 获取，包含当前经过身份验证的用户 Authentication； Authentication：可以是 AuthenticationManager 的输入，用于提供用户为进行身份验证而提供的凭据或 SecurityContext 中的当前用户； AuthenticationManager：定义 Spring Security 的过滤器如何执行身份验证的 API； ProviderManager ：最常见的 AuthenticationManager 实现； 用户已通过身份验证的最简单方法是直接设置 SecurityContextHolder； 12345678// 创建信息的 contextSecurityContext context = SecurityContextHolder.createEmptyContext();// 创建 authentication 主体完成认证Authentication authentication = new TestingAuthenticationToken(&quot;username&quot;, &quot;password&quot;, &quot;ROLE_USER&quot;); context.setAuthentication(authentication);// 将 Security Context 保存在 SecurityContextHolder 中SecurityContextHolder.setContext(context); 2. 思考 为什么在 SpringBoot 中，引入 Spring Security 依赖之后没有任何配置所有的请求就要认证呢？ SpringBootWebSecurityConfiguration，自动配置类 在项目中明明没有登录界面，登录界面怎么来的呢？ 访问接口时，在引入 spring security 之后会先经过一系列过滤器。在请求到达 FilterSecurityInterceptor 时，发现请求并未认证，请求拦截下来，并抛出 AccessDeniedException 异常。抛出的异常会被 ExceptionTranslationFilter 捕获，这个 Filter 中会调用 LoginUrlAuthenticationEntryPoint#commence 方法给客户端返回 302，要求客户端进行重定向到 /login 页面。客户端发送 /login 请求。/login 请求会再次被拦截器中 DefaultLoginPageGeneratingFilter 拦截到，并在拦截器中返回生成登录页面。 为什么使用 user 和控制台打印的密码能登录，登录时验证数据源存在哪里呢？ Spring Security中有一个基于内存（InMemoryUserDetailsManager）的默认用户实现。 二、登录认证 登录 调用 ProviderManager 的方法进行认证，如果认证成功生成 jwt，把用户信息存入 redis。 自定义 UserDetailsService，查询数据库 校验 定义 jwt 认证过滤器，获取 token，解析 token 中的 userid，查询 redis 中是否存在相应的 userid 并获取用户信息，最后存入 SecurityContextHolder。 1. 一些说明 AuthenticationManager ProviderManager AuthencationProvider关系 AuthenticationManager 有全局的和局部的，无论哪种，都是通过 ProviderManager 进行实现。每一个 ProviderManager 中都代理一个 AuthenticationProvider列表，列表中每一个实现代表一种身份认证方式。认证时底层数据源调用 UserDetailsService 来实现。 WebSecurityConfigurerAdapter（5.7+ 标为弃用） WebSecurityConfigurerAdapter 是 Spring Security 为我们提供的扩展类，方便我们重写默认配置，实现定制。 Spring Security(5.7) 中的 WebSecurityConfigurerAdapter 标记为弃用状态。新版的改变与使用参考 5.7新版配置，不同之处在于改变了写法，新版主要以配置 Bean 的方式使用。 UserDetails 提供核心用户信息，UserDetailsService#loadByUsername() 返回的就是一个 UserDetails 对象。 UserDetailsService 用来修改默认认证的数据源信息 UserDetailsService 接口下有许多的实现。同时，此接口也方便了我们以后的自定义数据源的扩展。里面定义了一个根据用户名查询用户信息的方法。 Authentication 封装的用户信息，包括用户名和密码。 2. 配置AuthenticationManager的两种方式 继承 WebSecurityConfigurerAdapter，springboot 对 security 默认配置中 在工厂默认创建 AuthenticationManager。 12345// 默认配置会自动发现创建的 UserDetailService 的 Bean@Autowiredpublic void initialize(AuthenticationManagerBuilder builder, DataSource datasource) &#123; System.out.println(&quot;spring boot 自动配置的全局 AuthenticationManager&quot;);&#125; 自定义全局认证数据源 12345678910// 自定义配置 AuthenticationManager@Overridepublic void configure(AuthenticationManagerBuilder builder) &#123; builder.userDetailsService(customerUserDetailsService())&#125;// 暴露本地的 AuthenticationManager 自定义实例@Overridepublic AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean();&#125; 小结： 默认自动配置全局 AuthenticationManager 默认找当前项目中是否存在自定义 UserDetailService 实例，如果存在会自动将当前项目的 UserDetailService 实例设置为数据源。 默认自动配置全局 AuthenticationManager 在工厂中使用时直接在代码中注入即可。 一旦通过自定义的方式配置后，会 自动覆盖 默认的实现；并且需要在实现中 指定 自定义的数据源对象 UserDetailsService 实例，并且这个 AuthenticationManager 需要暴露出来（自定义的默认是本地的，不允许其它组件注入）。 3. 密码加密 常见加密方案：Hash 算法+盐 单向自适应函数（占用大量系统资源，每个认证请求都会大大降低应用程序的性能），开发者可以通过 bcrypt、PBKDF2、sCrypt 以及 argon2 来体验这种自适应单向函数加密。 密码的认证是由 PasswordEncoder 进行的，他可以根据不同的加密实现不同的认证方式，所以非常的灵活。自定义密码加密有两种方式，一种是直接指定密码加密的方式（比如Bcrypt），另一种是使用自定义升级的方式。配置中指定密码加密的方式较为常见，另一种方式看自己的项目中是否需要，有需要就可以修改。 4. RememberMe RememberMe是一种服务端的行为，并非是把用户名密码保存在 Cookie 中的信息。传统的登录方式基于 Session 会话，一旦用户的会话过期，就要再次登录，这样就太过于繁琐。如果有一种机制，会话过期后，还能继续保持认证状态，就会方便很多，RememberMe就是为了解决这一需求而生的。 具体的实现思路就是通过 Cookie 来记录当前用户身份，用户登录成功之后，会通过一定算法，将用户信息时间戳等进行贾母，加密完成后，通过响应头带回前端存储再Cookie中，当浏览器会话过期之后，如果再次访问网站，会自动将 Cookie 中的信息发送给服务器，服务器对 Cookie 中的信息进行校验分析，进而确定出用户的身份，Cookie 中所保存的用户信息也是有失效的，例如三天、一周等。 5. 会话管理(SessionManagementFilter) 会话并发管理：简单来说，就是多个客户端使用同一账户登录。默认情况下，同一账户可以再多少设备上登录并没有限制，我们可以在 Spring Security 中进行配置。 开启会话管理 12345678// 自定义配置@Overridepublic void configure(HttpSecurity http) throw Exception &#123; http... .sessionManagement() // 开启会话管理 // 最大并发会话为 1 .maximumSessions(1);&#125; Spring Security 开启会话管理默认的是挤掉另一个客户端登录；我们可以设置为禁止其它客户端登录（当前用户登录成功，其它客户端无法使用当前的账户登录，除非当前用户注销退出）。集群下的会话管理可以使用 Redis 的Session 共享。 6. 跨域问题 入门：@CrossOrigin 该注解由 Spring 框架提供，含有属性： allowCredentials:浏览器是否应当发送凭证信息，如 Cookie。 allowHeader:允许访问头 origins:允许指定访问的所属域访问，* 表示所有字段。 exposeHeaders:哪些响应头可以作为响应的一部分暴露出来。使用通配符无效。 maxAge:预检查请求的有效期，有效期内不必再次发送预检请求，默认是100s。 methods:允许的请求方法，* 表示所有方法。 进阶：addCrosMapping（Spring MVC 提供） 123456789101112@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowCredentials(false) .allowedHeaders(&quot;*&quot;) .allowedMethods(&quot;*&quot;) .allowedOrigins(&quot;*&quot;) .maxAge(3600); &#125;&#125; CrosFilter（Spring Web提供的跨域处理解决方案） 12345678910111213141516171819202122232425import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;import java.util.Arrays;@Configurationpublic class WebMvcConfig &#123; FilterRegistrationBean&lt;CorsFilter&gt; corsFilter() &#123; FilterRegistrationBean&lt;CorsFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(); CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedHeaders(Arrays.asList(&quot;*&quot;)); corsConfiguration.setAllowedMethods(Arrays.asList(&quot;*&quot;)); corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;*&quot;)); corsConfiguration.setMaxAge(3600L); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); registrationBean.setFilter(new CorsFilter(source)); registrationBean.setOrder(-1); return registrationBean; &#125;&#125; Spring Security中的跨域解决方案 Q： 当项目中使用了Spring Security后，上面的方案有的会失效，有的可以继续使用，这是为什么？ A： 通过 @CrossOrigin 注解或者重写 addCorsMappings 方法配置的跨域解决方案，统统失效了（发送的预检请求会被 Spring Security 拦截）；通过 CorsFilter 配置的跨域，有没有失效则要看过滤器的优先级。如果过滤优先级高于 Spring Security 过滤器，即先于 Spring Security 过滤器执行，则 CorsFilter 所配置的跨域处理依然有效；如果优先级低于 Spring Security 过滤器，则 CorsFilter 所配置的跨域处理就会失效。 12345678910111213141516171819202122@Configurationpublic class WebMvcConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().anyRequest() .authenticated().and() .formLogin().and() // 跨域处理方案 .cors().configurationSource(corsConfigurationSource()).and() .csrf().disable(); &#125; CorsConfigurationSource corsConfigurationSource() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedHeaders(Arrays.asList(&quot;*&quot;)); corsConfiguration.setAllowedMethods(Arrays.asList(&quot;*&quot;)); corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;*&quot;)); corsConfiguration.setMaxAge(3600L); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); return source; &#125;&#125; 7. 异常处理 7.1 认证异常 认证异常涉及的异常类型比较多，AuthenticationException 是所有认证异常的父类。一般我们重写 AuthenticationEntryPoint#commence() 来自定义出现认证异常后返回给前端的提示信息。 7.2 授权异常 相较于认证异常，权限异常类就要少了很多。在实际项目开发中，如果默认提供的异常无法满足需求，就需要根据实际需求自定义异常类。一般重写 AccessDeniedHandler#handle() 实现授权失败的返回信息。 7.3 自定义异常处理配置示例 为求简单，这里给的是一个使用 lambda 函数的简写形式，没有写单独的类配置。 1234567891011121314151617181920212223242526@Configurationpublic class WebMvcConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().mvcMatchers(&quot;/hello&quot;).hasRole(&quot;ADMIN&quot;) .anyRequest() .authenticated().and() .formLogin().and() .csrf().disable() // 异常处理 .exceptionHandling() // 认证异常 .authenticationEntryPoint((request, response, authException) -&gt; &#123; response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE); response.setStatus(HttpStatus.UNAUTHORIZED.value()); response.getWriter().write(&quot;尚未认证，请进行认证操作&quot;); &#125;) // 权限异常 .accessDeniedHandler((request, response, accessDeniedException) -&gt; &#123; response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE); response.setStatus(HttpStatus.FORBIDDEN.value()); response.getWriter().write(&quot;无权访问&quot;); &#125;); &#125;&#125; 8. CSRF（Cross-site request forgery） CSRF 即跨站请求伪造，是 web 常见的攻击方式之一。 Spring Security 防止 CSRF 攻击的方式就是通过 csrf_token，前端发起请求的时候需要携带这个 csrf_token，后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。 CSRF 攻击依靠的是 Cookie 中所携带的认证信息。但是在前后端分离的项目我们的认证信息是基于 Token，而 token 并不存储在 Cookie 中，我们的 token 是设置到请求头中的，所以 CSRF 攻击在前后端分离的项目中就失效了。 二、授权 2.1 两种权限管理策略 基于过滤器的权限管理（FilterSecurityInterceptor）：主要拦截Http请求，拦截下来后，根据Http请求地址进行权限校验 基于方法的权限管理（MethodSecurityInterceptor）：主要是用来处理方法级别的权限问题。当需要调用某一个方法时，基于 AOP 将操作拦截下来，然后判断用户是否具备相关的权限。 1. 基于 URL 的权限管理 antMatchers()：最早出现的，用于任何 HttpMethod 请求列表。 mvcMatchers()：4.x 版本新增的，使用 Spring MVC 的匹配规则。例如，路径 /path，它会匹配 /path，/path/，/path.html 等。如果 Spring MVC 不会处理当前请求，会使用 antMatchers()。 两种方式本质上没有太大区别。使用 mvcMatchers() 的话优先使用 MVC 进行匹配，如果匹配不到，会使用 antMatchers() 匹配方式。 regexMatchers()；支持正则表达式。 2. 基于方法的权限管理 这种方式就是在 controller 层的方法上加上注解，指明需要哪些权限或者具有的角色才能访问对应的资源。 首先，配置类中开启方法权限校验：@EnableGlobalMethodSecurity(prePostEnabled = true, SecuredEnable = true, jsr250Enabled = true)，（这里开启了三种方式，一般只用第一种） 1234567891011121314151617181920212223// 开启配置 启用方法级别的权限认证@Configuration// 开启之后就可以使用 @preAuthorize 也是最常用的注解@EnableGlobalMethodSecurity(prePostEnabled = true)public class SecurityConfig&#123; ...&#125;// 前置校验@preAuthorize(&quot;hasAuthority(&quot;权限名称&quot;)&quot;)// 过滤 filterTarget 必须是数组 集合，不能过滤某个对象@preFilter(filterTarget = &quot;users&quot;)// 后置校验@PostAuthorize()@PostFilter()@Secured(&quot;role1&quot;, &quot;role2&quot;) // 只能判断角色，或者 关系，满足一个即通过请求// 允许所有用户访问@PermitAll()// 拒绝所有访问@DenyAll()// jsr250 提供的注解，和 Secured() 类似@RolesAllowed(&quot;role1&quot;, &quot;role2&quot;) 项目中，一般前四个用的较多，后面几个功能较为单一。 2.2 动态权限修改 以上方式都是通过代码实现的，比较难以修改，可以使用动态的权限修改，比如从数据库层面实现，修改字段即可达到修改相应的权限的目的。 只需实现 FilterInvocationSecurityMetaSource 接口并重写 getAttributes() 方法。之后在 SecurityConfig 配置类中，使用 http.apply() 方法，覆写里面的配置，setSecurityMetaSource() 改为实现 FilterInvocationSecurityMetaSource 接口的实现类即可。setRejectPublicInvocations() 设为 true/false，为 true 时拒绝 公共资源（没有权限管理的公共接口） 的访问。 2.3 RBAC(Role-Based Access Control) RBAC 即基于角色的权限控制，你也可以理解为使用 角色 来代理具体的 权限。 想像一下，每次添加用户时都单独添加权限的话，那肯定是比较繁琐的。如果我们加入一个“角色”，把常用的一些权限分配给预定义的角色，然后在添加用户的时候直接把“角色”（比如 admin）设置给用户，这个用户就自动拥有对应的权限。这样就比较简单方便。"},{"title":"Spring事务失效的几种情况","path":"/wiki/编程后花园/Java/SpringFramework/Spring事务失效的几种情况.html","content":"一、Spring 声明式事务失效的几种情况 Spring 的声明式事务非常的好用，但是使用不当的话事务会失效，对于生产环境中是非常严重的问题。 如果对 AOP 熟悉的 coder 可能这个问题非常简单，如果不了解也可以凭经验解决。下面总结一些情况。权限修饰符和 final 的情况不用说了，如果使用 IDE 的话基本上都会提示错误。 1. 自行 try-catch，吞掉异常 123456789@Override@Transactional(rollbackFor = Exception.class)public void saveBatch(List&lt;User&gt; list) &#123; try&#123; saveBatch(list); &#125; catch (Exception e) &#123; log.error(&quot;保存失败：&#123;&#125;&quot;, e.getMessage()); &#125;&#125; 如果是这种情况，虽然添加了事务，那么也不会生效。解决的办法就是在 catch 中抛出异常，Spring 事务回滚机制默认是捕获 RuntimeException 和 Error，当然 Spring 也提供了 rollbackFor 属性捕获其它异常，实际开发中最好指定事务回滚需要捕获的异常类型。如下代码： 12345678910@Override@Transactional(rollbackFor = Exception.class)public void saveBatch(List&lt;User&gt; list) &#123; try&#123; saveBatch(list); &#125; catch (Exception e) &#123; log.error(&quot;保存失败：&#123;&#125;&quot;, e.getMessage()); throw new RuntimeException(&quot;保存失败&quot;); &#125;&#125; 2. 同一服务类的方法相互调用 不论是事务方法调用事务方法，还是非事务方法调用事务方法，一般使用 声明式事务 失效的情况以此类居多。 1234567891011@Overridepublic void importExcel(List&lt;User&gt; list) &#123; // do something parser saveBatch(list);&#125;@Override@Transactional(propagation = Propagation.NESTED)public void saveBatch(List&lt;User&gt; list) &#123; // do something&#125; 解决办法有下面几种： 使用 Spring 提供的 AopContext.currentProxy() （简单方便）； 将其中的一个方法移至到另一个 xxxService 中，调用时使用 @Autowired 注入调用这是没问题的（还记得开头说的 AOP？）。因为在同一个 Service 中调用本类的方法就不是 Spring 代理的对象了，所以事务也就不会生效了（@Transactional 事务是 Spring 管理的）； 不使用 Spring 的事务管理，自己编写工具手动管理事务。 这里说说第一种，浪子也是第一次使用，其它两种方法基本上使用过 Spring Web 的 coder 都会。 暴露 Spring 代理对象，需要开启 业务调用 12345678910111213141516171819@SpringBootApplication// 暴露出 Spring 代理对象给业务使用，默认为 false@EnableAspectJAutoProxy(exposeProxy = true)public class Application &#123;...&#125;// 业务调用@Overridepublic void importExcel(List&lt;User&gt; list) &#123; // do something parser // 拿到代理对象 调用相关方法 xxxService currentProxy = (xxxService) AopContext.currentProxy(); currentProxy.saveBatch(list);&#125;@Override@Transactional(rollbackFor = Exception.class)public void saveBatch(List&lt;User&gt; list) &#123; userMapper.saveBatch(list);&#125; 3. 嵌套调用 事务嵌套调用时，有时候我们希望这种场景：里面的事务方法如果发生异常回滚，但我不希望外面的回滚： 12345678910111213@Override@Transactional(rollbackFor = Exception.class)public void importExcel(List&lt;User&gt; list) &#123; // do something parser updateSome(user); saveBatch(list);&#125;@Override@Transactional(propagation = Propagation.NESTED)public void saveBatch(List&lt;User&gt; list) &#123; // do something&#125; 上面的例子中，当 saveBatch 发生异常时，我希望它回滚，但是我不希望之前的 updateSome 回滚。但是事实确实都回滚了。原因就是如果下面的 saveBatch 发生异常时会向上抛，以至于外层也发生了异常，所以解决办法也很简单，直接 try-catch。 1234567891011121314151617@Override@Transactional(rollbackFor = Exception.class)public void importExcel(List&lt;User&gt; list) &#123; // do something parser updateSome(user); try &#123; saveBatch(list); &#125; catch (Exception e) &#123; // TODO: handle exception &#125;&#125;@Override@Transactional(propagation = Propagation.NESTED)public void saveBatch(List&lt;User&gt; list) &#123; // do something&#125; 二、事务优化 使用事务时最好指定回滚异常，设置事务传播属性； 尽量避免大事务连接，可以考虑使用上面的解决办法把事务方法抽离出来，进行内部调用。 参考：https://blog.csdn.net/hanjiaqian/article/details/120501741"},{"title":"Spring 注解","path":"/wiki/编程后花园/Java/SpringFramework/Spring注解.html","content":"Spring 4.x 引入注解开发，简化开发形式，提升开发效率。Spring Boot 也在这个推出，并且大力推动注解式开发。在 Spring 框架中有许多的注解，并且有部分和 Java/javax 中提供的注解同名，但是 Spring 框架做了一些额外的增强功能。毕竟 Spring 框架使用 Java 反射较多：接口 + 反射，什么都能做！ Spring 注解 Web @Component @Repository/@Mapper DAO类型 @Service Service类型 @Controller Controller 类型 上面的注解的本质就是 @Component 注解，使用它们可以更加准确的表达一个类型的作用。 顺带一提：@Configuration 可以创建多个 Bean 对象，而 @Component 只能创建单个 Bean 对象。 @ControllerAdvice、@RestControllerAdvice 顾名思义，这两个类都是对 controller 层做增强处理。这两个注解可以用来对 controller 的返回值做统一包装（下面有一个小栗子），也可以和另一个注解 @ExceptionHandler 一起作为全局的系统异常处理（项目常用）。 1234567891011121314151617181920212223242526// @RestControllerAdvice @ControllerAdvice(basePackages = &quot;com.xxx.controller&quot;) // 只对此包中的类进行结果封装public class ResultResponseHandler implements ResponseBodyAdvice &#123; private static final Logger log = LoggerFactory.getLogger(ResultResponseHandler.class); @Override public boolean supports(MethodParameter returnType, Class converterType) &#123; // 过滤不需要封装的结果 if (returnType.getParameterType().isAssignableFrom(ResultResp.class)) &#123; return false; &#125; return true; &#125; /** * 此处处理结果集后响应给客户端 */ @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; if (body instanceof ResultResp) &#123; return body; &#125; return ResultResp.success(body); &#125;&#125; @ResponseBody、@RequestBody、@Controller 这三个注解通常只在 controller 层使用：@RestController = @ResponseBody + @Controller. 所以对于目前常见的前后端分离的项目，一般我们直接使用 @RestController 注解即可。 另外我们已经知道，Spring 中使用了 jaskon 作为 json 工具，所以相关的注解底层运作也使用了 jaskon。比如 @ResponseBody、@RequestBody 等。 其中 @ResponseBody 把返回的对象转为 json 格式字符串后响应到客户端；而 @RequestBody 把客户端的 json 字符串参数转为 Java 中的复杂对象。 @Async Spring 提供了异步执行的代码的功能,能让我们以多线程的方式执行,但是 Spring 中自带的 @Async 注解执行异步时并没有使用线程池的概念, 如果同时执行多个任务可能会把系统资源耗尽的情况。对此，SpingBoot 做好了优化，默认使用线程池执行任务。 只需要在 SpringBoot 项目中需要异步执行的代码上加上注解 @Async,同时在启动类上加上 @EnableAsync 即可，如下： 1234567@SpringBootApplication@EnableAsyncpublic class AnsyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AnsyApplication.class, args); &#125;&#125; 12345@Asyncpublic void test() throws InterruptedException &#123; Thread.sleep(1000); System.out.println(&quot;子线程执行了&quot;);&#125; 测试代码 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = AnsyApplication.class)public class TestDemo &#123; @Autowired AnsyService service; @Test public void testDemo() throws Exception&#123; service.test(); System.out.println(&quot;主线程执行了&quot;); //阻塞当前的主线程，等待异步执行的结束 Thread.sleep(2000); &#125;&#125; Jackson @JsonProperty 序列化或者反序列化时都使用该注解里面的值。 @JsonAlias 只有反序列化时读取里面定义的值，可定义多个，jackson 负责读取并把把该值赋给实际的变量名称。 @JsonView 使用该字段创建视图，可以使用在 controller 类上，控制返回的字段，类似于 DTO、VO，不用在自己不用创建实体了，框架会把未使用该注解的字段过滤后然后返回给客户端。 不过注意，使用该注解时，返回的结果只能返回该对象或者该对象的集合；如果在外层使用自定义包装的形式，那么会直接返回一个空值 &#123;&#125;。 比如我们一般自定义返回结果类的时候，可以使用以下方法，加入项目自定义封装的类为 Result： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class); &#125;&#125;record User( @JsonView(Views.NameAndAge.class) String name, @JsonView(Views.NameAndAge.class) Integer age, LocalDateTime bir) &#123;&#125;interface Views &#123; class NameAndAge &#123; &#125;&#125;@RestControllerclass WebController &#123; @GetMapping(&quot;user&quot;) @JsonView(Views.NameAndAge.class) public Result getNameAndAge() &#123; List&lt;User&gt; users = List.of( new User(&quot;jhlz&quot;, 20, LocalDateTime.now()), new User(&quot;john&quot;, 21, LocalDateTime.now()), new User(&quot;yo&quot;, 22, LocalDateTime.now()), new User(&quot;me&quot;, 23, LocalDateTime.now()), new User(&quot;girl&quot;, 24, LocalDateTime.now()) ); return new Result(&quot;成功！&quot;, 200, users); &#125;&#125;record Result( @JsonView(Object.class) String msg, @JsonView(Object.class) int code, @JsonView(Object.class) Object data) &#123;&#125; 这样就返回的结果就正常了。"},{"title":"Gradle And Maven","path":"/wiki/编程后花园/Java/随笔/GradleAndMaven.html","content":"Gradle Gradle 与 Maven 的区别可以看这篇文章：https://gradle.org/maven-vs-gradle/。 日常使用哪个都是没有问题的，Gradle 语法比较简单，但是能不能看懂，自己用不用的起来就是另一回事儿了。很多人说 Gradle 过于灵活，较难上手，其实完全可以把它使用成 Maven 的样子，高级功能不用就行 😄。 这两个工具中 Gradle 的更新版本较快，高版本的部分语法是不兼容低版本的，所以力求稳定的话直接使用 Maven 即可，Gradle 升级不是那么的平缓。强大的灵活性失去的就是易用性。有句话说的好：高端玩家选择自定义设置，普通玩家选择默认配置。 本文使用 build.gradle.kts 的写法，毕竟 Kotlin 很好用！kts 的语法大部分都是以键值对的方式存在的，如果自己感觉很陌生，但是自己有基础的话，可以看一下 B 站霍老师的的视频： 迁移至gradle.ktshttps://www.bilibili.com/video/BV1Kf4y1p7zq/?share_source=copy_web&vd_source=0b7b4ba48d2cb78ec7e6042083167a54 墙裂推荐在 ~/.gradle 目录中创建 init.gradle.kts 文件，添加以下内容。这段内容的意思是：如果 Gradle 下载的依赖源是在 https://repo.maven.apache.org/maven2、https://dl.google.com/dl/android/maven2、https://plugins.gradle.org/m2 三个源中的依赖，下载时实际使用的地址将是 to 后面定义的镜像地址，此配置是全局生效的，不需要对新建的项目进行修改。 镜像地址使用的腾讯云的，可以根据自己的需要修改即可。这段代码也是来自于霍老师的，浪子自己手打的，累啊，霍老师竟然给了个 gist…… init.gradle.kts1234567891011121314151617181920212223242526272829fun RepositoryHandler.enableMirror() &#123; all &#123; if (this is MavenArtifactRepository) &#123; val originUrl = this.url.toString().removeSuffix(&quot;/&quot;) urlMappings[originUrl]?.let &#123; logger.lifecycle(&quot;Repository[$url] is mirrored to $it&quot;) this.setUrl(it) &#125; &#125; &#125;&#125;val urlMappings = mapOf( &quot;https://repo.maven.apache.org/maven2&quot; to &quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;, &quot;https://dl.google.com/dl/android/maven2&quot; to &quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;, &quot;https://plugins.gradle.org/m2&quot; to &quot;https://mirrors.tencent.com/nexus/repository/gradle-plugins/&quot;)gradle.allprojects &#123; buildscript &#123; repositories.enableMirror() &#125; repositories.enableMirror()&#125;gradle.beforeSettings &#123; pluginManagement.repositories.enableMirror() dependencyResolutionManagement.repositories.enableMirror()&#125; 两个文件 1. settings.gradle.kts settings.gradle.kts12345678// 项目的根文件名称rootProject.name = &quot;根项目文件夹名称&quot;// 包含的子模块，下面两种写法方式都可以// 方式一：冒号表示相对路径；也支持省略冒号的方式，这将使模块名称被解释为相对于 settings.gradle.kts 文件所在目录的路径include(&quot;:module1&quot;, &quot;:module2&quot;, &quot;:module3&quot;, &quot;:module4&quot;)// 方式二：include(&quot;:module1&quot;)include(&quot;:module2&quot;) 2. build.gradle.kts build.gradle.kts12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// gradle pluginsplugins &#123; // Java 插件 它为 Java 项目提供标准的 Java 工具链（如编译、测试、打包、生成JavaDoc等）和默认的目录布局 java // SpringBoot 插件 帮助配置和构建 Spring Boot 应用程序 id(&quot;org.springframework.boot&quot;) version &quot;3.1.2&quot; // Spring Dependency Management 插件可以帮助管理项目中的依赖关系， // 它可以让您在不需要手动指定版本号的情况下，使用特定版本的 Spring 库，并确保这些库与您项目中其他库的版本相兼容。 // 使用该插件，不需要在 build.gradle 中声明 dependencyManagement，它会辅助自动生成 id(&quot;io.spring.dependency-management&quot;) version &quot;1.1.3&quot;&#125;group = &quot;com.code&quot;version = &quot;1.0-SNAPSHOT&quot;allprojects &#123; // 所有项目使用的插件 apply &#123; plugin(&quot;kotlin&quot;) plugin(&quot;org.springframework.boot&quot;) plugin(&quot;io.spring.dependency-management&quot;) &#125; java &#123; sourceCompatibility = JavaVersion.VERSION_17 targetCompatibility = JavaVersion.VERSION_17 &#125; // 依赖下载源 repositories &#123; // 本地仓库 mavenLocal() // 腾讯云仓库 maven(&quot;https://mirrors.cloud.tencent.com/nexus/repository/maven-public/&quot;) // 如果项目中需要从 http 下载依赖，打开下面的设置 // maven &#123; // url = uri(&quot;http://mirrors.cloud.tencent.com/nexus/repository/maven-public/&quot;) // isAllowInsecureProtocol = true // &#125; &#125; // 所有项目的公共依赖 dependencies &#123; testImplementation &quot;org.springframework.boot:spring-boot-starter-test&quot; &#125;&#125;dependencies &#123; implementation(&quot;org.jetbrains.kotlin:kotlin-reflect&quot;)&#125;// 设置编译器的字符集，以便能够正确地处理文件中的 Unicode 字符。tasks.withType&lt;JavaCompile&gt; &#123; options.encoding = &quot;UTF-8&quot;&#125; 上面的是多模块的写法，子模块中的 build.gradle.kts 可以写也可以不写，空着也行。对于单体应用使用将更加简单，就不写了，和上面是类似的。 Maven Maven 是一个 Java 生态用的较多的依赖管理工具。 Maven 中有 6 种 scope： compile（默认） 这是默认作用域，如果未指定，则使用该 scope。编译依赖项在项目的所有类路径中都可用。此外，这些依赖项将传播到依赖项目，在编译与打包时都会加入。 provided 这很像 compile ，但表示您希望 JDK 或容器在运行时提供依赖项。例如，在为 Java Enterprise Edition 构建 Web 应用程序时，您需要将对 Servlet API 和相关 Java EE API 的依赖设置为范围 provided ，因为 Web 容器提供了这些类。具有此作用域的依赖项将添加到用于编译和测试的类路径中，但不添加到运行时类路径中（打包时不加入）。它不是可传递的。 runtime 此范围指示编译不需要依赖项，但执行程序需要依赖。Maven 在运行时和测试类路径中包含此作用域的依赖项，但不包括编译类路径。 test 此范围指示依赖项不是正常使用应用程序所必需的，并且仅适用于测试编译和执行阶段。此范围不是可传递的。通常，此范围用于测试库，如 JUnit 和 Mockito。它也用于非测试库，如 Apache Commons IO，这些库用于单元测试（src/test/java）但不用于代码（src/main/java）。 system 此作用域类似于 provided，但是需要结合 systemPath 提供显式包含它的 JAR，即而从本地文件系统获取依赖项，不会在存储库中查找。 1234567&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;basedir&#125;/lib/mysql-connector-java.jar&lt;/systemPath&gt;&lt;/dependency&gt; import 此作用域仅支持 POM 文件中的 dependencyManagement 部分。它表示依赖关系将被指定 POM 的 dependencyManagement 部分中的有效依赖关系列表替换。 自己的 jar 包安装到 maven 仓库 相信很多新手在没用 maven 之前，项目目录中都会单独使用一个文件夹存放项目使用的目录。但是使用 maven 之后就不需要了，使用 maven 管理要方便许多，那么问题来了，如果有的 jar 包在下载失败或者配置的下载源中没有怎么办？ 这个时候就可以自己去官网或者 jar 包作者提供的下载方式自己下载，然后使用 maven 提供的安装命令，安装到本地的 maven 仓库，然后项目中引入即可。 比如 Oracle 的 ojdbc8.jar，这个 jar 包当时浪子使用的阿里的下载源就没下载成功。后来去 Oracle 官网下载的 jar 包，在本地安装并引用。 食用方法，把对应的 jar 包放在使用它的项目中（其实这个不是必须的啦，maven 官方文档描述中说明：在目标 jar 包的同级目录中必须要有 pom.xml 文件），然后执行以下命令： 12# 安装 jar 包到本地 maven 仓库mvn install:install-file -Dfile=ojdbc8-23.2.0.0.jar -DgroupId=com.oracle -DartifactId=ojdbc8 -Dversion=23.2.0.0 -Dpackaging=jar -Dfile：jar 包名称，这里 jar 包是在项目根路径，所以直接写 -DgroupId、-DartifactId：坐标位置 -Dversion：版本号 上面的命令执行成功以后就可以去本地 maven 仓库中根据自己写的坐标位置找到刚才安装的 jar 包啦，这时候就可以使用 maven 引入项目使用了，刚在项目中的 jar 包也可以删除了（如果没用的话）。 Maven打包 打包之前推荐先清理（clean）再打包（package）。jar 包比较简单，SpringBoot 默认打的就是 jar 包。这里说一下 war 包的打包方式方式。 修改打包方式，去除内嵌的 tomcat 依赖 pom.xml123456&lt;packaging&gt;war&lt;/packaging&gt;...&lt;!-- 去除内嵌的 tomcat 依赖 --&gt;&lt;scope&gt;provided&lt;/scope&gt; 如果整合的是 jsp，那么使用打包的插件时，打包插件必须是 1.4.2 的版本，另外，在pom文件中加入以下内容，指定 jsp 文件的打包位置： pom.xml12345678910111213141516171819202122232425&lt;resources&gt; &lt;!-- 打包时将 jsp 文件拷贝到 META-INF 目录下 --&gt; &lt;resource&gt; &lt;!-- 指定 resources 插件处理那个目录下的资源文件 --&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;!-- 指定必须要放在此目录下才能被访问到 --&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt;&lt;/resources&gt; 在插件中指定入口类： 12345&lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;jvmArgument&gt;-Dfile.encoding=UTF-8&lt;/jvmArgument&gt; &lt;mainClass&gt;com.XXX.Application.class&lt;/mainClass&gt;&lt;/configuration&gt; 在启动类中，继承 SpringBootServletInitiallizer 类，重写 configure() 方法进行配置: 123456public class xxxApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(xxxApplication.class); &#125;&#125; 注意： 打成的 war 包使用外部 Tomcat 部署时，项目配置文件中配置的端口和项目名称会失效。 后台方式启动 jar 包：nohup java -jar jar包名称 &amp;"},{"title":"一些 API 说明","path":"/wiki/编程后花园/Java/随笔/JavaAPI.html","content":"一、Java Api 1. 文件监听 背景：之前第三方系统使用 FTP 传输一些静态资源到服务器的指定文件夹中，包含图片、视频、txt 文本文件。其中需要读取 txt 的文本内容，并将其整理落库。本来想使用 js 脚本处理的，后来领导说尽量写在一起。于是使用该 API 实现。 WatchService 接口可以用来实现对系统的文件进行监听。 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void watchFileTest() &#123; // 监听路径 String path = &quot;D:\\\\&quot;; try &#123; // 创建 WatchService 实例 WatchService watchService = FileSystems.getDefault().newWatchService(); // 这里只监听 创建 事件 // 除此之外，还有修改、删除、特殊事件 // StandardWatchEventKinds.ENTRY_MODIFY // StandardWatchEventKinds.ENTRY_DELETE // StandardWatchEventKinds.OVERFLOW Paths.get(path).register(watchService, StandardWatchEventKinds.ENTRY_CREATE); while (true) &#123; // 一直等待事件，如果没有就阻塞 // 如果对事件不是那么敏感，可以使用 watchService.poll(long timeout, TimeUnit unit) 每隔多少时间获取一次 WatchKey key = watchService.take(); // 获取事件列表 List&lt;WatchEvent&lt;?&gt;&gt; events = key.pollEvents(); // 由于只监听了一种事件，这里使用流处理。 events.stream() .filter(e -&gt; Objects.equals(e.kind(), StandardWatchEventKinds.ENTRY_CREATE)) .forEach(e -&gt; &#123; String fileName = e.context().toString(); System.out.println(&quot;创建了 [&quot; + fileName + &quot;] 文件&quot;); try &#123; // 休眠 1ms 是为了让系统完成相应的回调函数， // 否则你会看到输出多次 ”创建了 [&quot; + fileName + &quot;] 文件“ 内容 Thread.sleep(100); &#125; catch (InterruptedException ex) &#123; throw new RuntimeException(ex); &#125; &#125;); // 重置 watchKey 继续监听文件夹的事件 key.reset(); &#125; &#125; catch (IOException | InterruptedException e) &#123; throw new RuntimeException(e); &#125;&#125; 2. ServiceLoader 获取某个接口的所有实现类 Java 6 引入了一个新功能，用于发现和加载与给定接口匹配的实现：Service Provider Interface (SPI)。SPI 的核心是 ServiceLoader 类。它具有延迟发现和加载实现的作用。它使用上下文类路径来查找提供程序实现并将它们放在内部缓存中。可以参见官方文档：https://docs.oracle.com/javase/tutorial/ext/basics/spi.html 12345@Testpublic void testServiceLoader() &#123; java.util.ServiceLoader&lt;AssetsStrategy&gt; strategies = java.util.ServiceLoader.load(AssetsStrategy.class); strategies.forEach(System.out::println);&#125; 当然，如果直接执行以上代码是没有任何打印内容的。因为它还需要一点儿额外的配置。你需要在 resources/META-INF 目录下新建 services 目录，然后在新建的目录中添加一个文件，这个 文件名 必须是接口的 所在包路径+接口名称全限定名称，不带任何后缀，且区分大小写。最后按照同样的格式把实现了该接口的实现类写到该文件中。 以上面的测试方法举个栗子，AssetsStrategy 是一个接口，该接口位于 com.example.strategy 包，并且它有 Model1、Model2 两个实现类。在 resources/META-INF/services/com.example.strategy.AssetsStrategy 文件中（该文件必须采用 UTF-8 编码）添加以下内容： resources/META-INF/services/com.example.strategy.AssetsStrategy12com.example.model.Model1com.example.model.Model2 然后运行上面的测试代码，就可以看到结果啦~ 3. JUC LockSupport LockSupport 可以实现线程的阻塞和释放，并且该类对外提供的方法都是静态方法：parkxxx 阻塞线程，unparkxxx 唤醒被阻塞的线程。"},{"title":"Java使用各种工具问题总结","path":"/wiki/编程后花园/Java/随笔/Java使用各种工具问题总结.html","content":"一、Java 1. Excel文件导出中文名称时被转义 12String fileName = URLEncode.encode(name, &quot;UTF-8&quot;);response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename*=utf-8&#x27;zh_cn&#x27;&quot; + fileName + &quot;.xlsx&quot;); 文件的下载在响应之前要设置以 附件（attachment） 的形式，否则点击下载时会在浏览器打开。 Spring MVC 默认的上传文件大小(max-request-size)最大为10M，可以在配置文件中修改。 二、Spring 1. Spring Security 5.x 跨线程获取用户信息 使用 Spring Security 时，如果采用异步方法获取用户信息是获取不到的，它采用 ThreadLocal 存储，这样的话有些请求无法顺利执行，可以在 Spring Boot 启动类主方法添加： 12345public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); // 开启本地线程共享 SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);&#125; 2. swagger 如果在项目中实现 ResponseBodyAdvice 接口统一封装 controller 返回的接口，访问 swagger 地址时会出现弹窗 Unable to infer base url. This is common when using dynamic servlet registration or when the API is behind an API Gateway 的问题。 需要在实现 ResponseBodyAdvice 的类注解上额外加入 @RestControllerAdvice(basePackages = &quot;xxx.xx.controller&quot;) 限定需要对返回结果进行封装的范围，这样的话就不会拦截 swagger 相关资源的地址，访问就正常了。 也可以下面这样修改（浪子没有测试，具体见：https://juejin.cn/post/6921700441038258189）： 123456789101112131415161718192021@RestControllerAdvice// @RestControllerAdvice(basePackages = &quot;com.example.controller&quot;) // 只对此包中的类进行结果封装public class ResultResponseHandler implements ResponseBodyAdvice &#123; @Override public boolean supports(MethodParameter returnType, Class converterT ype) &#123; // 过滤不需要封装的结果 if (returnType.getParameterType().isAssignableFrom(ResultResp.class)) &#123; return false; &#125; return true; &#125; @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; if (body instanceof Json || body instanceof UiConfiguration || (body instanceof ArrayList &amp;&amp; ((ArrayList) body).get(0) instanceof SwaggerResource)) &#123; return body; &#125; return ResultResp.success(body); &#125; 3. 跨域 注解方式全局配置MVC全局配置xxxController.java12345// 注解用在 Controller 类中，该类所有方法允许其它域中进行访问@CrossOriginpublic class xxxController &#123;&#125;CorsConfig.java1234567891011121314@Configurationpublic class CorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowedOrigins(&quot;*&quot;); config.setAllowedHeaders(&quot;*&quot;); config.setAllowedMethods(&quot;*&quot;); // 处理所有请求的跨域配置 source.registerCorsConfiguration(&quot;/**&quot;, config); return new CorsFilter(source); &#125;&#125;WebMvcConfig.jav1234567891011121314151617181920@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; /** * 跨域访问（CORS） * * @param registry */ @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowCredentials(false) // 所有头 .allowedHeaders(&quot;/**&quot;) // 所有源 .allowedOrigins(&quot;/**&quot;) // 所有方法 .allowedMethods(&quot;/**&quot;) .maxAge(5000); &#125;&#125; 4. 在 Filter 中注入 Spring Bean 在 Spring Web 中，执行顺序是 context-param–&gt;listener–&gt;filter–&gt;servlet，可以看到 servlet 是在最后的，所以在 Filter 中注入 Bean 的时候就会报 NPE，如果是 SpringBoot 项目，可以在 Filter 的实现类上使用 @Order 注解延迟加载，让 Bean 先行加载，这样就可以在 Filter 中注入了。 三、MyBatis/MyBatis Plus（MP） MP官方文档https://www.baomidou.com/pages/24112f/ Result Maps collection does not contain value for ……在 SQL 文件中使用了 resultType=&quot;java.util.map&quot;，并且不止一处使用，那么凡是使用 resultType 或者 resultMap 这种属性的标签，不能有属性指向错误，否则就会报错： “Result Maps collection does not contain value for ……” Parameter index out of range (2 > number of parameters, which is 1).不能在 mybatis 的 sql.xml 中的 sql 标签（&lt;select&gt;、&lt;update&gt;、&lt;delete&gt;等）中注释 sql 语句，如果注释的语句中 带有参数，那么就会报这个错误。如果有必须注释的语句，把相关语句复制一份放在 mybatis 标签外面使用&lt;!-- 注释 sql 内容 --&gt; 注释。如果可以，还是把 SQL 语句存储在外部的 txt 等文本文件里。 org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)有这个错误的话就是 mapper 接口和对应的 xml 文件没有绑定，或者绑定了，但是 xml 文件不是在 resources/mapper 路径下。需要在项目的 pom.xml 中添加以下内容：pom.xml123456789101112131415161718192021&lt;!-- 把 xml 文件一起打包 --&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 1. $ And # 这个我想很多人都知道使用哪个比较好了，说说问题。具体语句省略，请注意循环内的条件。 123456789101112select * from user uleft join address a on u.address = a.sitewhere a.longitude = #&#123;longitude&#125; and a.latitude = #&#123;latitude&#125;&lt;if test=&quot;mallId != null and mallId != &#x27;&#x27;&quot;&gt; and u.mallId = #&#123;mallId&#125;&lt;/if&gt;&lt;if test=&quot;propertyType != null and propertyType.size() &gt; 0&quot;&gt; and u.property_type in &lt;foreach collection=&quot;propertyType&quot; index=&quot;index&quot; item=&quot;type&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; $&#123;type&#125; &lt;/foreach&gt;&lt;/if&gt; 上面的语句在循环中使用了 $&#123;&#125;，我把它修改成了 #&#123;&#125;，但是输入的筛选的条件是不会生效的，继而没有返回数据。 之后看了看它传的参数，发现接口接收的字符串，然后在业务层转为字符串集合，并且为每个元素加入单引号后传入 SQL 的。 123456789101112private static List&lt;String&gt; getParamList(String propertyType) &#123; List&lt;String&gt; paramList = new ArrayList(); if (!StringUtils.isEmpty(propertyType.trim())) &#123; String[] split = propertyType.split(&quot;,&quot;): for （int i = θ;i&lt; split.length; i++）&#123; split[i] = &quot;&#x27;&quot; + split[i] + &quot;&#x27;&quot;; paramlist.add(split[i]); &#125; &#125; log.debug(&quot;propertyType list : &#123;&#125;&quot;, paramlist); return paramlist; &#125; 于是猜想可能就是这个原因导致查询条件不生效，于是把这段代码改成了下面的样子： 1234567private static List&lt;String&gt; getParamlist(String str) &#123; List&lt;String&gt; result = null; if (!StringUtils.isEmpty(str.trim())) &#123; result = Arrays.stream(str.split(&quot;,&quot;)).map(String::trim).collect(Collectors.toList(O); &#125; return result;&#125; 这段代码没有给分割后的字符加入英文单引号，map 方法对每一个元素都去掉前后的空格（请结合自身业务场景确定参数是否可包含空格，浪子这里不需要），然后再次测试该接口，perfect！it is working now! 之后使用修改后的字符转集合方法代码再次使用 $&#123;&#125; 去测试，发现 SQL 语句查询又不生效了。。。 于是浪子明白了：使用 $&#123;&#125; 时，参数为 List 类型需要我们为每个元素手动加入单引号，使用单引号包裹才会生效；而使用 #&#123;&#125; 时，List 参数类型则不需要我们手动加入英文单引号，直接传入 List 即可。 2. 接口传参报错 错误信息： 1No primary or default constructor found for interface java.util.List] 后端使用 List&lt;String&gt; 或者数组接参数收时，前端传入数组接收不到；但是可以传字符串，每个元素可以使用英文 , 分割。 3. MP插入或更新null值 当使用 Mybatis Plus 时，更新数据为 null 值时，即使数据库的字段设置为可以为 null，但是更新或插入时还是数据更新失败。这个就涉及到字段验证策略了。MP 官网也给出了 解决办法 4. mapper.xml 在 mapper.xml 中编写 SQL 语句时有部分字符需要转义才可以被框架正确的解析： 转义字符 含义 说明 &amp;gt; &gt; greater than &amp;lt; &lt; less than &amp;amp; &amp; 也可以使用 &lt;![CDATA[]]&gt; 来声明语句，被这个标记所包含的内容将表示为纯文本。"},{"title":"Java 编写 WebSocket","path":"/wiki/编程后花园/Java/随笔/Java编写WebSocket.html","content":"WebSocket Java 中使用 WebSocket 的方式一般下面几种： 使用 Java 提供的 @ServerEndpoint 注解实现 使用 Spring 提供的低层级 WebSocket API 实现 使用 STOMP 消息实现 使用 Java 注解 这也是常用的一种方式： @ServerEndpoint：暴露出去的 ws 服务访问的路径，有点类似我们经常用的 @RequestMapping； @OnOpen：当 websocket 建立连接成功后会触发这个注解修饰的方法，它有一个 Session 参数； @OnClose：当 websocket 建立的连接断开后会触发这个注解修饰的方法，它有一个 Session 参数； @OnMessage：当客户端发送消息到服务端时，会触发该注解的方法体执行，它有一个 String 入参表明客户端传入的值； @OnError：当 websocket 建立连接时出现异常会触发这个注解修饰的方法，它有一个 Session 参数； 以上几个注解都在 javax.websocket 包下。 连接端点ws config1234567891011121314import javax.websocket.OnMessage;import javax.websocket.Session;import javax.websocket.server.ServerEndpoint;import java.io.IOException; @ServerEndpoint(&quot;/ws/test&quot;)public class TestWebSocketEndpoint &#123; @OnMessage public void handleMessage(Session session, String message) throws IOException &#123; session.getBasicRemote().sendText(&quot;requtest text: &quot; + message); &#125; ...&#125;123456789@Configuration@EnableWebSocketpublic class WebSocketConfig&#123; @Bean public ServerEndpointExporter serverEndpointExporter() &#123; return new ServerEndpointExporter(); &#125;&#125; 使用 Spring 的 WS 实现 通过继承 TextWebSocketHandler 类并进行方法覆写，可以对 websocket 的事件进行处理： afterConnectionEstablished() 方法在 socket 连接成功后被触发，同 Java 注解里的 @OnOpen 功能; afterConnectionClosed()方法在 socket 连接关闭后被触发，同 Java 注解里的 @OnClose 功能; handleTextMessage() 方法是在客户端发送信息时触发，同原生注解里的 @OnMessage 功能。 Handler 示例ws config12345678910111213141516171819202122232425262728import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.socket.CloseStatus;import org.springframework.web.socket.TextMessage;import org.springframework.web.socket.WebSocketSession;import org.springframework.web.socket.handler.TextWebSocketHandler;import java.text.MessageFormat;public class MyTextHandler extends TextWebSocketHandler&#123; private final Logger logger = LoggerFactory.getLogger(getClass()); @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; logger.debug(&quot;Opened new session in instance &quot; + this); &#125; @Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123; session.sendMessage(new TextMessage(&quot;request: &quot; + message.toString())); &#125; @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; session.close(CloseStatus.SERVER_ERROR); logger.debug(&quot;Info: WebSocket connection closed.&quot;); &#125;&#125;123456789101112131415@Configuration@EnableWebSocketpublic class WebSocketConfig implements WebSocketConfigurer&#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; registry.addHandler(echoWebSocketHandler(), &quot;/customertest&quot;); registry.addHandler(echoWebSocketHandler(), &quot;/customertest_sockjs&quot;).withSockJS(); &#125; @Bean public WebSocketHandler myTextHandler()&#123; return new MyTextHandler(); &#125;&#125; 使用 STOMP STOMP(Simple Text Oriented Messaging Protocol)，就是在 WebSocket 基础之上提供了一个基于帧的线路格式（frame-based wire format）层。它对发送简单文本消息定义了一套规范格式（STOMP 消息基于 Text，当然也支持传输二进制数据），目前很多服务端消息队列都已经支持 STOMP，比如：RabbitMQ、 ActiveMQ 等。 通过实现 WebSocketMessageBrokerConfigurer 接口并加上 @EnableWebSocketMessageBroker 来进行 stomp 的配置与注解扫描。 ws configcontroller1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.messaging.simp.config.ChannelRegistration;import org.springframework.messaging.simp.config.MessageBrokerRegistry;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer&#123; /** * 暴露的 stomp 的路径 */ @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; // 配置客户端尝试连接地址 registry.addEndpoint(&quot;/ws&quot;).setAllowedOrigins(&quot;*&quot;).withSockJS(); &#125; /** * 节点配置 */ @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; // 设置广播节点 registry.enableSimpleBroker(&quot;/topic&quot;, &quot;/user&quot;); // 客户端向服务端发送消息需有 /api 前缀 registry.setApplicationDestinationPrefixes(&quot;/api&quot;); // 指定用户发送（一对一）的前缀 /user/ registry.setUserDestinationPrefix(&quot;/user/&quot;); &#125; @Autowired private CustomerInterceptor customerInterceptor; @Override public void configureClientInboundChannel(ChannelRegistration registration) &#123; registration.interceptors(customerInterceptor); &#125;&#125;/** * 使用自定义拦截器打印一下 ws 断开的通知信息 */@Componentpublic class CustomerInterceptor implements ChannelInterceptor &#123; private final Logger logger = LoggerFactory.getLogger(getClass()); @Override public void afterSendCompletion(Message&lt;?&gt; message, MessageChannel channel, boolean sent, Exception ex) &#123; StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message); StompCommand command = accessor.getCommand(); //用户已经断开连接 if(StompCommand.DISCONNECT.equals(command))&#123; String user = &quot;&quot;; Principal principal = accessor.getUser(); if(principal != null &amp;&amp; StringUtils.isNoneBlank(principal.getName()))&#123; user = principal.getName(); &#125;else&#123; user = accessor.getSessionId(); &#125; logger.debug(MessageFormat.format(&quot;用户&#123;0&#125;的WebSocket连接已经断开&quot;, user)); &#125; &#125;&#125;12345678910111213141516171819@Controllerpublic class WsController &#123; /** * 如果服务端主动发送消息可以通过 SimpMessagingTemplate 类的 convertAndSend 方法 */ @Autowired private SimpMessagingTemplate simpMessagingTemplate; /** * @MessageMapping 注解用于监听指定路径的客户端消息，比如客户端需要访问 ws:ip:port/api/hello，api 是 ws config 中配置的前缀 * @SendTo 注解则用于服务端将消息发送监听了该路径的客户端 */ @MessageMapping(&quot;/hello&quot;) @SendTo(&quot;/topic/ws&quot;) public String test(String message) &#123; System.out.println(&quot;接收消息：&quot; + message); return &quot;Hello,&quot; + messgae + &quot;!&quot;; &#125;&#125; 除了上面的几种之外，还有其它大神编写的 ws 实现库，例如 TIO 等，它的时候方法相差不大。"},{"title":"Java解析MySQL的binlog日志","path":"/wiki/编程后花园/Java/随笔/Java解析mysql-binlog数据.html","content":"由于工作需要，研究了一下 Java 解析 MySQL 的 binlog，使用第三方封装的库，可以获取实时插入的信息数据，满足要求。总体看下来使用还是很简单的。 引入 binlog 的解析库 pom.xml12345&lt;dependency&gt; &lt;groupId&gt;com.zendesk&lt;/groupId&gt; &lt;artifactId&gt;mysql-binlog-connector-java&lt;/artifactId&gt; &lt;version&gt;0.28.0&lt;/version&gt;&lt;/dependency&gt; Github：https://github.com/osheroff/mysql-binlog-connector-java 编码 12345678mysql: binlog: hostname: localhost port: 3306 schema: tb_exp username: root password: root table-list: exp_user 123456789101112131415161718@Data@Component@ConfigurationProperties(prefix = &quot;mysql.binlog&quot;)public class BinlogProperty &#123; private String hostname; private String port; private String username; private String password; /** * 数据库 */ private String schema; /** * 监听的表集合 */ private List&lt;String&gt; tableList;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180/** * binlog * * @author jhlz * @since 2023/5/29 9:57 */@Componentpublic class BinlogUtil1 &#123; private static final Logger log = LoggerFactory.getLogger(BinlogUtil.class); @Autowired private BinlogProperty binlogProperty; /** * 数据库名称 map */ private static final Map&lt;Long, String&gt; TABLE_MAP = new HashMap&lt;&gt;(); /** * 异步线程处理 binlog，防止阻塞主线程 */ @PostConstruct public void handle() &#123; ThreadUtil.execAsync(() -&gt; &#123; binlogListening(); log.info(&quot;正在监听 &lt;&#123;&#125;:&#123;&#125;:&#123;&#125;&gt; binlog……&quot;, binlogProperty.getHostname(), binlogProperty.getSchema(), binlogProperty.getTableList()); &#125;); &#125; /** * binlog 监听 */ public void binlogListening() &#123; BinaryLogClient client = new BinaryLogClient(binlogProperty.getHostname(), Integer.valueOf(binlogProperty.getPort()), binlogProperty.getUsername(), binlogProperty.getPassword()); client.setServerId(1); // 注册监听 client.registerEventListener(event -&gt; &#123; EventData data = event.getData(); EventType eventType = event.getHeader().getEventType(); if (Objects.equals(EventType.TABLE_MAP, eventType)) &#123; TableMapEventData tableMapEventData = (TableMapEventData) data; String database = tableMapEventData.getDatabase(); String tableName = tableMapEventData.getTable(); // 目标明确！缓存指定数据库以及指定的表名 if (Objects.equals(binlogProperty.getSchema(), database) &amp;&amp; binlogProperty.getTableList().contains(tableName)) &#123; TABLE_MAP.put(tableMapEventData.getTableId(), tableName); &#125; &#125; // 新增的 binlog 数据 if (EventType.isWrite(eventType)) &#123; WriteRowsEventData wr = (WriteRowsEventData) data; // 获取表名称 String tableName = TABLE_MAP.get(wr.getTableId()); if (Objects.nonNull(tableName)) &#123; log.info(&quot;&#123;&#125; =============== INSERT&quot;, tableName); System.out.println(wr.toString()); &#125; &#125; // 更新的 binlog 数据 if (EventType.isUpdate(eventType)) &#123; UpdateRowsEventData ur = (UpdateRowsEventData) data; String tableName = TABLE_MAP.get(ur.getTableId()); if (Objects.nonNull(tableName)) &#123; log.info(&quot;&#123;&#125; =============== UPDATE&quot;, tableName); System.out.println(ur.toString()); &#125; &#125; &#125;); // 连接服务 connectServer(client); &#125; /** * 获取指定索引位置的最新值，如果是批量，只拿第一条记录的值 * * @param data binlog 数据 * @param index 数据库目标字段的索引位置，起始索引 0 * @return 目标索引位置的值或者 null */ public static String getValueByIndex(EventData data, int index) &#123; // 新增事件 if (data instanceof WriteRowsEventData) &#123; WriteRowsEventData wr = (WriteRowsEventData) data; BitSet includedColumns = wr.getIncludedColumns(); // 如果该位置有值为 true，否则是 false if (includedColumns.get(index)) &#123; List&lt;Serializable[]&gt; rows = wr.getRows(); // 只拿第一条记录的值 Serializable[] arr = rows.get(0); // 需要判空，如果一条数据中某列的值为 null 则 NPE if (Objects.nonNull(arr[index])) &#123; return arr[index].toString(); &#125; &#125; &#125; // 更新事件 if (data instanceof UpdateRowsEventData) &#123; UpdateRowsEventData ur = (UpdateRowsEventData) data; BitSet includedColumns = ur.getIncludedColumns(); if (includedColumns.get(index)) &#123; // 只获取第一条记录 Map.Entry&lt;Serializable[], Serializable[]&gt; entry = ur.getRows().get(0); // entry 的 key 为旧值，value 为更新值 Serializable[] newValue = entry.getValue(); if (newValue[index] != null) &#123; return newValue[index].toString(); &#125; &#125; &#125; return null; &#125; /** * 获取事件数据指定索引位置的值 * * @param data binlog 数据 * @param index 数据库目标字段的索引位置 * @param key 数据库目标字段的名称 * @return map，键为传入的 key 值，值为 binlog 读取的新值 */ private static List&lt;Map&lt;String, Object&gt;&gt; getValueByIndex(EventData data, int index, String key) &#123; List&lt;Map&lt;String, Object&gt;&gt; res = new ArrayList&lt;&gt;(); if (data instanceof WriteRowsEventData) &#123; WriteRowsEventData wr = (WriteRowsEventData) data; BitSet includedColumns = wr.getIncludedColumns(); if (includedColumns.get(index)) &#123; // 获取每一行的值，Serializable[] 一条记录的所有值 List&lt;Serializable[]&gt; rows = wr.getRows(); // TODO 批量插入不清楚什么格式，先循环吧，使用 MAP 装载结果，后面出问题再调试 rows.forEach(r -&gt; &#123; // 拿到索引位的值 Serializable value = r[index]; // 若 value 为 null，则抛出 NPE if (Objects.nonNull(value)) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(key, value); res.add(map); &#125; &#125;); &#125; &#125; if (data instanceof UpdateRowsEventData) &#123; UpdateRowsEventData ur = (UpdateRowsEventData) data; BitSet includedColumns = ur.getIncludedColumns(); if (includedColumns.get(index)) &#123; ur.getRows().forEach(u -&gt; &#123; Serializable[] newValue = u.getValue(); Serializable obj = newValue[index]; if (Objects.nonNull(obj)) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(key, obj); res.add(map); &#125; &#125;); &#125; &#125; return res; &#125; /** * 连接服务器 * * @param client 客户端 */ private static void connectServer(BinaryLogClient client) &#123; try &#123; client.connect(); &#125; catch (IOException e) &#123; log.error(&quot;连接失败：&#123;&#125;&quot;, e.getMessage()); throw new RuntimeException(e); &#125; &#125;&#125;"},{"title":"MQ","path":"/wiki/编程后花园/Java/随笔/MQ.html","content":"消息队列 队列我们都知道是一种数据结构，从头部插入，从尾部删除。而消息队列就是在这种结构上进行完善而来，消息队列可以帮助程序实现解耦、异步、削峰，从而实现程序的高可用。 说到消息队列，就会有两个概念：生产者和消费者。这两个概念也是非常简单的，就和现实生活中的供给、需求是一样的。生产者生产产品，消费者消费产品。 解耦就是降低耦合度，假如我们需要给多个系统发送消息，就可以引入 MQ 进行处理，我们的系统只用把消息推送到 MQ 中，然后让其他系统订阅我们的主题，只要订阅了，就可以从 MQ 中获取到数据。这样我们就不用考虑调用其它系统时会发生的种种问题了，只要确保消息能够正确到达 MQ 中即可。 异步就非常简单了，现在的语言基本都有异步编程框架了。 削峰就是流量高峰期把 “流量信息” 都发送到 MQ 中，然后后续根据消费者的速度去慢慢处理，知道这些信息被消费者处理完。 典型的就是电商，时不时的搞一些大促（秒杀活动），流量会高于平时几十倍几百倍…大促的时候，举个例子假如是 5000 单，如果说下单要实时操作数据库，假设数据库最大承受每秒 2000 单，那么促销的时候数据库会挂掉导致系统直接不可用，那是多么严重的事情。 所以在这种场景下使用 MQ 完美的解决了这个问题，下游系统下单时只需要往 MQ 里发消息，我的订单系统可以设定消费的频率，比如每秒我就消费 2000 个消息（在数据库的可承受范围），不管你下游系统每秒下多少单，我都保持这个速率，既不会影响订单系统的数据库，也不影响下游系统的下单操作，很好的保护了系统，也提高了下单的吞吐量。 一般来说，大促会持续几分钟，往多了就说 4 个小时吧，每秒 5000，4 小时 7200W 单往 MQ 里写，订单系统每秒消费 2000 单，大促过后，MQ 里会积压 4320W 个消息，剩下的就慢慢消费呗。当然了，大促的时候肯定会临时申请加机器的，每秒消费可能不止2000。 这就是削峰，将某一段时间的超高流量分摊到更长的一段时间内去消化，避免了流量洪峰击垮系统。 想必大家随着开发经验的增长，都会意识到一样东西：引入一个中间件，系统的维护复杂度就会高起来。这也是没办法的。另外我们要确保消息的一致性以及 MQ 系统的高可用，很多系统都依赖于此，MQ 系统是不能出现问题的，一旦出现问题，就会发生“多米诺骨牌”效应。 RabbitMQ RabbitMQ是轻量级的，在AMQP（Advanced Message Queuing Protocol ）基础上实现的，易于在本地和云中部署。它支持多种消息传递协议。RabbitMQ 可以部署在分布式和联合配置中，以满足高规模、高可用性的需求。 一、介绍 RabbitMQ 在许多操作系统和云环境上运行，并为大多数流行语言提供了广泛的开发人员工具。比如提供了 Java、Spring Framework、.NET、Ruby、Python、PHP、JS、GO等语言的客户端、适配器和工具。 官方学习教程https://www.rabbitmq.com/getstarted.html 1. RabbitMQ的几种模型 二、操作 RabbitMQ的常用命令 1234567891011121314rabbitmqctl list_users # 查看用户列表rabbitmqctl add_user admin 123456 #添加用户名和密码rabbitmqctl set_permissions -p /admin&quot;.*&quot; &quot;.*&quot; &quot;.*&quot; #修改权限rabbitmqctl set_user_tags admin administrator #添加用户角色#守护模式启动（后台运行）rabbitmq-server -detached# 停止服务rabbitmqctl stop# 查看状态rabbitmqctl status # 重启 rabbitmq 服务rabbitmq-server restart 启用插件的同时并启动服务：rabbitmq-plugins enable rabbitmq_management，这个插件是 RabbitMQ 自带的，便于我们查看系统的状态数据，启用这个插件之后才可以使用 http://IP地址:15672 访问网页管理页面，查看具体信息。默认登录的初始账号密码为 guest。 注意： 在较新的版本中，默认的账号只能以本地 localhost 的方式访问，如果服务在远程启动，本地进行远程访问操作时登录可能会出现 User can only log in via localhost 的情况，解决办法就是新添加一个超级管理员账户，使用这个新添加的账户登录。 5672 用于客户端使用，15672 用于网页控制。 镜像队列：（使用最多） 123456# 策略说明rabbitmqctl set_policy [-p &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt; &lt;definition&gt;# 查看当前策略：rabbitmqctl list_policies# 删除队列：rabbitmqctl clear_policy ha-all -p vhost 可选参数，针对指定 vhost 下的 queue 进行设置 name: policy 的名称 pattern: queue 的匹配模式（正则表达式） definition: 镜像定义，包括三个部分ha-mode、ha-params、ha-sync-mode ha-mode 指明镜像队列的模式，有效值 all/exactly/nodes all 表示在集群所有的节点上进行镜像 exactly 表示在指定个数的节点上进行镜像，节点的个数由 ha-params 指定 nodes 表示在指定的节点上进行镜像，节点名通过 ha-params 指定 ha-params: ha-mode 模式需要用到的参数 ha-sync-mode: 进行队列中消息的同步方式，有效值为 automatic 和 manual priority: 可选参数，policy 的优先级。"},{"title":"gRPC","path":"/wiki/编程后花园/Java/随笔/gRPC.html","content":"RPC 框架有 Hession、Thrift、gRPC 等。 gRPC gPRC：Google 开源的高性能的 RPC 框架，gRPC 是一个可在任何环境中运行的现代开源高性能远程过程调用（RPC）框架。它可以高效地连接数据中心内和数据中心间的服务，并为负载平衡、跟踪、健康检查和身份验证提供可插拔的支持。它还适用于分布式计算，将设备、移动应用程序和浏览器连接到后端服务。 gRPC 的核心设计思路： 网络通信：gPRC 自己封装的网络通信，提供多种语言的网络通信； 协议：采用 HTTP2.0 协议； 序列化：采用 protobuf(Protocol Buffers)， Google 开源的一种序列化方式。 代理的创建：stub（存根/桩）调用者像调用本地方法一样调用远端的方法。 HTTP2 传输数据使用的二进制数据内容，传输体量较小，支持双向流（双工） gRPC 与 Thrift 都是支持异构语言的 RPC。 区别 Thrift gRPC 网络通信 TCP 专属协议（传输层协议，更快） HTTP2.0（应用层协议，相对于 Thrift 的 TCP 慢） 性能 Thrift 性能高于 gRPC - 使用范围 社区活跃 大厂背书，云原生时代，与其它组件合作顺利，所以 gRPC 应用更广 gRPC 的优点： 高效的进行进程间通信； 支持多语言，原生支持 C、GO、Java 实现。C 语言版本上扩展 C++、C#、NodeJS、Python、Ruby、PHP； 支持多平台； gRPC 序列化采用 protobuf，效率高； 使用 HTTP2.0 协议； HTTP 协议 HTTP1.x HTTP1.0：请求响应模式，短连接无状态协议；传输的数据主要是文本结构，单工协议（客户端请求服务端，服务端无法主动推送内容到客户端） HTTP1.1：请求响应模式，有限的连接（Connection：keep-alived），会保持一段时间，减少传输的数据(有时候刷新页面但是 SSL 并不刷新)；升级的方式：WebScoket 协议实现双工，实现服务端向客户端推送。 HTTP1.x 主要有以下特点： 传输数据文本格式，可读性好但是效率差； 本质上 无法实现双工通信； 请求资源需要发送多次请求，建立多个连接； HTTP 协议基于 TCP 协议（长连接），但是有自己的设计实现，响应之后会自己断掉，所以 HTTP 是短连接协议。 HTTP2.0 二进制协议，效率高于 HTTP1.x，可读性差； 可以实现双工通信； 采用多路复用技术，一个请求/连接可以请求多个数据； HTTP2.0 协议的三个概念： 数据流（stream） 消息（message） 帧（frame） 如上图所示，一次连接发送多个流，流中带有消息，消息由帧组成，帧中包含了请求或者响应的数据。在 HTTP2.0 的设计中，可以通过为不同的 stream 设置权重，来限制不同流的传输顺序，比如先发送 css stream 还是 js stream； 并且，如果 Client 发送的数据太快，Server 处理不过来，则可以通知 Client 暂停数据的发送实现流控。 序列化 protobuf 是一种与编程语言无关，与具体的平台无关，定义的中间语言，可以在 client 和 server 中进行 RPC 的数据传输。protobuf 有两个版本，proto2、proto3，目前主流应用是 proto3。 使用 protobuf 需要安装对应的编译器，需要把 protouf 的 IDL 语言转换成具体的编程语言。"},{"title":"volatile 关键字","path":"/wiki/编程后花园/Java/随笔/volatile.html","content":"本篇文章需要掌握JMM（Java Memory Model） 介绍 volatile 在多线程环境下可以保证共享数据的可见性，但不保证数据操作的原子性（线程不安全）。要想保证线程安全，还是需要锁机制或者使用原子类（原子类内部已使用 volatile 保证了可见性）。 为了提高 CPU 的运行效率，JVM 会对一些代码进行重新排序。volatile 修饰变量可以实现禁止指令重排序，修正重排序带来的并发安全问题。 happens-before规则 我们知道为了提高处理速度，JVM 会进行指令重排序优化，在并发编程下可能会带来一些安全隐患，比如 重排序导致的多个线程之间的不可见性。如果让程序员去了解这些底层的实现以及具体的规则，那么我们的负担就太重了，会影响并发编程的效率。 从 JDK5 开始，提出了 happens-before 概念：如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。简单来说，就是前一个操作的结果可以被后续的操作获取。 happens-before 规则可以理解为对 JVM 的约束规则。它在编译优化的同时，依然保证了多线程的可见性。 happens-before的几个规则 程序顺序原则：同一个线程中前面所有的写操作都对后续操作可见（一个线程内保证语义的串行性）。 锁规则：在线程1解锁之前的所有写操作都对后续加锁的线程可见（unlock必然发生在随后的加锁lock前）。 volatile 规则：如果线程1写入 volatile 变量v，接着线程2读取了这个值，线程1写入 v 之前的写操作都对线程2可见（volatile 变量的写先发生于读，保证了 volatile 变量的可见性）。 传递性：如果 A happens-before B，B happens-before C，那么 A happens-before C。 start() 规则：如果在线程 A 中启动线程 B，那么在线程 B 启动之前，线程 A 中对共享变量的修改都对线程 B 可见。需要注意的是，在线程 B 启动之后，线程 A 再对变量的修改线程 B 未必可见。线程的 start() 方法先于他的每一个动作。 join() 规则：对于线程 A 写入的所有变量，如果任一线程调用 A.join() 或者 A.isAlive() 成功返回后，那么 A 写入的变量都对该线程可见。线程的所有操作先于线程的终结。 线程的中断先于被中断线程的代码。 对象的构造函数执行、结束先于 finalize() 方法。 这些原则都是保证指令重排不会破环原有的语义结构。例如第二条锁原则，unlock必然发生在随后的lock前。如果对一个锁解锁后，再加锁，那么加锁的动作绝对不能重排在解锁前。 volatile使用场景 适合纯赋值操作，不适合类似 a++ 操作。 12345678910111213141516171819202122232425262728293031323334353637public class VolatileTest implements Runnable &#123; // 使用 public 是为了测试获取到结果值 public volatile boolean flag = false; public AtomicInteger atomicInteger = new AtomicInteger(0); @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; // 修改 flag 的值 switchFlag(); // +1 atomicInteger.incrementAndGet(); &#125; &#125; private void switchFlag() &#123; // 纯赋值操作符合预期 flag = true; // 不符合预期，可能为 true // flag = !flag; &#125;&#125;class Test03 &#123; public static void main(String[] args) throws InterruptedException &#123; VolatileTest v = new VolatileTest(); Thread t1 = new Thread(v); Thread t2 = new Thread(v); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(v.flag); System.out.println(v.atomicInteger.get()); &#125;&#125; volatile 可以适合做多线程中的纯赋值操作，如果一个共享变量自始至终只被各个线程赋值，而没有其它的操作，那么就可以用 volatile 来代替 synchronized 或者代替原子变量，因为赋值自身是有原子性的，而 volatile 又保证了可见性，所以足以保证线程安全。 volatile与synchronized volatile 只能修饰 实例变量 和 类变量，而 synchronized 可以修饰方法以及代码块。 volatile 保证数据的可见性，但是不保证原子性（多线程进行写操作，不保证线程安全）；而 synchronized 是一种排它（互斥）的机制。 volatile 用于禁止指令重排序，可以解决单例双重检查对象初始化代码执行乱序问题。 volatile 可以看作是轻量版的 synchronized，volatile 不保证原子性，但是如果对一个共享变量进行直接赋值而没有其它的操作，那么就可以用 volatile 来代替 synchronized，因为赋值本身是有原子性的，而 volatile 又保证了可见性，所以就可以保证线程安全了。 总结 volatile 修饰符适用于以下场景，某个属性被多个线程共享，其中一个线程修改了此属性，其它线程可以立即得到修改后的值；或者作为触发器，实现轻量级同步。 volatile 属性的读写操作都是无锁的，它不能代替 synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间去获取锁和释放锁，所以它是低成本的。 volatile 只能作用于属性，修饰的属性不会被 compilers 做指令重排序。 volatile 提供了可见性，任一个线程修改值后将立即对其它线程可见，volatile 属性不会被线程缓存，始终从主存中读取。 volatile 提供了 happens-before，保证其修饰的变量在写入 happens-before 后其它线程后续对该变量的读操作。 volatile 可以使得 long 和 double 的赋值是原子的。 volatile 可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。"},{"title":"微信公众号模板消息测试推送","path":"/wiki/编程后花园/Java/随笔/微信公众号模板消息测试推送.html","content":"微信公众号分为订阅号和服务号，订阅号不支持模板消息，但是每天可以群发消息；而服务号一个月可以群发四次消息。认证过的服务号是可以使用模板消息的，认证需要 money，而订阅号就需要有内测的权限，微信对订阅号正在启用模板消息灰度测试，所以很多是不能自己测试的。但是可以使用测试号。不过值得注意的是，测试号只能用于测试，不能用于向正是号推送消息等。 功能实现 首先申请测试号，测试号申请地址 申请登录之后，可以看到已经生成的 appID 和 appsecret，这两个是获取公众号的 accessToken 信息必不可少的。 对于公众号模板消息测试而言，接口配置信息 和 JS接口安全域名 可以略过不用配置。 测试号二维码需要关注，接收模板消息必须关注。模板消息接口需要按照要求增加一个模板。这样，准备工作就做好了，接下来可以进行代码了。 对应请求信息的 url 可以在 体验接口权限表 中点击对应的链接进行查看。 123456789101112// 请求获取 accessTokenprivate static String tokenApi = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=&quot; + grant_type + &quot;&amp;appid=&quot; + appid + &quot;&amp;secret=&quot; + secret;// 请求获取用户列表的 url GET请求:https://api.weixin.qq.com/cgi-bin/user/get?access_token=ACCESS_TOKEN&amp;next_openid=NEXT_OPENIDprivate static String userListUrl = &quot;https://api.weixin.qq.com/cgi-bin/user/get?access_token=&quot;;// 请求获取用户基本信息(UnionID机制) GET请求:https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CNprivate static String userInfoUrl = &quot;https://api.weixin.qq.com/cgi-bin/user/info?access_token=&quot;;// 发送模板信息 url POST请求:https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKENprivate static String sendUrl = &quot;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=&quot;; 问题解决 出现 &quot;errcode&quot;:40003,&quot;errmsg&quot;:&quot;invalid openid rid: 61b87426-7ecce312-0478a848&quot; 的错误： 解决方案： 设置发送对象的键为 touser，不要为 toUser 或者 openid 示例如下： 12345paramData.put(&quot;touser&quot;, openid);paramData.put(&quot;template_id&quot;, templateId);paramData.put(&quot;url&quot;, &quot;xxx/login&quot;);// data 为数据模板的 mapparamData.put(&quot;data&quot;, data);"},{"title":"时区和 Unicode","path":"/wiki/编程后花园/Programming/通用概念/时区和Unicode.html","content":"时区 如果高中的地理学得好的话基本没什么难度，编程语言中也经常见到：UTC、GMT、ISO 等。 GMT：格林尼治（又称格林威治）标准时间；英国伦敦格林尼治定为 0° 经线开始的地方，地球每 15° 经度被分为一个时区，共分为 24 个时区（东西经各 12 个时区），相邻时区相差一小时；例如：中国北京位于东八区，GMT 时间比北京时间慢 8 小时。 由于地球不是完美球体且自转速度在变慢，导致以格林尼治天文台为基准时间实际上是不精确的。 UTC：世界协调时间；经严谨计算得到的时间，精确到秒，误差在0.9s以内，是比GMT更为精确的世界时间；为了更准确度量时间，科学家们发明了UTC时间，以铯原子跃迁次数来度量时间，比 GMT 时间更准确，为了保证 GMT 的准确性，每隔几年 GMT 时间会做一次调整，以与UTC时间对齐。 CST：编程语言中，一般不使用 CST 来代表中国的时区时间（浪子之前在 Java 中使用，解析失败，后来才明白）。CST 有四个不同时区的缩写： Central Standard Time (USA) UT-6:00 美国标准时间 Central Standard Time (Australia) UT+9:30 澳大利亚标准时间 China Standard Time UT+8:00 中国标准时间 Cuba Standard Time UT-4:00 古巴标准时间 另外编程语言中输出时间你可能会见到下面的后缀： 格式 说明 UTC+8 东八区 GMT+8 同上 GMT+08:00 采用 GMT 时间并精确到分钟级别 GMT+08:00:00 采用 GMT 时间并精确到秒级别 GMT+0800 不显示冒号并采用 GMT 时间并精确到分钟级别 GMT+080000 不显示冒号并采用 GMT 时间并精确到秒级别 +08:00 精确到分钟级别 +08:00:00 精确到秒级别 除了上面的表示方式，还有以 区域/城市 的方式定义时区的，例如：Asia/Shanghai。如果你安装过 Linux 系统，大部分带有 GUI 的安装程序大都以该方式呈现。 最后说一下时间戳，1970年1月1日，这个日期也被称为 Unix 时间或 POSIX 时间，被许多 Unix 和类 Unix 系统和编程语言使用，如C/C++，Java，JavaScript，Perl，PHP，Python 和 Ruby 等等。 最初计算机操作系统是32位，而时间也是用32位表示。因此32位能表示的最大值是2147483647。另外 1 年 365 天的总秒数是 31536000，2147483647/31536000 = 68.1，也就是说32位能表示的最长时间是68年，从1970年开始的话，加上 68.1，实际最终到2038年01月19日03时14分07秒，便会达到最大时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000，算下来也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。使用 64 位整数数据类型来存储 Unix 时间可以解决此问题，因为它可表示的日期范围超过 5840 亿年。 参考： https://www.baeldung.com/linux/epoch-time https://zhuanlan.zhihu.com/p/399627424 ISO 8601：它是一种日期展现格式 YYYY-MM-DDTHH:mm:ss.sssZ；国内一般会使用 yyyy-mm-dd hh:mm:ss 的格式。还有很多其它格式，这里就不写在正文了，编程语言中格式化选项可能会默认提供（枚举类），在不同的国家使用不同的日期格式。 Unicode Unicode 被设计为通用，唯一和统一，即代码涵盖所有主要的现代书面语言（通用），每个字符只有一个编码（唯一），每个字符由固定宽度的inbits（统一）表示。 查询百度百科，它的介绍是这样的： 统一码（Unicode），也叫万国码、单一码，由统一码联盟开发，是计算机科学领域里的一项业界标准，包括字符集、编码方案等。 统一码是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 推荐看这篇文章：https://zhuanlan.zhihu.com/p/195497699 有兴趣想深入了解的话可以看看这个：https://home.unicode.org/ Unicode 是一种字符编码规范，而 UTF-8、UTF-16 等都是具体的实现，UTF-8 在如今被广泛使用。 我们常见的多是 UTF-8，Unix/Linux 的默认编码方案。UTF-8 编码方案之所以被广泛使用，是因为多种语言的文字和各种类型的符号可以混合在同一信息中，而不必像 UTF-16 或 UTF-32 那样为每个字符预留多个字节。在 UTF-8 中，如果只需要 ASCII 文本，则每个字符使用一个字节，高阶位设置为 0；如果非 ASCII 字符需要一个以上的字节，则由字节的高阶 1 位决定使用多少个字节。"},{"title":"线程与并发","path":"/wiki/编程后花园/Programming/通用概念/线程与并发.html","content":"线程与进程 当我们谈论线程时，通常指的是在一个进程中独立运行的执行单元。一个进程可以包含多个线程，每个线程共享进程的资源，但有自己的独立执行流。线程是操作系统进行调度和执行的基本单位，它使得程序能够同时执行多个任务。 我们要明白线程存在的问题： 线程并不便宜。线程需要进行上下文切换，成本很高。 线程不是无限的。可启动的线程数量受到底层 操作系统 的限制。在服务器端应用程序中，这可能会造成严重瓶颈。 线程并非总是可用。有些平台（如 JavaScript）甚至不支持线程。 线程并非易事。调试线程和避免竞态条件是我们在多线程编程中经常遇到的问题。 多线程的两种模型 一对一模型（One-to-One Model）： 每个用户级（语言）线程（应用线程）都映射到一个内核级（系统）线程。 优点：充分利用多核处理器，可以实现真正的并行执行。 缺点：线程的创建和切换开销较大，特别是在线程数量较多的情况下。 M:N 模型 并发模型 OS 线程： 无需改变编程模型，线程间同步困难，性能开销大 线程池可以降低一些成本，但难以支撑大量1O绑定的工作 Event-driven 模型： 与回调函数一起用，可能高效 非线性的控制流，数据流和错误传播难以追踪 Coroutines: 类似线程，无需改变编程模型 类似 async，支持大量任务 抽象掉了底层细节（这对系统编程、自定义运行时的实现很重要） Actor 模型： 将所有并发计算划分为 actor，消息通信易出错 可以有效的实现 actor 模型，但许多实际问题没解决（例如流控制、重试逻辑） Async/await、Future Futures, promises, and others 这种方法要求我们在编程方式上做出一系列改变： 不同的编程模型。与回调类似，编程模式也从自上而下的命令式方法转变为链式调用的组合模式。在这种模式下，循环、异常处理等传统程序结构通常不再有效。 不同的应用程序接口。通常需要学习全新的 API，如 thenCompose 或 thenAccept，不同平台的 API 也会有所不同。 特定的返回类型。返回类型脱离了我们所需的实际数据，而是返回一个新的 Promise 类型，这就需要进行内省。 错误处理可能很复杂。错误的传播和链式的调用并不总是那么直观、简单。 Reactive extensions 反应式扩展 Reactive Extensions (Rx) 由 Erik Meijer 引入 C#。虽然它在 .NET 平台上得到了广泛应用，但直到 Netflix 将其移植到 Java 并命名为 RxJava 后，它才真正成为主流应用。从那时起，包括 JavaScript (RxJS) 在内的各种平台都有了大量的移植版本。 Rx 背后的理念是转向所谓的可观察流，即我们现在将数据视为流（无限量的数据），而这些流是可以被观察到的。在实际应用中，Rx 就是简单的观察者模式（Observer Pattern），通过一系列扩展，我们可以对数据进行操作。 在方法上，它与 Futures 非常相似，但我们可以认为 Futures 返回的是离散元素，而 Rx 返回的是数据流。不过，与前者类似，它也为我们的编程模型引入了一种全新的思维方式，著名的说法是 “everything is a stream, and it’s observable”。 这意味着处理问题的方式不同了，与我们在编写同步代码时的习惯相比，有了很大的转变。与 Futures 相比，Rx 的一个好处是，由于它已被移植到如此多的平台上，因此无论我们使用 C#、Java、JavaScript 或任何其他可用 Rx 的语言，一般都能找到一致的 API 体验。此外，Rx 在错误处理方面也确实引入了一种更好的方法。 Coroutines Coroutines：“协程” 是一种可暂停计算的思想，即函数可以在某个时刻暂停执行，稍后再恢复执行。 协程的好处之一是，对于开发人员来说，编写非阻塞代码与编写阻塞代码本质上是一样的。编程模型本身并没有真正改变。 Coroutines 并不是一个新概念，它们已经存在了几十年，在 Go 等其他编程语言中很流行。 以上内容摘自 Kotlin 官网。 多线程可能出现的问题 执行的顺序无法预测、死锁、竞态条件…… 锁 在计算机编程中，锁是一种同步机制，用于控制多个线程或进程对共享资源的访问。锁的目的是防止多个线程同时修改共享数据，从而避免数据不一致或其他并发问题。 以下是几种常见的锁类型： 互斥锁（Mutex）：互斥锁是最基本的锁类型之一。在任意时刻，只有一个线程可以持有互斥锁，其他线程必须等待释放锁后才能获取。这确保了同一时刻只有一个线程能够执行被保护的代码段，从而防止数据竞争。 信号量（Semaphore）：信号量是一种更为通用的同步机制，它不仅可以用于互斥访问共享资源，还可以用于控制同时访问某个资源的线程数量。信号量维护一个计数器，线程可以通过执行P（等待）和V（释放）操作来增加或减少计数器的值。 读写锁（Read-Write Lock）：读写锁允许多个线程同时读取共享资源，但只有一个线程能够写入。这种锁适用于读操作频繁而写操作较少的场景，提高了并发性。 自旋锁（Spin Lock）：自旋锁是一种不会使线程进入睡眠状态的锁。当线程尝试获取自旋锁而发现它已经被其他线程持有时，它会一直循环（自旋）等待，直到锁被释放。 条件变量（Condition Variable）：条件变量通常与互斥锁一起使用，用于线程之间的通信。一个线程可以等待某个条件成立，而另一个线程在满足条件时发送信号，唤醒等待的线程。 轻量级锁（Lightweight Locking）：通常用于优化互斥锁的性能。轻量级锁尝试通过使用一些特殊的硬件指令来减小锁的开销，以提高并发性。 递归锁（Recursive Lock）：允许同一线程多次获取同一个锁，而不会造成死锁。线程必须释放相同数量的锁，才能完全释放锁。 锁在多线程和多进程编程中都是非常重要的工具，正确地使用锁可以确保程序在并发环境下的正确性和稳定性。然而，不正确的锁使用可能导致死锁、竞态条件等问题，因此在设计并发程序时需要谨慎使用和管理锁。 除了上述提到的常见锁类型之外，还有一些其他特定场景或特性的锁，这里列举一些： 分布式锁（Distributed Lock）：用于分布式系统中的多个节点之间同步访问共享资源。分布式锁需要考虑网络延迟、节点故障等问题，以确保在整个分布式系统中的一致性。 公平锁（Fair Lock）：公平锁保证等待时间最长的线程最先获得锁，以确保资源的公平分配。相对于非公平锁，公平锁可能导致更大的性能开销。 写入优先锁（Write-Priority Lock）：允许写入操作优先于读取操作，适用于写入操作频繁但读取操作较少的场景。 悲观锁（Pessimistic Lock）：在整个访问过程中保持资源锁定，适用于并发写入较多的情况。常见的悲观锁包括数据库中的排他锁。 乐观锁（Optimistic Lock）：在大部分时间内不加锁，只在更新时检查是否有其他线程对数据进行了修改。如果检测到冲突，再采取相应的处理措施，例如重试或放弃更新。 时间锁（Timed Lock）：允许线程在尝试获取锁时设置最大等待时间，超过该时间仍未获取到锁则放弃。 自适应自旋锁（Adaptive Spin Lock）：根据锁的争用程度动态调整自旋等待时间，以提高性能。 多粒度锁（Multi-Granularity Lock）：允许在不同层次上锁定资源，以提高并发性。 这些锁类型的选择取决于具体的应用场景和性能需求。在设计并发系统时，开发者需要仔细考虑并选择适当的锁机制，以确保系统的正确性、性能和可维护性。 死锁 死锁是多线程或多进程并发编程中一种常见的问题，它发生在两个或多个线程（或进程）相互等待对方释放资源的情况下，导致它们都无法继续执行。死锁通常涉及多个锁，而线程或进程之间的相互等待形成一个闭环。 死锁产生的主要原因包括： 互斥条件（Mutual Exclusion）：资源具有排他性，即一次只能由一个线程或进程占用。如果一个线程已经占用了一个资源，其他线程必须等待。 占有且等待（Hold and Wait）：一个线程在持有资源的同时等待其他资源，而其他线程则可能持有其需要的资源。这样的循环等待可能导致死锁。 不可抢占（No Preemption）：一个线程在没有释放资源的情况下，其他线程无法强制抢占它占用的资源，只能等待。 环路等待（Circular Wait）：存在一个等待循环，使得每个线程都在等待下一个线程释放资源，形成一个环路。 避免死锁的一般方法包括： 按顺序获取锁：规定线程获取锁的顺序，使得所有线程都按照相同的顺序获取锁，从而避免循环等待。 使用超时机制：允许线程在等待一段时间后放弃对资源的请求，以避免死锁。 资源分配策略：确保系统在资源分配时不会导致死锁，可以采用银行家算法等策略。 死锁检测和恢复：定期检测系统中是否存在死锁，并在检测到死锁时采取措施进行恢复，例如强制终止某些线程。 使用锁的层次性：按照资源的层次性进行加锁，确保每个线程按照相同的顺序获取锁。 注意，死锁的发生不仅仅取决于锁的使用，还与程序的设计、资源管理和线程调度等因素有关。因此，在设计并发系统时，需要仔细考虑这些因素，以降低死锁的发生概率。"}]